[{"title":"redis设计与实现读书笔记-多机数据库的实现","date":"2020-03-19T14:21:30.000Z","path":"posts/redis-three/","text":"前言经过前两篇读书笔记的整理对redis设计与实现这本书梳理了下,当然我的梳理稍显粗糙,因为很多内容在书上介绍的比较清楚,而这本书就在我手头上,我在笔记中就不再赘述,有资源的最好读原书,看一本好书的时候最直观的感受就是这本书看的很顺畅,津津有味,对很多之前的疑惑有解谜的作用,而不是逼着自己今天看几页,明天看几页,而这本书就是让我感觉比较舒服的一本,接下来这篇重点介绍redis的主从复制,哨兵模式和集群,这里也是很多面试爱问的点. 复制这里的复制,指的就是我们都懂的主从复制.书中讲述了redis2.8版本之前的复制原理和2.8之后的复制原理,接下来描述中旧版指的就是2.8版本之前的,新版指的就是2.8版本之后的. 旧版复制功能的实现Redis的复制功能分为同步(sync)和命令传播(command propagate)两个操作: 同步操作将从服务器的数据库状态更新至主服务器当前所处的数据库状态 命令传播操作用于当主服务器数据库状态被修改,导致主从不一致时,使主从数据库重新回到一致状态 同步当客户端向从服务器发送SLAVEOF命令要求从服务器复制主服务器的时候,从服务器首先执行的就是同步操作. 从服务器会向主服务器发送SYNC命令来完成同步,大致过程如下: 从服务器向主服务器发送SYNC命令 主服务器收到命令后执行BGSAVE命令,在后台生成RDB文件,并使用一个缓冲区来记录从现在开始执行的所有写命令 当主服务器执行完BGSAVE命令之后,主服务器会将生成的RDB文件发送给从服务器,从服务接受并载入文件,使自己数据库状态更新至主服务器执行BGSAVE命令时的数据库状态 主服务器将记录在缓冲区里面的所有写命令发送给从服务器,从服务器收到后执行,使自己数据库状态更新至主服务器当前的数据库状态 命令传播当同步之后,主从服务器处于一致状态,但是当主服务器执行新的写命令之后,两者又不一致了,这时候主服务器会将刚才执行的写命令发送给从服务器让其执行,以使两者重新一致,这个过程就是命令传播 旧版复制功能缺陷旧版复制分为以下两种情况: 初次复制: 从服务器之前没有复制过现在要复制的这台主服务器 断线后重复制: 处于命令传播阶段的主从服务器因为网络原因中断复制,之后从服务器通过自动重连重新接上了主服务器,并继续复制主服务器 缺陷之处: 对于初次复制,旧版复制有很好的支持,问题就在于断线后复制,在断线后复制的时候,理想的状态是将断线前从服务器目前复制到的位置之后所有的内容进行复制,但是旧版的断线复制,却是重新执行了所有的复制操作,依然是从服务器向主服务器发送SYNC指令,之后主服务器在后台生成对应的RDB文件……,将之前的老路重新走了一遍,这其实非常消耗性能 新版复制功能的实现为了解决旧版断线重连后复制的低效问题,新版采用了PSYNC命令代替SYNC命令来执行复制时的同步操作. PSYNC有完整重同步和部分重同步两种模式: 完整从同步与初次复制的步骤类似 部分重同步就是主服务器只将主从服务器断开这段时间执行的指令发给从服务器执行 可以看到部分重同步的开销比之前旧版的小了很多,实现部分重同步的三个部分如下: 主服务器的复制偏移量(replication offset)和从服务器的复制偏移量 主服务器的复制积压缓冲区(replication backlog) 服务器的运行ID(run ID) 复制偏移量主服务器和从服务器在执行复制的过程中会分别维护一个复制偏移量: 主服务器每次向从服务器传播N个字节时,会在自己的复制偏移量上加N;而从服务器每次收到从主服务器传播来的N个字节的数据时,也会在自己的复制偏移量上加N 通过对主从复制偏移量的对比,可以判断主从服务器是否处于一致状态:如果复制偏移量相同,说明处于一致状态,否则不一致. 假设断线重连后,从服务器向主服务器发送PSYNC命令,同时汇报自己的复制偏移量,那么主服务器如何判断是该对从服务器进行全部重同步还是部分重同步,如果是部分重同步,又如何判断要传递的数据是哪些呢,这些都和复制积压缓冲区有关 复制积压缓冲区复制积压缓冲区是由主服务器维护的一个固定长度(fixed-size)先进先出(FIFO)队列,默认大小为1MB 当主服务器向从服务器进行命令传播时,它会同时将命令放入复制积压缓冲区,如下图所示 复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量,如下表: 偏移量 10087 10088 10089 10090 10091 10092 10093 10095 10096 10096 字节值 ‘*’ 3 ‘\\r’ ‘\\n’ ‘$’ 3 … ‘S’ ‘E’ ‘T’ 当主从断线重连之后,从服务器向主服务器发送PSUNC命令同时汇报自己的复制偏移量offset之后,主服务器会拿着这个复制偏移量去复制积压缓冲区中查看,如果从该offset开始往后的数据仍然存在,就执行部分重同步,如果已经不存在了,就执行完整重同步操作. 复制积压加缓冲区的大小可以在配置文件中配置:repl-backlog-size 服务器运行ID除了复制偏移量和复制积压缓冲区之外,实现部分重同步还需要用到服务器运行ID 每个redis服务器,不论主从都有自己的运行ID 运行ID在服务器启动时自动生成,由40个随机的16进制字符组成,如:53b9b28df…. 当从服务器对主服务器进行初次复制的时候,主服务器会将自己的运行ID传送给从服务器,从服务器会将这个运行ID保存起来,当断线重连后,从服务器会向主服务器发送这个运行ID,如果与当前主服务器的运行ID相同,则可以由主服务器根据情况判断是否可以执行部分重同步,如果这个ID和当前主服务器的ID不同,那么直接执行完整重同步. PSYNC命令的实现PSYNC命令的调用方法有两种情况: 如果从服务器之前没有复制过任何主服务器,或者之前执行过SLAVEOF NO ONE命令,那么从服务器在开始一次新的复制时将向主服务器发送PSYNC ? -1命令,主动请求主服务器进行完整重同步 如果从服务器已经复制过某个主服务器,那么重连后从服务器将向主服务器发送PSYNC runid offset命令,runid是上次复制的主服务器运行id,offset是从服务器的复制偏移量,之后主服务器会根据收到的信息判定是进行部分重同步还是完整重同步 关于复制过程的整体实现过程,可以看原书15.6节-复制的实现 Sentinel哨兵模式哨兵模式是redis为保证高可用所提供的解决方案,由一个或多个哨兵组成的哨兵系统,监控系统中任意多个主服务器以及这些主服务器下的所有从服务器,当发生故障的时候,比如主服务器挂了,哨兵可以通过选举机制产生新的主服务器并进行故障转移,从而保证可用性 启动并初始化sentinel启动一个sentinel可以使用命令: redis-sentinel /path/to/your/sentinel.conf或者命令redis-server /path/to/your/sentinel.conf --sentinel 当一个sentinel启动时,需要执行以下步骤: 初始化服务器 将普通redis服务器使用的代码替换成sentinel专用代码 初始化sentinel状态 根据指定的配置文件,初始化sentinel监视的主服务器列表 创建连向主服务器的网络连接 初始化服务器sentinel本质上只是一个运行在特殊模式下的redis服务器,因为sentinel并不使用数据库,所以初始化sentinel的时候就不会载入RDB文件或者AOF文件 使用sentinel专用代码该步骤中将一部分普通redis使用的代码替换成sentinel专用代码,特别指出PING SENTINEL INFO SUBSCRIBE UNSUBSCRIBE PSUBSCRIBE 和 PUNSUBSCRIBE这七个命令是客户端可以对sentinel执行的全部命令 初始化sentinel状态在应用了sentinel专用代码之后,服务器会初始化一个sentinel.c/sentinelState结构(sentinel状态),这个结构保存了服务器所有与sentinel功能有关的状态(服务器的一般状态仍然由redis.h/redisServer结构保存): 1234567891011121314151617struct snetinelState&#123; //当前纪元,用于实现故障转移(选举机制会用到) uint64_t current_epoch; //保存了所有被这个sentinel监视的主服务器 //字典的键是主服务器的名字,值是一个指向sentinelRedisInstance结构的指针 dict *masters; //是否进入了TILT模式; int tilt; //目前正在执行的脚本的数量 int running_scripts; //进入TITL模式的时间 mstime_t titl_start_time; //最后一次执行时间处理器的时间 mstime_t previous_time; //一个FIFO队列,包含了所有需要执行的用户脚本 list *scripts_queue; &#125;sentinel 初始化sentinel状态的masters属性每个sentinelRedisInstance(实例结构)结构代表一个被sentinel监视的redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个sentinel.实例结构包含的属性较多,下面代码展示了作为主服务器使用时用到的一部分属性: 1234567891011121314151617181920212223242526typedef struct sentinelRedisInstance&#123; //标识值,记录了实例的类型以及该实例的当前状态 int flags; //实例的名字,主服务的名字由用户在配置文件中配置,从服务器以及sentinel的名字由sentinel自动设置 //格式为ip:port,比如\"127.0.0.1:26379\" char *name; //实例的运行id char *runid; //配置纪元,用于实现故障转移 uint64_t config_epoch; //实例的地址 sentinelAddr *addr; //SENTINEL down-after-milliseconds选项设定的值 //实例无响应多少毫秒之后才会被判断为主观下线(subjectively down) mstime_t down_after_period; //SENTINEL monitor &lt;master-name&gt; &lt;IP&gt; &lt;port&gt; &lt;quorum&gt;选项中的quorum参数 //判断这个实例为客观下线(objectively down)所需的支持投票数量 int quorum; //SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt;选项的值 //在执行故障转移时,可以同时对新的主服务器执行同步的从服务器数量 int parallel_syncs; //SENTINEL failover-timeout&lt;master-name&gt; &lt;ms&gt; 选项的值 //刷新故障迁移状态的最大时限 mstime_t failover_timeout; //...&#125;sentinelRedisInstance sentinelRedisInstance.addr属性是一个指向sentinel.c/sentinelAddr结构的指针,这个结构保存着实例的IP地址和端口号: 1234typedef struct sentinelAddr&#123; char *ip; int port;&#125;sentinelAddr 对sentinel状态的初始化将引发对master字典的初始化,masters字典的初始化时根据被载入的sentinel配置文件来进行的. 创建连向主服务器的网络连接初始化sentinel的最后一步是创建连向被监视主服务器的网络连接,sentinel将成为主服务器的客户端,它可以向主服务器发送命令,并从命令回复中获取相关信息. 对于每个被sentinel监视的主服务器来说,sentinel会创建两个连向主服务器的异步网络连接: 一个是命令连接,这个连接专门用于向主服务器发送命令,并接受命令回复 另一个是订阅连接,这个连接专门用于订阅主服务器的_sentinel_:hello频道 获取主服务器信息sentinel会默认以每十秒一次的频率,通过命令连接向被监视的主服务器发送INFO命令,并通过分析命令回复来获取主服务器当前的信息,包括: 主服务器本身的信息:runid,role(服务器角色) 主服务器下所有从服务器信息,sentinel无须用户提供从服务器的地址,可以自动根据主服务器的回复获取 获取从服务器信息同样的,sentinel会默认以每十秒一次的频率,通过命令连接向从服务器发送INFO命令,并通过分析命令回复来获取从服务器当前的信息,包括: 从服务器的运行ID run_id 从服务器的角色role 主服务器的ip地址master_host,以及主服务区的端口号master_port 主从服务器的连接状态master_link_status 从服务器的优先级slave_priority 从服务器的复制偏移量slave_repl_offeset(这个在主服务器挂了,重新选主的时候有用) 向主服务器和从服务器发送信息 默认情况下,sentinel会以每两秒一次的频率,通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令: PUBLISH _sentinel_:hello “&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot; 该命令向服务器的_sentinel_:hello频道发送了一条信息,参数中以s_开头的是 sentinel本身的信息,m_开头的记录的是主服务器的信息,如果此时监控的是主服务器,就是主服务器自己的信息,如果监控的是从服务器,也是从服务器对应主服务器的信息 接收来自主服务器和从服务器的频道信息当sentinel与一个主服务器或者从服务器建立起连接之后,sentinel就会通过订阅连接,向服务器发送以下命令: SUBSCRIBE _sentinel_:hello sentinel对 _sentinel_:hello频道的订阅会一直持续到sentinel与服务器断开为止,也就是说对于每个与sentinel连接的服务器,sentinel既通过命令连接向服务器的_sentinel_:hello 频道发送信息,又通过订阅连接从服务器的该频道接收信息. 用户在使用sentinel的时候不需要提供各个sentinel的地址信息,监视同一个主服务器的多个sentinel可以自动发现对方. sentinel在连接主服务器或者从服务器的时候会同时创建命令连接和订阅连接,但是在连接其他sentinel的时候只会创建命令连接而不创建订阅连接. 主观下线 所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。 主观下线就是说如果服务器在down-after-milliseconds给定的毫秒数之内， 没有返回 Sentinel 发送的 PING 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（SDOWN ）。 sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（master，从服务，其他sentinel）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。sentinel配置文件中的down-after-milliseconds设置了判断主观下线的时间长度，如果实例在down-after-milliseconds毫秒内，返回的都是无效回复，那么sentinel回认为该实例已（主观）下线，修改其flags状态为SRI_S_DOWN。如果多个sentinel监视一个服务，有可能存在多个sentinel的down-after-milliseconds配置不同，这个在实际生产中要注意。 客观下线客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断，然后开启failover。 客观下线就是说只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。 只有当master被认定为客观下线时，才会发生故障迁移。 当sentinel监视的某个服务主观下线后，sentinel会询问其它监视该服务的sentinel，看它们是否也认为该服务主观下线，接收到足够数量（这个值可以配置）的sentinel判断为主观下线，既认为该服务客观下线，并对其做故障转移操作。 sentinel通过发送 SENTINEL is-master-down-by-addr ip port current_epoch runid，（ip：主观下线的服务ip，port：主观下线的服务端口，current_epoch：sentinel的纪元，runid：*表示检测服务下线状态，如果是sentinel 运行id，表示用来选举领头sentinel）来询问其它sentinel是否同意服务下线。 一个sentinel接收另一个sentinel发来的is-master-down-by-addr后，提取参数，根据ip和端口，检测该服务是否在该sentinel主观下线，并且回复is-master-down-by-addr，回复包含三个参数：down_state（1表示已下线，0表示未下线），leader_runid（领头sentinal id），leader_epoch（领头sentinel纪元）。 sentinel接收到回复后，根据配置设置的下线最小数量，达到这个值，既认为该服务客观下线。 客观下线条件只适用于主服务器： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。 在redis-sentinel的conf文件里有这么两个配置：1）sentinel monitor &lt;masterName&gt; &lt;ip&gt; &lt;port&gt; &lt;quorum&gt; 四个参数含义：masterName这个是对某个master+slave组合的一个区分标识（一套sentinel是可以监听多套master+slave这样的组合的）。ip 和 port 就是master节点的 ip 和 端口号。quorum这个参数是进行客观下线的一个依据，意思是至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。 2）sentinel down-after-milliseconds ** &lt; **masterName &gt; &lt;timeout&gt;这个配置其实就是进行主观下线的一个依据，masterName这个参数不用说了，timeout是一个毫秒值，表示：如果这台sentinel超过timeout这个时间都无法连通master包括slave（slave不需要客观下线，因为不需要故障转移）的话，就会主观认为该master已经下线（实际下线需要客观下线的判断通过才会下线） 那么，多个sentinel之间是如何达到共识的呢？某个sentinel先将master节点进行主观下线，然后会将这个判定通过sentinel is-master-down-by-addr这个命令问对应的节点是否也同样认为该addr的master节点要做客观下线。最后当达成这一共识的sentinel个数达到前面说的quorum设置的这个值时，就会对该master节点下线进行故障转移。quorum的值一般设置为sentinel个数的二分之一加1，例如3个sentinel就设置2。 选举领头sentinel 一个redis服务被判断为客观下线时，多个监视该服务的sentinel协商，选举一个领头sentinel，对该redis服务进行故障转移操作。选举领头sentinel遵循以下规则： 1）所有的sentinel都有公平被选举成领头的资格。2）所有的sentinel都有且只有一次将某个sentinel选举成领头的机会（在一轮选举中），一旦选举某个sentinel为领头，不能更改。3）sentinel设置领头sentinel是先到先得，一旦当前sentinel设置了领头sentinel，以后要求设置其他sentinel为领头请求都会被拒绝。4）每个发现服务客观下线的sentinel，都会要求其他sentinel将自己设置成领头。5）当一个sentinel（源sentinel）向另一个sentinel（目标sentinel）发送is-master-down-by-addr ip port current_epoch runid命令的时候，runid参数不是*，而是sentinel运行id，就表示源sentinel要求目标sentinel选举其为领头。6）源sentinel会检查目标sentinel对其要求设置成领头的回复，如果回复的leader_runid和leader_epoch为源sentinel，表示目标sentinel同意将源sentinel设置成领头。7）如果某个sentinel被半数以上的sentinel设置成领头，那么该sentinel既为领头。8）如果在限定时间内，没有选举出领头sentinel，暂定一段时间，再选举。 故障转移所谓故障转移就是当master宕机，选一个合适的slave来晋升为master的操作，redis-sentinel会自动完成这个，不需要我们手动来实现。 一次故障转移操作大致分为以下流程：发现主服务器已经进入客观下线状态。对我们的当前集群进行自增， 并尝试在这个集群中当选。如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤： 选出一个从服务器，并将它升级为主服务器。向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。向已下线主服务器的从服务器发送 SLAVEOF 命令， 让它们去复制新的主服务器。当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。 Sentinel 使用以下规则来选择新的主服务器： 在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。 在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。 在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出复制偏移量（replication offset）最大的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么带有最小运行 ID 的那个从服务器成为新的主服务器。 Sentinel 自动故障迁移的一致性特质 Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。 这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。 更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。 简单来说， 可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。 举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。 如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。 Sentinel 状态的持久化 Sentinel 的状态会被持久化在 Sentinel 配置文件里面。每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。这意味着停止和重启 Sentinel 进程都是安全的。 Sentinel 在非故障迁移的情况下对实例进行重新配置即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是： 根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。 不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。 总结来说，故障转移分为三个步骤： 1）从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务sentinel状态数据结构中保存了主服务的所有从服务信息，领头sentinel按照如下的规则从从服务列表中挑选出新的主服务；删除列表中处于下线状态的从服务；删除最近5秒没有回复过领头sentinel info信息的从服务；删除与已下线的主服务断开连接时间超过 down-after-milliseconds*10毫秒的从服务，这样就能保留从的数据比较新（没有过早的与主断开连接）；领头sentinel从剩下的从列表中选择优先级高的，如果优先级一样，选择偏移量最大的（偏移量大说明复制的数据比较新），如果偏移量一样，选择运行id最小的从服务。 2）已下线主服务的所有从服务改为复制新的主服务挑选出新的主服务之后，领头sentinel 向原主服务的从服务发送 slaveof 新主服务 的命令，复制新master。 3）将已下线的主服务设置成新的主服务的从服务，当其回复正常时，复制新的主服务，变成新的主服务的从服务同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从。 温馨提示：还可以向任意sentinel发生sentinel failover 进行手动故障转移，这样就不需要经过上述主客观和选举的过程。 集群模式 Redis Cluster实现在多个节点之间进行数据共享，即使部分节点失效或者无法进行通讯时，Cluster仍然可以继续处理请求。若每个主节点都有一个从节点支持，在主节点下线或者无法与集群的大多数节点进行通讯的情况下， 从节点提升为主节点，并提供服务，保证Cluster正常运行，Redis Cluster的节点分片是通过哈希槽（hash slot）实现的，每个键都属于这 16384（0～16383） 个哈希槽的其中一个，每个节点负责处理一部分哈希槽。 数据shardingRedis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个节点， 其中： 节点 A 负责处理 0 号至 5500 号哈希槽。 节点 B 负责处理 5501 号至 11000 号哈希槽。 节点 C 负责处理 11001 号至 16384 号哈希槽。 这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说： 如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。 如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。 因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线 集群内部数据结构Redis Cluster功能涉及三个核心的数据结构clusterState、clusterNode、clusterLink都在cluster.h中定义。这三个数据结构中最重要的属性就是：clusterState.slots、clusterState.slots_to_keys和clusterNode.slots了，它们保存了三种映射关系： clusterState：集群状态 nodes：所有结点 migrating_slots_to：迁出中的槽 importing_slots_from：导入中的槽 slots_to_keys：槽中包含的所有Key，用于迁移Slot时获得其包含的Key slots：Slot所属的结点，用于处理请求时判断Key所在Slot是否自己负责 clusterNode：结点信息 slots：结点负责的所有Slot，用于发送Gossip消息通知其他结点自己负责的Slot。通过位图方式保存节省空间，16384/8恰好是2048字节，所以槽总数16384不能随意定！ clusterLink：与其他结点通信的连接 集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count 也被放到了这个结构里面。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687typedef struct clusterState &#123; ... //指向当前节点的指针 clusterNode *myself; /* This node */ //集群当前的状态：是在线还是下线 int state; /* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */ //集群当前的配置纪元,用于实现故障转移 uint64_t currentEpoch; //集群中至少处理着一个槽的节点的数量 int size; //集群节点名单（包括 myself 节点） //字典的键为节点的名字，字典的值为 clusterNode 结构 dict *nodes; /* Hash table of name -&gt; clusterNode structures */ //记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点 //migrating_slots_to[i] = NULL 表示槽 i 未被迁移 //migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS]; //记录要从源节点迁移到本节点的槽，以及进行迁移的源节点 //importing_slots_from[i] = NULL 表示槽 i 未进行导入 //importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS]; //负责处理各个槽的节点 //例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理 clusterNode *slots[REDIS_CLUSTER_SLOTS]; //跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序 //当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便 //具体操作定义在 db.c 里面 zskiplist *slots_to_keys; ...&#125; clusterState; //节点状态struct clusterNode &#123; ... //创建节点的时间 mstime_t ctime; //从节点的名字,由40个十六进制字符组成 char name[REDIS_CLUSTER_NAMELEN]; //节点标识 //使用各种不同的标识值记录节点的角色（比如主节点或者从节点）， //以及节点目前所处的状态（比如在线或者下线）。 int flags; /* REDIS_NODE_... */ //节点当前的配置纪元,用于实现故障转移 uint64_t configEpoch; //节点的ip地址 char ip[REDIS_IP_STR_LEN] //节点的端口号 int port; //由这个节点负责处理的槽 //一共有 REDIS_CLUSTER_SLOTS / 8 个字节长 //每个字节的每个位记录了一个槽的保存状态 //位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理 //比如 slots[0] 的第一个位保存了槽 0 的保存情况 //slots[0] 的第二个位保存了槽 1 的保存情况，以此类推 unsigned char slots[REDIS_CLUSTER_SLOTS/8]; /* slots handled by this node */ //指针数组，指向各个从节点 struct clusterNode **slaves; /* pointers to slave nodes */ //如果这是一个从节点，那么指向主节点 struct clusterNode *slaveof; /* pointer to the master node */ ... //保存连接点所需的有关信息 clusterLink *link;&#125;; /* clusterLink encapsulates everything needed to talk with a remote node. *///clusterLink 包含了与其他节点进行通讯所需的全部信息typedef struct clusterLink &#123; ... //TCP 套接字描述符 int fd; /* TCP socket file descriptor */ //输出缓冲区,保存着等待发送给其他节点的消息(message) sds sndbuf; //输入缓冲区,保存着从其他节点收到的消息 sds rcvbuf; //与这个连接相关联的节点，如果没有的话就为 NULL struct clusterNode *node; /* Node related to this link if any, or NULL */ ...&#125; clusterLink; Redis Cluster集群的处理流程在单机模式下，Redis对请求的处理很简单。Key存在的话，就执行请求中的操作；Key不存在的话，就告诉客户端Key不存在。然而在集群模式下，因为涉及到请求重定向和Slot迁移，所以对请求的处理变得很复杂，流程如下： 检查Key所在Slot是否属于当前Node？ 计算crc16(key) % 16384得到Slot 查询clusterState.slots负责Slot的结点指针 与myself指针比较 若不属于，则响应MOVED错误重定向客户端 若属于且Key存在，则直接操作，返回结果给客户端 若Key不存在，检查该Slot是否迁出中？(clusterState.migrating_slots_to) 若Slot迁出中，返回ASK错误重定向客户端到迁移的目的服务器上 若Slot未迁出，检查Slot是否导入中？(clusterState.importing_slots_from) 若Slot导入中且有ASKING标记，则直接操作 否则响应MOVED错误重定向客户端 Redis Cluster容错机制failover是redis cluster的容错机制，是redis cluster最核心功能之一；它允许在某些节点失效情况下，集群还能正常提供服务。 redis cluster采用主从架构，任何时候只有主节点提供服务，从节点进行热备份，故其容错机制是主从切换机制，即主节点失效后，选取一个从节点作为新的主节点。在实现上也复用了旧版本的主从同步机制。 从纵向看，redis cluster是一层架构，节点分为主节点和从节点。从节点挂掉或失效，不需要进行failover，redis cluster能正常提供服务；主节点挂掉或失效需要进行failover。另外，redis cluster还支持manual failover，即人工进行failover，将从节点变为主节点，即使主节点还活着。下面将介绍这两种类型的failover。 1）主节点失效产生的failover （主）节点失效检测一般地，集群中的节点会向其他节点发送PING数据包，同时也总是应答（accept）来自集群连接端口的连接请求，并对接收到的PING数据包进行回复。当一个节点向另一个节点发PING命令，但是目标节点未能在给定的时限（node timeout）内回复时，那么发送命令的节点会将目标节点标记为PFAIL（possible failure）。 由于节点间的交互总是伴随着信息传播的功能，此时每次当节点对其他节点发送 PING 命令的时候，就会告知目标节点此时集群中已经被标记为PFAIL或者FAIL标记的节点。相应的，当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这称为失效报告（failure report）。 如果节点已经将某个节点标记为PFAIL，并且根据节点所收到的失效报告显式，集群中的大部分其他主节点（n/2+1）也认为那个节点进入了失效状态，那么节点会将那个PFAIL节点的状态标记为FAIL。 一旦某个节点被标记为FAIL，关于这个节点已失效的信息就会被广播到整个集群，所有接收到这条信息的节点都会将失效节点标记为FAIL。 选举主节点一旦某个主节点进入 FAIL 状态， 集群变为FAIL状态，同时会触发failover。failover的目的是从从节点中选举出新的主节点，使得集群恢复正常继续提供服务。整个主节点选举的过程可分为申请、授权、升级、同步四个阶段： 申请新的主节点由原已失效的主节点属下的所有从节点中自行选举产生，从节点的选举遵循以下条件：a、这个节点是已下线主节点的从节点；b、已下线主节点负责处理的哈希槽数量非空；c、主从节点之间的复制连接的断线时长有限，不超过 ( (node-timeout * slave-validity-factor) + repl-ping-slave-period ）。 如果一个从节点满足了以上的所有条件，那么这个从节点将向集群中的其他主节点发送授权请求，询问它们是否允许自己升级为新的主节点。从节点发送授权请求的时机会根据各从节点与主节点的数据偏差来进行排序，让偏差小的从节点优先发起授权请求。 授权其他主节点会遵信以下三点标准来进行判断：a、 发送授权请求的是从节点，而且它所属的主节点处于FAIL状态 ；b、 从节点的currentEpoch〉自身的currentEpoch，从节点的configEpoch&gt;=自身保存的该从节点的configEpoch；c、 这个从节点处于正常的运行状态，没有被标记为FAIL或PFAIL状态； ​ 如果发送授权请求的从节点满足以上标准，那么主节点将同意从节点的升级要求，向从节点返回 CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK授权。 升级一旦某个从节点在给定的时限内得到大部分主节点（n/2+1）的授权，它就会接管所有由已下线主节点负责处理的哈希槽，并主动向其他节点发送一个PONG数据包，包含以下内容：a、 告知其他节点自己现在是主节点了b、 告知其他节点自己是一个ROMOTED SLAVE，即已升级的从节点；c、告知其他节点都根据自己新的节点属性信息对配置进行相应的更新 同步其他节点在接收到ROMOTED SLAVE的告知后，会根据新的主节点对配置进行相应的更新。特别地，其他从节点会将新的主节点设为自己的主节点，从而与新的主节点进行数据同步。至此，failover结束，集群恢复正常状态。 此时，如果原主节点恢复正常，但由于其的configEpoch小于其他节点保存的configEpoch（failover了产生较大的configEpoch），故其配置会被更新为最新配置，并将自己设新主节点的从节点。 另外，在failover过程中，如果原主节点恢复正常，failover中止，不会产生新的主节点。 2）Manual FailoverManual Failover是一种运维功能，允许手动设置从节点为新的主节点，即使主节点还活着。Manual Failover与上面介绍的Failover流程大都相同，除了下面两点不同：a）触发机制不同，Manual Failover是通过客户端发送cluster failover触发，而且发送对象只能是从节点；b）申请条件不同，Manual Failover不需要主节点失效，failover有效时长固定为5秒，而且只有收到命令的从节点才会发起申请。 另外，Manual Failover分force和非force，区别在于：非force需要等从节点完全同步完主节点的数据后才进行failover，保证不丢失数据，在这过程中，原主节点停止写操作；而force不进行进行数据完整同步，直接进行failover。 3）集群状态检测集群有OK和FAIL两种状态，可以通过CLUSTER INFO命令查看。当集群发生配置变化时， 集群中的每个节点都会对它所知道的节点进行扫描，只要集群中至少有一个哈希槽不可用（即负责该哈希槽的主节点失效），集群就会进入FAIL状态，停止处理任何命令。另外，当大部分主节点都进入PFAIL状态时，集群也会进入FAIL状态。这是因为要将一个节点从PFAIL状态改变为FAIL状态，必须要有大部分主节点（n/2+1）认可，当集群中的大部分主节点都进入PFAIL时，单凭少数节点是没有办法将一个节点标记为FAIL状态的。 然而集群中的大部分主节点(n/2+1)进入了下线状态，让集群变为FAIL，是为了防止少数存着主节点继续处理用户请求，这解决了出现网络分区时，一个可能被两个主节点负责的哈希槽，同时被用户进行读写操作（通过禁掉其中少数派读写操作，证保只有一个读写操作），造成数据丢失数据问题。说明：上面n/2+1的n是指集群里有负责哈希槽的主节点个数。 参考文献Redis Cluster集群知识学习总结 redis系列：集群 高可用Redis：Redis Cluster redis cluster介绍 Redis哨兵模式（sentinel）学习总结及部署记录（主从复制、读写分离、主从切换)","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.enjoyican.com/tags/Redis/"}]},{"title":"redis设计与实现读书笔记-单机数据库的实现","date":"2020-03-18T14:52:30.000Z","path":"posts/redis-two/","text":"1. 数据库redis数据库的很多操作都是通过对键空间进行操作来实现的,比如添加,删除,更新,取值操作,比如用于清空整个数据库的FLUSHDB命令,用于返回数据库中随机键的RANDOMKEY,类似的命令还有EXISTS,RENAME,KEYS等. 当使用redis命令对数据库进行读写时,服务器不仅对键空间执行指定的读写操作,还会执行一些额外的维护操作,包括: 读取一个键后(包括读操作和写操作)更新键的命中(hit)或不命中(miss)的次数,这两个值可以在INFO stats命令的keyspace_hits属性和keyspace_misses属性中查看. 更新键的LRU(最后一次使用)时间,这个值可以用来计算键的闲置时间(为将来键删除算法做准备) 读取时如果发现键已经过期,就删除该键之后再执行剩下的操作 如果有客户端使用WATCH命令监视了某个键,那么服务器在对被监视的键进行修改之后,会将这个键标记为脏(dirty) 服务器每次修改一个键之后,都会对脏(dirty)键计数器的值增1,这个计数器会触发服务器的持久化和复制操作 设置过期时间redis有四个命令用来设置键的过期时间: EXPIRE &lt;key&gt; &lt;ttl&gt; 将键的生存时间设置为ttl秒 PEXPIRE &lt;key&gt; &lt;ttl&gt;将键的生存时间设置为ttl毫秒 EXPIRE &lt;key&gt; &lt;timestamp&gt; 将键的生存时间设置为timestamp所指定的秒数时间戳 PEXPIRE &lt;key&gt; &lt;timestamp&gt;将键的生存时间设置为timestamp所指定的毫秒数时间戳 以上四个命令,最终执行都是转换为第四个命令的执行方式执行的. 保存过期时间redisDb结构的expires字典保存了数据库中所有键的过期时间,这个字典叫做过期字典:过期字典是一个long long类型的整数,这个整数保存了键所指向的数据库键的过期时间(毫秒精度的UNIX时间戳) 移除过期时间PERSIST命令可以移除一个键的过期时间,用法 PERSIST key 计算并返回剩余生存时间TTL命令以秒为单位返回键的剩余生存时间,而PTTL命令则以毫秒为单位返回键的剩余生存时间,这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的 过期键删除策略 定时删除: 在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行键删除操作 优点: 对内存友好,通过使用定时器保证过期键会尽快删除,并释放掉占用的内存 缺点: 对CPU时间不友好,比如某一时刻过期键比较多,那就会占用比较多的CPU时间来删除 惰性删除: 平时不对键进行操作,当从键空间获取键的时候,检查键是否过期,过期的话就删除该键,没过期就返回 优点: 对CPU时间友好 缺点: 对内存不友好,比如一个键已经过期,但是没有及时删除,就会一直占用内存 定期删除: 每个一段时间对数据库进行检查,删除里面的过期键,至于删除多少,检查多少个数据库,由具体算法确定 定期删除是以上两种方案优缺点的折中,但是需要合理设定删除操作的执行时长和频率 redis实际采取的是惰性删除和定期删除两种策略 惰性删除策略由db.c/expireIfNeeded函数实现,所有读写数据库的命令(如SET LRANGE SADD HGET KEYS等)在执行之前都会调用该函数对键进行检查:如果已经过期该函数会将该键删除,否则不做操作. 定期删除策略由redis.c/activeExpireCycle函数实现,每当redis的服务器周期性操作redis.c/serverCron函数执行时,activeExpireCycle函数就会被调用. AOF/RDB和复制功能对过期键的处理生成RDB文件: 当执行SAVE或者BGSAVE命令创建新的RDB文件时,已过期的键不会被保存到新建的RDB文件中 载入RDB文件: 启动redis服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行载入.如果服务器以主服务器模式运行,载入RDB文件时,会对文件中保存的键进行检查,过期的键不会被载入;如果服务器以从服务器的模式运行,不论键是否过期,都会载入到数据库,但是由于主从服务器进行数据同步的时候从服务器的数据库就会清空,所以不会有什么影响. AOF文件写入: 当过期键被惰性删除或者定期删除之后,程序会向AOF文件追加一条DEL命令,来显式的记录该键已被删除 AOF重写: 在执行AOF重写的过程中会对数据库中的键进行检查,如果已经过期了的不会被保存到重写后的AOF文件 复制: 当服务器运行在复制模式下时,从服务器的过期键删除动作由主服务器控制: 主服务器删除一个键之后会显式的向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键 从服务器只有在接到主服务器发来的DEL命令之后,才会删除过期键 从服务器接到客户端发送的读命令时,即使碰到过期键也不会处理,还是会按照正常情况返回值 数据库通知数据库通知功能可以让客户端通过订阅给定的频道或模式,来获知数据库中键的变化,以及数据库中命令的执行情况,这类通知可以分为两类: 键空间通知(key-space notification): 关注某个键执行了什么命令,比如针对某个key执行了expire,set,del等 键事件通知(key-event notification): 关注某个命令被什么键执行了,比如del命令执行在哪些键上了 服务器配置的notify-keyspace-events选项决定了服务器所发送通知的类型: AKE : 发送所有类型的键空间和键事件通知 AK : 发送所有类型的键空间通知 AE : 发送所以类型的键事件通知 K$ : 只发送和字符串键有关的键空间通知 El : 只发送和list键有关的键事件通知 2. RDB持久化RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态. RDB文件的创建与载入有两个Redis命令可以用于生成RDB文件,一个是SAVE,另一个是BGSAVE,SAVE 命令会阻塞服务器进程,BGSAVE命令会派生出一个子进程,然后由子进程负责创建RDB文件. Redis并没有专门用于载入RDB文件的命令,只要服务器启动之后检测到RDB文件就会自动载入,由于AOF文件的更新频率通常比RDB文件的更新频率高,所以: 如果服务器开启了AOF持久化功能,则优先使用AOF文件来还原数据库状态 AOF持久化功能关闭时,会采用RDB文件来还原数据 服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止,BGSAVE命令可以在配置文件中配置每个一段时间自动执行,详见save 900 1...这一组配置 具体RDB文件保存的格式和内容建议直接看原书第10章内容 3.AOF持久化与RDB持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库的状态的,AOF持久化功能的实现分为命令追加(append),文件写入,文件同步(sync)三个步骤 命令追加当AOF持久化功能处于打开状态时,服务器在执行完一个写命令之后,会以协议格式将被执行的写命令追加到服务器状态的aof_buf缓冲区的末尾: 1234567struct redisServer&#123; // ... //AOF缓冲区 sds aof_buf; //...&#125; 例如:当客户端向服务器发送如下命令: redis &gt; SET KEY VALUE OK 服务器在执行完命令之后,会将以下协议内容追加到aof_buf缓冲区的末尾: *3\\r\\n$3\\r\\nSET\\r\\nKEY\\r\\n$5\\r\\nVALUE\\r\\n 文件的写入与同步 reids服务器进程就是一个事件循环(loop).这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像serverCron函数这样需要定时运行的函数. 由于服务器在处理文件事件时可能会执行写命令.在此期间一些内容被追加到aof_buf缓冲区中,所以在服务器每次结束一个事件循环之前,都会调用一个flushAppendOnlyFile函数,考虑是否将aof_buf缓冲区中内容写入和保存进AOF文件中,该函数的行为有服务器配置文件中的appendfsync选项中的值来决定,各个值的含义如下: appendfsync选项的值 flushAppendOnlyFile函数的行为 always 将缓冲区中的所有内容写入并同步到AOF文件 everysec (默认) 将缓冲区中的所有内容写入到AOF文件,如果上次同步距离现在时间超过1秒,那么再次对AOF文件进行同步,该同步行为有一个专门负责的线程 no 将缓冲区中的所有内容写入到AOF文件,但并不进行同步,何时同步由操作系统决定 AOF文件载入与数据还原因为AOF文件中记录了重建数据库所需要的所有写命令,所以服务器只要读入并重新执行一遍AOF文件中保存的写命令,就可以还原服务器关闭之前的数据库状态. AOF重写随着AOF文件中保存的指令越来越多,文件体积越来越大,这个时候需要对文件进行重写来缩小文件所占存储空间. AOF文件重写并不需要对现有AOF文件进行读取或者分析,是直接通过读取服务器当前的数据库状态实现的,比如当前数据库存在一个键值对,老的AOF文件中可能存储了对这个键值对的各种历史操作命令,重写的时候只要读取该键值对最新的状态将之前的多个指令合并成最后的一条指令保存即可,这就是AOF重写的原理 有个特殊的点是对于除了字符串之外的另外四种数据类型,如果一个键对应的元素个数很多,超过某个配置的值,会使用多条记录保存命令,而不只是一条. AOF文件的重写是通过一个子进程来执行的,使用子进程而不是线程,主要是为了在避免使用锁的情况下还能保证数据安全性.由于在子进程执行重写任务的过程中,可能主进程依然会执行新的命令.Redis设置了一个AOF重写缓冲区来存储在这段时间中主进程执行的新的指令.该缓冲区当子进程建立的时候开始使用 因此在子进程进行重写的过程中,如果主线程接收到新的命令,会将其同时保存在aof_buf缓冲区及AOF重写缓冲区中;而子进程在完成AOF重写工作后会给主进程发送一个信号,之后主进程收到信号并调用一个函数,执行以下工作: 将AOF重写缓冲区中的所有内容写入到新的AOF文件中,这时新的AOF文件所保存的数据库状态将和当前服务器的状态一致. 对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧文件的替换 这两个动作完成之后,主线程就可以继续接受新的指令了. 在整个AOF后台重写的过程中,只有该过程会对主进程造成阻塞,其他时间都是在后台进行,不影响主进程执行任务.","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.enjoyican.com/tags/Redis/"}]},{"title":"redis设计与实现读书笔记-数据结构与实现","date":"2020-03-17T13:19:30.000Z","path":"posts/redis-one/","text":"1. 简单动态字符串简单动态字符串(simple dynamic string,SDS)是redis的默认字符串表示,除此之外,SDS还被用做缓冲区(AOF模块中的AOF缓冲区和客户端状态中的输入缓冲区),AOF模块缓冲区指的是在做AOF备份的时候新增加的指令会缓冲到缓冲区,之后再发起部分同步到磁盘;客户端状态的输入缓冲区是指在服务端保存着客户端输入指令的一个缓冲区. SDS的表示结构如下: 12345678struct sdshdr&#123; //记录buf数组中已使用的字节的数量,等于SDS所保存字符串的长度 int len; //保存buf数组中未使用字节的数量 int free; //字节数组,用于保存字符串 char buf[]&#125; 以上两图为SDS存储示例.图1中free为0,表示该SDS没有分配任何未使用空间,len=5表示存储的字符串字节长度,buf指向保存数据的数组,结尾保存空字符串’\\0’,这是为了遵循C的保存习惯,以便可以使用部分C的函数,但不计入len的统计中.图二中free=5表示除了保存的redis字符串之外,还分配了5字节未使用的空间. 因为保存了字符串的长度,所以redis获取字符串的长度时间复杂度为O(1),同时可以杜绝缓冲区溢出,当需要修改SDS时,会先检查空间是否足够,不够的话会先扩展空间再保存新的数据. 通过buf中的free表示的未使用空间,SDS实现了空间预分配和惰性空间释放两种优化策略. 1.1 空间预分配当进行字符串增长操作,需要对SDS进行空间扩展时,程序会在分配修改所需的必要空间之外,再分配额外的未使用空间,分配策略如下: 如果修改之后SDS的长度小于1MB,那么程序将分配和修改之后len长度同样大小的未使用空间;如果修改之后的SDS长度大于1MB,那么程序将分配1MB的未使用空间. 1.2 惰性空间释放当进行字符串缩短操作时,修改后空余出来的空间并不会被立即释放,而是记录在free中,当下次进行字符串的扩展时,如果字符串长度小于free的值,就不需要进行空间扩展操作,通过这个策略避免了既避免了缩短字符串之后的内存重分配操作,又为将来的拓展留出空间,同时SDS提供了专门释放空间的api,不需要担心free空间太大造成的内存浪费. 以下是SDS字符串与C字符串的区别: 2. 链表链表在redis中的应用比较广泛,list类型的值对象底层实现之一就是链表,当列表键中包含了数量比较多的元素,或者包含的元素都是比较长的字符串时,就会使用链表(后面笔记中记录),除此之外发布与订阅,慢查询,监视器等功能也用到了链表,Redis服务器本身还用链表来保存多个客户端的状态信息以及构建客户端输出缓冲区. redis的链表实现是双端无环链表,其结构与示意图如下: 此外还通过list结构对链表进行持有,示意图及结构如下: 1234567891011121314typedef struct list&#123; //表头节点 listNode *head; //表尾节点 listNode *tail; //链表所包含的节点数量 unsigned long len; //节点值复制函数 void *(*dup)(void *ptr); //节点值释放函数 void (*free) (void *ptr); //节点值对比函数 int (*match)(void *ptr,void *key);&#125;list; 3. 字典字典中一个key对应一个value,每个key是唯一的,redis数据库底层就是使用字典实现,增删改查操作也是建立在对字典的操作之上.除此之外,字典还是值对象类型为hash时的底层实现,当一个hash值对象包含的数据比较多或者包含的数据的长度都比较长的时候,redis会使用字典作为其底层实现,而字典的底层又是使用哈希表实现,每个哈希表包含多个哈希节点每个哈希节点保存了字典中的一个键值对redis哈希表使用链地址法解决哈希冲突,多个冲突的节点通过next指针相链接,当有冲突时,新的节点放在其他节点的前面.当hash表中数据过多或者过少时,会通过rehash来重新分配空间(将原来小空间哈希表上的节点rehash保存到另外一个大空间哈希表上的,之后将原来的小表置空). 3.1 哈希表的扩展与收缩当以下条件中的任意一个满足时,程序会自动开始对hash表进行扩展操作: 1)服务器目前没有执行BGSAVE或者BGREWRITEAOF命令,且韩系表的负载因子大于等于1(负载因子=已保存的节点数量/哈希表大小) 2)服务器正在执行以上两个命令中的一个,但是负载因子大于等于5 当哈希表负载因子小于0.1,程序自动开始对哈希表执行收缩操作. 3.2 渐进式rehash当扩展或收缩哈希表的时候,需要对其中保存的键值对进行rehash,但是为了表面对服务器性能造成影响,并不是一次性rehash全部键值对而是分多次渐进式分配.渐进式rehash期间新增的键值对不会保存到老的哈希表中,会直接进入新hash表. 4. 跳表redis使用跳表(skiplist)作为zset对象类型的底层实现之一:当一个zset包含的元素数量比较多或者包含的成员都是比较长的字符串时redis中只在两个地方使用了跳表,一个是实现zset数据类型,另外一个是在集群节点中用作内部数据结构.同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是分值可以相同,分值相同时按照字典排序小的在前大的在后. 5. 整数集合整数集合(intset)值对象为set数据类型的底层实现之一,当一个集合质包含整数值元素,并且集合的元素数量不多时. intset是redis用来保存整数值的集合抽象数据结构,可以保存类型为int16_t,int32_t或者int64_t的整数值,并且保证 不会出现重复: 整数集合数据结构如下: 12345678typedef struct intset&#123; //编码方式 uint32_t encoding; //集合包含的元素数量 uint32_t length; //保存元素的数组 int8_t contents[];&#125;intset contents[]用于保存集合中的元素(按照值的大小从小到大,不重复) encoding中保存的编码方式决定了contents[]中保存的值类型,有三种对应关系,encoding(content)-&gt;INTSET_ENC_INT16(int16_t):可保存-32768~32767;INTSET_ENC_INT32(int32_t)可保存-2147483648~2147283647,INTSET_ENC_INT64(int64_t)可保存-9223372036854775808~9223372036854775807 升级当要将一个新元素添加到整数集合里时,如果新元素的类型比整数集合现有的所有元素的类型都长,整数集合会先进行升级,然后才将新元素添加进去,比如现有三个是int16_t,现在要添加一个int32_t会先将之前的三个转换为int32_t,然后再加入新元素.升级的好处一是提升整数集合的灵活性,另外能够节约内存空间,目前暂不支持降级 6. 压缩列表压缩列表(ziplist)是list和hash值对象的底层实现之一,当一个list只包含少数元素,并且每个元素要么是小整数值要么是长度比较短的字符串,或者一个hash键的值包含少量的键值对,并且每个键值对要么要么是小整数值要么是长度比较短的字符串. 压缩列表是redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型数据结构,一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值. 7. 对象7.1 对象类型与编码Redis使用对象来保存数据库中的键和值,分别为键对象和值对象.每个对象由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type,encoding和ptr: 123456789typedef struct redisObject&#123; //类型 unsigned type:4; //编码 unsigned encoding:4; //指向底层实现数据结构的指针 void *ptr; //...&#125; 对于redis数据库保存的键值对来说,键总是一个字符串对象,值可以是字符串对象,list对象,hash对象,set对象和zset对象.可以使用type命令查看值对象的类型,命令格式为type key. 对象的ptr指针指向对象的底层实现数据结构,由对象的encoding属性决定,encoding属性记录了对象的底层实现,这个属性的值可以是下表中列出的常量中的一个: 编码常量 编码所对应的底层数据结构 REDIS_ENCODING_INT long类型的整数 REDIS_ENCODING_EMBSTR embstr编码的简单动态字符串 REDIS_ENCODING_RAW 简单动态字符串 REDIS_ENCODING_HT 字典 REDIS_ENCODING_LINKEDLIST 双端链表 REDIS_ENCODING_ZIPLIST 压缩列表 REDIS_ENCODING_INTSET 整数集合 REDIS_ENCODING_SKIPLIST 跳跃表和字典 每种类型的对象都至少使用了两种类型的编码,如下表所示: 类型 编码 对象 REDIS_STRING REDIS_ENCODING_INT 使用整数值实现的字符对象 REDIS_STRING REDIS_ENCODING_EMBSTR 使用embstr编码的简单动态字符串实现的字符串对象 REDIS_STRING REDIS_ENCODING_RAW 使用简单动态字符串实现的字符串对象 REDIS_LIST REDIS_ENCODING_ZIPLIST 使用压缩列表实现的list对象 REDIS_LIST REDIS_ENCODING_LINKEDLIST 使用双端链表实现的list对象 REDIS_HASH REDIS_ENCODING_ZIPLIST 使用压缩列表实现的hash对象 REDIS_HASH REDIS_ENCODING_HT 使用字典实现的hash对象 REDIS_SET REDIS_ENCODING_INTSET 使用整数集合实现的set对象 REDIS_SET REDIS_ENCODING_HT 使用字典实现的set对象 REDIS_ZET REDIS_ENCODING_ZIPLIST 使用压缩列表实现的zset对象 REDIS_ZET REDIS_ENCODING_SKIPLIST 使用跳跃表和字典实现的zset对象 使用object encoding key命令可以查看对应键的值对象的编码,每种值对象至少使用两种编码可以方便redis在不同的场景下选择合适的数据实现,提高效率. 7.2 字符串对象字符串对象的编码可以是int,raw或者embstr,各自使用场景如下: int: 当字符串对象保存的是整数值,并且该整数值可以用long类型表示 raw: 当保存的是字符串并且该字符串长度大于39字节,使用一个SDS来保存值,并将编码设置为raw embstr: 当保存的是字符串并且该字符串长度小于39字节,将编码设置为embstr embstr编码是专门用于保存短字符串的一种优化编码放是,其和raw编码一样,都是用redisObject结构和sdshdr结构来表示字符串对象,但raw编码需要调用两次内存分配函数来创建redisObject结构和sdshdr结构,而embstr通过调用一次内存分配函数来分配一块连续的空间,空间中依次包含redisObject结构和sdshdr结构: 使用embstr编码好处是:1.降低内存分配次数(从两次降低为一次)2.释放字符串对象时,raw需要调用两次内存释放函数,embstr只需要一次3.因为embstr编码对象保存在连续空间中,能更好利用缓存带来的优势 可以用long double类型表示的浮点数在redis中也是作为字符串保存的.编码对象可以相互转换,其中embstr编码没有任何修改程序,因此是只读的.下表是常见字符串命令的实现: 7.3 list对象list对象的编码可以是ziplist或者linkedlist,当list对象同时满足以下两个条件时,使用ziplist编码,否则使用linkedlist 1.list对象保存的所有字符串元素的长度都小于64字节; 2.元素数量小于512个 以上两个数值在配置文件中可以修改,对应的是list-max-ziplist-value选项和list-max-ziplist-entries 7.4 hash对象hash对象的编码可以是ziplist或者hashtable,当使用ziplist压缩列表编码时,一个键值对分别保存在一个节点上,一前一后紧挨在一起.先添加的键值对在表头方向,后添加的在表尾方向;当使用hashtable编码时,底层使用字典作为实现,键值对都是字符串对象. hash对象同时满足以下两个条件时使用ziplist编码,否则使用hashtable编码: 1.键值对的键和值字符串长度都小于64字节; 2.键值对个数小于512个 以上两个数值在配置文件中可以修改,对应的是hash-max-ziplist-value选项和hash-max-ziplist-entries 7.5 set对象set对象的编码可以是intset或者hashtable,当对象同时满足以下两个条件是,使用intset编码,否则使用hashtable编码: 1.保存的所有元素都是整数值 2.元素的数量不超过512个 第二个数值在配置文件中可以修改,对应的是set-max-intset-entries 7.6 zset对象zset对象的编码可以是ziplist或者skiplist.当使用ziplist编码时,每个元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员(member),第二个节点保存元素的分值(score),列表内按照分值从小到大排序,分值小的在表头方向,分值大的在表尾方向,skiplist编码看p78. 当同时满足以下两个条件时,使用ziplist编码,否则使用ziplist编码: 1.元素数量个数少于128个 2.所有元素成员的长度都小于64字节 以上两个数值在配置文件中可以修改,对应的是zset-max-ziplist-entries选项和zset-max-ziplist-value","categories":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://www.enjoyican.com/tags/Redis/"}]},{"title":"基于hexo博客搭建tips","date":"2020-03-12T02:08:30.000Z","path":"posts/blog-byhexo-tips/","text":"搭建基于hexo搭建博客的教程,网上很多,这里不再赘述,不同主题适配有不同的坑需要踩,因人而异,下面给出一些教程链接: hexo官方主页中文版 使用Hexo搭建GitHub博客 使用hexo搭建个人博客网站最完整详细教程 按照上述教程搭建过程中如遇到报错异常,一般网上搜索都是能搜索到原因的,针对修改即可.博客搭建完成后,你有两种方式访问自己的博客: 自己有服务器,但是没有域名: 首先上传新写好的一篇文档之后执行hexo g,hexo s发布文章启动博客之后,就可以在浏览器通过IP:4000(hexo默认端口)访问到自己的博客,但是这种访问方式一方面浏览器地址看着不舒服,另一方面通过hexo s在服务器启动之后,没办法退出当前命令行,ctrl+C之后就自动退出了,访问不了了,通过hexo s&amp;启动,可以让博客后台运行,短暂解放你的命令行,可以让你去执行别的命令,但是这个线程过一会儿就死亡了,又访问不了了. 自己没有服务器,基于github搭建: 基于github搭建的,当你执行hexo g hexo d发布到远程仓库之后你可以通过https: yourgithubusername.github.io访问你的博客,但是github访问有可能比较慢,此外github屏蔽了百度搜索,这个博客内容只能孤芳自赏了.所以接下来就想到申请域名,通过自己服务器搭建博客. 申请域名备案因为我自己平时有自用的阿里云服务器,没有域名,所以这一步我只需要在阿里云上申请域名并备案即可,域名的申请国内外网站都可以,我不想在后面与阿里云服务器匹配的时候遇到各种坑所以直接在阿里云上注册了一个域名,三年193RMB,注册成功后提交阿里云初审,自2019年7月29日起，根据管局对备案真实性的要求，阿里云备案流程中使用移动端进行活体检测保障真实性，幕布拍照方式不再使用,直接在app上人脸识别后上传照片即可不过人脸识别的时候请稍微收拾下,我当时人脸识别的时候没想到后面会用这张照片申请备案所以大半夜12点穿着睡衣,睡眼惺忪拍了张照,后面也懒得替换了,所以就用一张挫照提交备案申请了. 备案时阿里云会进行初审,注意网站名称不要出现博客,空间等字样,这些字样不在工信部备案支持内容里,具体可以上阿里云查询,不过就算填错,阿里云初审同学会提醒你修改 初审用了1个工作日,之后就是阿里云提交工信部审核,我的个人网站审核特别快,一天就通过了,之前一直以为要15-20天,必须给浙江工信部点个赞. 备案完成后,按照相关指示修改你的博客js文件,将要求的备案号放在你网站的底部并链接到对应网址. 用nginx做静态资源服务器域名有了,在阿里云控制台指向你的服务器ip之后,就可以通过nginx访问博客静态资源了.因为前述hexo g的执行就是在对应的public文件夹下生成静态html等文件资源,所以我们可以通过nginx访问,就不再需要后台启动hexo了. 安装nginx,网上教程很多,搜索即可,安装很快 配置nginx配置文件,将root根目录配置如下 12345678910server &#123; listen 80; server_name enjoyican.com www.enjoyican.com; location / &#123; # root目录配置为你的博客路径下的public文件夹 root /usr/soft/hexo/public/; index index.html index.htm; &#125; &#125; 这样配置并重启nginx之后就可以通过域名访问你的博客资源了,但是在浏览器访问的时候会显示不安全字样,看着不舒服,所以接下来就是配置https,以及将http的请求转发到https上,具体的配置可以参考如下链接: 个人网站升级http为https","categories":[{"name":"tips","slug":"tips","permalink":"https://www.enjoyican.com/categories/tips/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://www.enjoyican.com/tags/hexo/"}]},{"title":"转载-Spring IOC 容器源码分析","date":"2020-03-08T15:15:46.000Z","path":"posts/Spring-IOC/","text":"郑重声明 : 本文转载自我关注的一位大佬的博客,原文链接: https://www.javadoop.com/post/spring-ioc ,如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意. Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。 本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。 阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。 希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。 引言先看下最基本的启动 Spring 容器的例子： 123public static void main(String[] args) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:applicationfile.xml\");&#125; 以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;&lt;/dependency&gt; spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。 多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。 废话说完，我们继续。ApplicationContext context = new ClassPathXmlApplicationContext(...) 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的： 1 读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。 当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。 我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 FileSystemXmlApplicationContext 和 AnnotationConfigApplicationContext 这两个类。 1、FileSystemXmlApplicationContext 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。 2、AnnotationConfigApplicationContext 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。 不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。 我们先来一个简单的例子来看看怎么实例化 ApplicationContext。 首先，定义一个接口： 123public interface MessageService &#123; String getMessage();&#125; 定义接口实现类： 123456public class MessageServiceImpl implements MessageService &#123; public String getMessage() &#123; return \"hello world\"; &#125;&#125; 接下来，我们在 resources 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; &lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"/&gt;&lt;/beans&gt; 这样，我们就可以跑起来了： 12345678910111213public class App &#123; public static void main(String[] args) &#123; // 用我们的配置文件来启动一个 ApplicationContext ApplicationContext context = new ClassPathXmlApplicationContext(\"classpath:application.xml\"); System.out.println(\"context 启动成功\"); // 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式 MessageService messageService = context.getBean(MessageService.class); // 这句将输出: hello world System.out.println(messageService.getMessage()); &#125;&#125; 以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。 BeanFactory 简介BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。 初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构： 2 我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。 ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。 ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。 AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。 ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。 请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。 然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。 启动过程分析下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。 第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。 1234567891011121314151617181920public class ClassPathXmlApplicationContext extends AbstractXmlApplicationContext &#123; private Resource[] configResources; // 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法 public ClassPathXmlApplicationContext(ApplicationContext parent) &#123; super(parent); &#125; ... public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); // 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割) setConfigLocations(configLocations); if (refresh) &#123; refresh(); // 核心方法 &#125; &#125; ...&#125; 接下来，就是 refresh()，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。 往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) &#123; // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try &#123; // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)， // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 下面，我们开始一步步来肢解这个 refresh() 方法。 创建 Bean 容器前的准备工作这个比较简单，直接看代码中的几个注释即可。 12345678910111213141516171819protected void prepareRefresh() &#123; // 记录启动时间， // 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型 this.startupDate = System.currentTimeMillis(); this.closed.set(false); this.active.set(true); if (logger.isInfoEnabled()) &#123; logger.info(\"Refreshing \" + this); &#125; // Initialize any placeholder property sources in the context environment initPropertySources(); // 校验 xml 配置文件 getEnvironment().validateRequiredProperties(); this.earlyApplicationEvents = new LinkedHashSet&lt;ApplicationEvent&gt;();&#125; 创建 Bean 容器，加载并注册 Bean我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。 注意，这个方法是全文最重要的部分之一，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。 当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。 // AbstractApplicationContext.java 1234567891011protected ConfigurableListableBeanFactory obtainFreshBeanFactory() &#123; // 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等 refreshBeanFactory(); // 返回刚刚创建的 BeanFactory ConfigurableListableBeanFactory beanFactory = getBeanFactory(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Bean factory for \" + getDisplayName() + \": \" + beanFactory); &#125; return beanFactory;&#125; // AbstractRefreshableApplicationContext.java 120 1234567891011121314151617181920212223242526272829@Overrideprotected final void refreshBeanFactory() throws BeansException &#123; // 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory // 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前 // ApplicationContext 是否有 BeanFactory if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; // 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。 DefaultListableBeanFactory beanFactory = createBeanFactory(); // 用于 BeanFactory 的序列化，我想不部分人应该都用不到 beanFactory.setSerializationId(getId()); // 下面这两个方法很重要，别跟丢了，具体细节之后说 // 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用 customizeBeanFactory(beanFactory); // 加载 Bean 到 BeanFactory 中 loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125;&#125; 看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。 我们说说为什么选择实例化 DefaultListableBeanFactory ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下： 3 我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。 如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？ 之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。 那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。 在继续往下之前，我们需要先了解 BeanDefinition。我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？ 这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。 所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。 BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。 BeanDefinition 接口定义我们来看下 BeanDefinition 的接口定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123; // 我们可以看到，默认只提供 sington 和 prototype 两种， // 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种， // 不过，它们属于基于 web 的扩展。 String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; // 比较不重要，直接跳过吧 int ROLE_APPLICATION = 0; int ROLE_SUPPORT = 1; int ROLE_INFRASTRUCTURE = 2; // 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍 // 一句话就是：继承父 Bean 的配置信息而已 void setParentName(String parentName); // 获取父 Bean String getParentName(); // 设置 Bean 的类名称，将来是要通过反射来生成实例的 void setBeanClassName(String beanClassName); // 获取 Bean 的类名称 String getBeanClassName(); // 设置 bean 的 scope void setScope(String scope); String getScope(); // 设置是否懒加载 void setLazyInit(boolean lazyInit); boolean isLazyInit(); // 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)， // 是 depends-on=\"\" 属性设置的值。 void setDependsOn(String... dependsOn); // 返回该 Bean 的所有依赖 String[] getDependsOn(); // 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效， // 如果根据名称注入，即使这边设置了 false，也是可以的 void setAutowireCandidate(boolean autowireCandidate); // 该 Bean 是否可以注入到其他 Bean 中 boolean isAutowireCandidate(); // 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean void setPrimary(boolean primary); // 是否是 primary 的 boolean isPrimary(); // 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录 // 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的 void setFactoryBeanName(String factoryBeanName); // 获取工厂名称 String getFactoryBeanName(); // 指定工厂类中的 工厂方法名称 void setFactoryMethodName(String factoryMethodName); // 获取工厂类中的 工厂方法名称 String getFactoryMethodName(); // 构造器参数 ConstructorArgumentValues getConstructorArgumentValues(); // Bean 中的属性值，后面给 bean 注入属性值的时候会说到 MutablePropertyValues getPropertyValues(); // 是否 singleton boolean isSingleton(); // 是否 prototype boolean isPrototype(); // 如果这个 Bean 是被设置为 abstract，那么不能实例化， // 常用于作为 父bean 用于继承，其实也很少用...... boolean isAbstract(); int getRole(); String getDescription(); String getResourceDescription(); BeanDefinition getOriginatingBeanDefinition();&#125; 这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。 这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。 有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分： 12customizeBeanFactory(beanFactory);loadBeanDefinitions(beanFactory); 虽然只有两个方法，但路还很长啊。。。 customizeBeanFactorycustomizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。 12345678910protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) &#123; if (this.allowBeanDefinitionOverriding != null) &#123; // 是否允许 Bean 定义覆盖 beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.allowCircularReferences != null) &#123; // 是否允许 Bean 间的循环依赖 beanFactory.setAllowCircularReferences(this.allowCircularReferences); &#125;&#125; BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。 默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。 至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。 之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。 加载 Bean: loadBeanDefinitions接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。 读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。 // AbstractXmlApplicationContext.java 80 123456789101112131415161718/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/@Overrideprotected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException &#123; // 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory); // Configure the bean definition reader with this context's // resource loading environment. beanDefinitionReader.setEnvironment(this.getEnvironment()); beanDefinitionReader.setResourceLoader(this); beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this)); // 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的， // 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧 initBeanDefinitionReader(beanDefinitionReader); // 重点来了，继续往下 loadBeanDefinitions(beanDefinitionReader);&#125; 现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。 // AbstractXmlApplicationContext.java 120 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException &#123; Resource[] configResources = getConfigResources(); if (configResources != null) &#123; // 往下看 reader.loadBeanDefinitions(configResources); &#125; String[] configLocations = getConfigLocations(); if (configLocations != null) &#123; // 2 reader.loadBeanDefinitions(configLocations); &#125;&#125;// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里@Overridepublic int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException &#123; Assert.notNull(resources, \"Resource array must not be null\"); int counter = 0; // 注意这里是个 for 循环，也就是每个文件是一个 resource for (Resource resource : resources) &#123; // 继续往下看 counter += loadBeanDefinitions(resource); &#125; // 最后返回 counter，表示总共加载了多少的 BeanDefinition return counter;&#125;// XmlBeanDefinitionReader 303@Overridepublic int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource));&#125;// XmlBeanDefinitionReader 314public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; // 用一个 ThreadLocal 来存放配置文件资源 Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;EncodedResource&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; // 核心部分是这里，往下面看 return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125;&#125;// 还在这个文件中，第 388 行protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; // 这里就不看了，将 xml 文件转换为 Document 对象 Document doc = doLoadDocument(inputSource, resource); // 继续 return registerBeanDefinitions(doc, resource); &#125; catch (...&#125;// 还在这个文件中，第 505 行// 返回值：返回从当前配置文件加载了多少数量的 Beanpublic int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); // 这里 documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore;&#125;// DefaultBeanDefinitionDocumentReader 90@Overridepublic void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) &#123; this.readerContext = readerContext; logger.debug(\"Loading bean definitions\"); Element root = doc.getDocumentElement(); // 从 xml 根节点开始解析文件 doRegisterBeanDefinitions(root);&#125; 经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析： doRegisterBeanDefinitions：123456789101112131415161718192021222324252627282930313233// DefaultBeanDefinitionDocumentReader 116protected void doRegisterBeanDefinitions(Element root) &#123; // 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义， // 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题， // 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了 BeanDefinitionParserDelegate parent = this.delegate; this.delegate = createDelegate(getReaderContext(), root, parent); if (this.delegate.isDefaultNamespace(root)) &#123; // 这块说的是根节点 &lt;beans ... profile=\"dev\" /&gt; 中的 profile 是否是当前环境需要的， // 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析 // 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区 String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE); if (StringUtils.hasText(profileSpec)) &#123; String[] specifiedProfiles = StringUtils.tokenizeToStringArray( profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS); if (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123; if (logger.isInfoEnabled()) &#123; logger.info(\"Skipped XML bean definition file due to specified profiles [\" + profileSpec + \"] not matching: \" + getReaderContext().getResource()); &#125; return; &#125; &#125; &#125; preProcessXml(root); // 钩子 // 往下看 parseBeanDefinitions(root, this.delegate); postProcessXml(root); // 钩子 this.delegate = parent;&#125; preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。 这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。 接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) : 123456789101112131415161718192021222324// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，// 其他的属于 custom 的protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123; if (delegate.isDefaultNamespace(root)) &#123; NodeList nl = root.getChildNodes(); for (int i = 0; i &lt; nl.getLength(); i++) &#123; Node node = nl.item(i); if (node instanceof Element) &#123; Element ele = (Element) node; if (delegate.isDefaultNamespace(ele)) &#123; // 解析 default namespace 下面的几个元素 parseDefaultElement(ele, delegate); &#125; else &#123; // 解析其他 namespace 的元素 delegate.parseCustomElement(ele); &#125; &#125; &#125; &#125; else &#123; delegate.parseCustomElement(root); &#125;&#125; 从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。 parseDefaultElement(ele, delegate) 代表解析的节点是 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt;、&lt;beans /&gt; 这几个。 这里的四个标签之所以是 default 的，是因为它们是处于这个 namespace 下定义的： 1http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans 又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 xmlns 就是咯。 123456&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\" default-autowire=\"byName\"&gt; 而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;等。 这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。 假如读者想分析 &lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt; 的实现原理，就应该到 ContextNamespaceHandler 中找答案。 12345678910111213&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd \" default-autowire=\"byName\"&gt; 同理，以后你要是碰到 &lt;dubbo /&gt; 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。 回过神来，看看处理 default 标签的方法： 12345678910111213141516171819private void parseDefaultElement(Element ele, BeanDefinitionParserDelegate delegate) &#123; if (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123; // 处理 &lt;import /&gt; 标签 importBeanDefinitionResource(ele); &#125; else if (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123; // 处理 &lt;alias /&gt; 标签定义 // &lt;alias name=\"fromName\" alias=\"toName\"/&gt; processAliasRegistration(ele); &#125; else if (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123; // 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧 processBeanDefinition(ele, delegate); &#125; else if (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123; // 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归 doRegisterBeanDefinitions(ele); &#125;&#125; 如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 &lt;bean /&gt; 标签出来说。 processBeanDefinition 解析 bean 标签下面是 processBeanDefinition 解析 &lt;bean /&gt; 标签： // DefaultBeanDefinitionDocumentReader 298 1234567891011121314151617181920protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); // 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的 if (bdHolder != null) &#123; bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // Register the final decorated instance. BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // Send registration event. getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 继续往下看怎么解析之前，我们先看下 &lt;bean /&gt; 标签中可以定义哪些属性： Property class 类的全限定名 name 可指定 id、name(用逗号、分号、空格分隔) scope 作用域 constructor arguments 指定构造参数 properties 设置属性的值 autowiring mode no(默认值)、byName、byType、 constructor lazy-initialization mode 是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了) initialization method bean 属性设置完成后，会调用这个方法 destruction method bean 销毁后的回调方法 上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。 简单地说就是像下面这样子： 123456789101112131415&lt;bean id=\"exampleBean\" name=\"name1, name2, name3\" class=\"com.javadoop.ExampleBean\" scope=\"singleton\" lazy-init=\"true\" init-method=\"init\" destroy-method=\"cleanup\"&gt; &lt;!-- 可以用下面三种形式指定构造参数 --&gt; &lt;constructor-arg type=\"int\" value=\"7500000\"/&gt; &lt;constructor-arg name=\"years\" value=\"7500000\"/&gt; &lt;constructor-arg index=\"0\" value=\"7500000\"/&gt; &lt;!-- property 的几种情况 --&gt; &lt;property name=\"beanOne\"&gt; &lt;ref bean=\"anotherExampleBean\"/&gt; &lt;/property&gt; &lt;property name=\"beanTwo\" ref=\"yetAnotherBean\"/&gt; &lt;property name=\"integerProperty\" value=\"1\"/&gt;&lt;/bean&gt; 当然，除了上面举例出来的这些，还有 factory-bean、factory-method、&lt;lockup-method /&gt;、&lt;replaced-method /&gt;、&lt;meta /&gt;、&lt;qualifier /&gt; 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。 有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。 // BeanDefinitionParserDelegate 428 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public BeanDefinitionHolder parseBeanDefinitionElement(Element ele) &#123; return parseBeanDefinitionElement(ele, null);&#125;public BeanDefinitionHolder parseBeanDefinitionElement(Element ele, BeanDefinition containingBean) &#123; String id = ele.getAttribute(ID_ATTRIBUTE); String nameAttr = ele.getAttribute(NAME_ATTRIBUTE); List&lt;String&gt; aliases = new ArrayList&lt;String&gt;(); // 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组， // 当然，如果你不定义 name 属性的话，就是空的了 // 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了 if (StringUtils.hasLength(nameAttr)) &#123; String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS); aliases.addAll(Arrays.asList(nameArr)); &#125; String beanName = id; // 如果没有指定id, 那么用别名列表的第一个名字作为beanName if (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123; beanName = aliases.remove(0); if (logger.isDebugEnabled()) &#123; logger.debug(\"No XML 'id' specified - using '\" + beanName + \"' as bean name and \" + aliases + \" as aliases\"); &#125; &#125; if (containingBean == null) &#123; checkNameUniqueness(beanName, aliases, ele); &#125; // 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中, // 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。 AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean); // 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。 if (beanDefinition != null) &#123; // 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生 // 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要 if (!StringUtils.hasText(beanName)) &#123; try &#123; if (containingBean != null) &#123;// 按照我们的思路，这里 containingBean 是 null 的 beanName = BeanDefinitionReaderUtils.generateBeanName( beanDefinition, this.readerContext.getRegistry(), true); &#125; else &#123; // 如果我们不定义 id 和 name，那么我们引言里的那个例子： // 1. beanName 为：com.javadoop.example.MessageServiceImpl#0 // 2. beanClassName 为：com.javadoop.example.MessageServiceImpl beanName = this.readerContext.generateBeanName(beanDefinition); String beanClassName = beanDefinition.getBeanClassName(); if (beanClassName != null &amp;&amp; beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp; !this.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123; // 把 beanClassName 设置为 Bean 的别名 aliases.add(beanClassName); &#125; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Neither XML 'id' nor 'name' specified - \" + \"using generated bean name [\" + beanName + \"]\"); &#125; &#125; catch (Exception ex) &#123; error(ex.getMessage(), ele); return null; &#125; &#125; String[] aliasesArray = StringUtils.toStringArray(aliases); // 返回 BeanDefinitionHolder return new BeanDefinitionHolder(beanDefinition, beanName, aliasesArray); &#125; return null;&#125; 然后，我们再看看怎么根据配置创建 BeanDefinition 实例的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public AbstractBeanDefinition parseBeanDefinitionElement( Element ele, String beanName, BeanDefinition containingBean) &#123; this.parseState.push(new BeanEntry(beanName)); String className = null; if (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123; className = ele.getAttribute(CLASS_ATTRIBUTE).trim(); &#125; try &#123; String parent = null; if (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123; parent = ele.getAttribute(PARENT_ATTRIBUTE); &#125; // 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了 AbstractBeanDefinition bd = createBeanDefinition(className, parent); // 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中 parseBeanDefinitionAttributes(ele, beanName, containingBean, bd); bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT)); /** * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素， * 解析出来以后的信息都放到 bd 的属性中 */ // 解析 &lt;meta /&gt; parseMetaElements(ele, bd); // 解析 &lt;lookup-method /&gt; parseLookupOverrideSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;replaced-method /&gt; parseReplacedMethodSubElements(ele, bd.getMethodOverrides()); // 解析 &lt;constructor-arg /&gt; parseConstructorArgElements(ele, bd); // 解析 &lt;property /&gt; parsePropertyElements(ele, bd); // 解析 &lt;qualifier /&gt; parseQualifierElements(ele, bd); bd.setResource(this.readerContext.getResource()); bd.setSource(extractSource(ele)); return bd; &#125; catch (ClassNotFoundException ex) &#123; error(\"Bean class [\" + className + \"] not found\", ele, ex); &#125; catch (NoClassDefFoundError err) &#123; error(\"Class that bean class [\" + className + \"] depends on not found\", ele, err); &#125; catch (Throwable ex) &#123; error(\"Unexpected failure during bean definition parsing\", ele, ex); &#125; finally &#123; this.parseState.pop(); &#125; return null;&#125; 到这里，我们已经完成了根据 &lt;bean /&gt; 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。 我们回到解析 &lt;bean /&gt; 的入口方法: 123456789101112131415161718protected void processBeanDefinition(Element ele, BeanDefinitionParserDelegate delegate) &#123; // 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆 BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele); if (bdHolder != null) &#123; // 如果有自定义属性的话，进行相应的解析，先忽略 bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder); try &#123; // 我们把这步叫做 注册Bean 吧 BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry()); &#125; catch (BeanDefinitionStoreException ex) &#123; getReaderContext().error(\"Failed to register bean definition with name '\" + bdHolder.getBeanName() + \"'\", ele, ex); &#125; // 注册完成后，发送事件，本文不展开说这个 getReaderContext().fireComponentRegistered(new BeanComponentDefinition(bdHolder)); &#125;&#125; 大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 &lt;bean /&gt; 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上： 12345678public class BeanDefinitionHolder implements BeanMetadataElement &#123; private final BeanDefinition beanDefinition; private final String beanName; private final String[] aliases;... 然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。 下面，我们开始说说注册 Bean 吧。 注册 Bean// BeanDefinitionReaderUtils 143 123456789101112131415161718public static void registerBeanDefinition( BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry) throws BeanDefinitionStoreException &#123; String beanName = definitionHolder.getBeanName(); // 注册这个 Bean registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition()); // 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了 String[] aliases = definitionHolder.getAliases(); if (aliases != null) &#123; for (String alias : aliases) &#123; // alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了， // 获取的时候，会先将 alias 转换为 beanName，然后再查找 registry.registerAlias(beanName, alias); &#125; &#125;&#125; 别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。 // DefaultListableBeanFactory 793 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182@Overridepublic void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException &#123; Assert.hasText(beanName, \"Bean name must not be empty\"); Assert.notNull(beanDefinition, \"BeanDefinition must not be null\"); if (beanDefinition instanceof AbstractBeanDefinition) &#123; try &#123; ((AbstractBeanDefinition) beanDefinition).validate(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(...); &#125; &#125; // old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding BeanDefinition oldBeanDefinition; // 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中 oldBeanDefinition = this.beanDefinitionMap.get(beanName); // 处理重复名称的 Bean 定义的情况 if (oldBeanDefinition != null) &#123; if (!isAllowBeanDefinitionOverriding()) &#123; // 如果不允许覆盖的话，抛异常 throw new BeanDefinitionStoreException(beanDefinition.getResourceDescription()... &#125; else if (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123; // log...用框架定义的 Bean 覆盖用户自定义的 Bean &#125; else if (!beanDefinition.equals(oldBeanDefinition)) &#123; // log...用新的 Bean 覆盖旧的 Bean &#125; else &#123; // log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean &#125; // 覆盖 this.beanDefinitionMap.put(beanName, beanDefinition); &#125; else &#123; // 判断是否已经有其他的 Bean 开始初始化了. // 注意，\"注册Bean\" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程， // 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans if (hasBeanCreationStarted()) &#123; // Cannot modify startup-time collection elements anymore (for stable iteration) synchronized (this.beanDefinitionMap) &#123; this.beanDefinitionMap.put(beanName, beanDefinition); List&lt;String&gt; updatedDefinitions = new ArrayList&lt;String&gt;(this.beanDefinitionNames.size() + 1); updatedDefinitions.addAll(this.beanDefinitionNames); updatedDefinitions.add(beanName); this.beanDefinitionNames = updatedDefinitions; if (this.manualSingletonNames.contains(beanName)) &#123; Set&lt;String&gt; updatedSingletons = new LinkedHashSet&lt;String&gt;(this.manualSingletonNames); updatedSingletons.remove(beanName); this.manualSingletonNames = updatedSingletons; &#125; &#125; &#125; else &#123; // 最正常的应该是进到这个分支。 // 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition this.beanDefinitionMap.put(beanName, beanDefinition); // 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字 this.beanDefinitionNames.add(beanName); // 这是个 LinkedHashSet，代表的是手动注册的 singleton bean， // 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的 // 手动指的是通过调用以下方法注册的 bean ： // registerSingleton(String beanName, Object singletonObject) // 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面\"手动\"注册一些 Bean， // 如 \"environment\"、\"systemProperties\" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的 this.manualSingletonNames.remove(beanName); &#125; // 这个不重要，在预初始化的时候会用到，不必管它。 this.frozenBeanDefinitionNames = null; &#125; if (oldBeanDefinition != null || containsSingleton(beanName)) &#123; resetBeanDefinition(beanName); &#125;&#125; 总结一下，到这里已经初始化了 Bean 容器，&lt;bean /&gt; 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。 ——— 分割线 ——— 到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。 Bean 容器实例化完成后说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。 考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Overridepublic void refresh() throws BeansException, IllegalStateException &#123; // 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛 synchronized (this.startupShutdownMonitor) &#123; // 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); // 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中， // 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了， // 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map) ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean // 这块待会会展开说 prepareBeanFactory(beanFactory); try &#123; // 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口， // 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】 // 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化 // 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事 postProcessBeanFactory(beanFactory); // 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法 invokeBeanFactoryPostProcessors(beanFactory); // 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别 // 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization // 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机 registerBeanPostProcessors(beanFactory); // 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了 initMessageSource(); // 初始化当前 ApplicationContext 的事件广播器，这里也不展开了 initApplicationEventMulticaster(); // 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说 // 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前） onRefresh(); // 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过 registerListeners(); // 重点，重点，重点 // 初始化所有的 singleton beans //（lazy-init 的除外） finishBeanFactoryInitialization(beanFactory); // 最后，广播事件，ApplicationContext 初始化完成，不展开 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. // 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源 destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // 把异常往外抛 throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125;&#125; 准备 Bean 容器: prepareBeanFactory之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。 这里简单介绍下 prepareBeanFactory(factory) 方法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * Configure the factory's standard context characteristics, * such as the context's ClassLoader and post-processors. * @param beanFactory the BeanFactory to configure */protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123; // 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器， // 这里设置为加载当前 ApplicationContext 类的类加载器 beanFactory.setBeanClassLoader(getClassLoader()); // 设置 BeanExpressionResolver beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader())); // beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment())); // 添加一个 BeanPostProcessor，这个 processor 比较简单： // 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调， // 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware // 注意：它不仅仅回调 ApplicationContextAware， // 还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了 beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this)); // 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们， // Spring 会通过其他方式来处理这些依赖。 beanFactory.ignoreDependencyInterface(EnvironmentAware.class); beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class); beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class); beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class); beanFactory.ignoreDependencyInterface(MessageSourceAware.class); beanFactory.ignoreDependencyInterface(ApplicationContextAware.class); /** * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值， * 之前我们说过，\"当前 ApplicationContext 持有一个 BeanFactory\"，这里解释了第一行。 * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean */ beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory); beanFactory.registerResolvableDependency(ResourceLoader.class, this); beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this); beanFactory.registerResolvableDependency(ApplicationContext.class, this); // 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类， // 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器 beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this)); // 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它 // tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样， // 感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); // Set a temporary ClassLoader for type matching. beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125; /** * 从下面几行代码我们可以知道，Spring 往往很 \"智能\" 就是因为它会帮我们默认注册一些有用的 bean， * 我们也可以选择覆盖 */ // 如果没有定义 \"environment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment()); &#125; // 如果没有定义 \"systemProperties\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties()); &#125; // 如果没有定义 \"systemEnvironment\" 这个 bean，那么 Spring 会 \"手动\" 注册一个 if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123; beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment()); &#125;&#125; 在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。 初始化所有的 singleton beans我们的重点当然是 finishBeanFactoryInitialization(beanFactory); 这个巨头了，这里会负责初始化所有的 singleton beans。 注意，后面的描述中，我都会使用初始化或预初始化来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。 我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 environment、systemProperties 等。 剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。 // AbstractApplicationContext.java 834 1234567891011121314151617181920212223242526272829303132333435363738394041// 初始化剩余的 singleton beansprotected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) &#123; // 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了 // 什么，看代码这里没有初始化 Bean 啊！ // 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧 if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123; beanFactory.setConversionService( beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)); &#125; // Register a default embedded value resolver if no bean post-processor // (such as a PropertyPlaceholderConfigurer bean) registered any before: // at this point, primarily for resolution in annotation attribute values. if (!beanFactory.hasEmbeddedValueResolver()) &#123; beanFactory.addEmbeddedValueResolver(new StringValueResolver() &#123; @Override public String resolveStringValue(String strVal) &#123; return getEnvironment().resolvePlaceholders(strVal); &#125; &#125;); &#125; // 先初始化 LoadTimeWeaverAware 类型的 Bean // 之前也说过，这是 AspectJ 相关的内容，放心跳过吧 String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false); for (String weaverAwareName : weaverAwareNames) &#123; getBean(weaverAwareName); &#125; // Stop using the temporary ClassLoader for type matching. beanFactory.setTempClassLoader(null); // 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了， // 肯定不希望这个时候还出现 bean 定义解析、加载、注册。 beanFactory.freezeConfiguration(); // 开始初始化 beanFactory.preInstantiateSingletons();&#125; 从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。 preInstantiateSingletons// DefaultListableBeanFactory 728 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overridepublic void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Pre-instantiating singletons in \" + this); &#125; // this.beanDefinitionNames 保存了所有的 beanNames List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作 for (String beanName : beanNames) &#123; // 合并父 Bean 中的配置，注意 &lt;bean id=\"\" class=\"\" parent=\"\" /&gt; 中的 parent，用的不多吧， // 考虑到这可能会影响大家的理解，我在附录中解释了一下 \"Bean 继承\"，不了解的请到附录中看一下 RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); // 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的 if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; // 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解) if (isFactoryBean(beanName)) &#123; // FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急 final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); // 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过 boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; // 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了 getBean(beanName); &#125; &#125; &#125; // 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化 // 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略 for (String beanName : beanNames) &#123; Object singletonInstance = getSingleton(beanName); if (singletonInstance instanceof SmartInitializingSingleton) &#123; final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; smartSingleton.afterSingletonsInstantiated(); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; smartSingleton.afterSingletonsInstantiated(); &#125; &#125; &#125;&#125; 接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。 getBean在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。 // AbstractBeanFactory 196 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176@Overridepublic Object getBean(String name) throws BeansException &#123; return doGetBean(name, null, null, false);&#125;// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，// 已经初始化过了就从容器中直接返回，否则就先初始化再返回@SuppressWarnings(\"unchecked\")protected &lt;T&gt; T doGetBean( final String name, final Class&lt;T&gt; requiredType, final Object[] args, boolean typeCheckOnly) throws BeansException &#123; // 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)， // 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的 final String beanName = transformedBeanName(name); // 注意跟着这个，这个是返回值 Object bean; // 检查下是不是已经创建过了 Object sharedInstance = getSingleton(beanName); // 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)， // 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean if (sharedInstance != null &amp;&amp; args == null) &#123; if (logger.isDebugEnabled()) &#123; if (isSingletonCurrentlyInCreation(beanName)) &#123; logger.debug(\"...\"); &#125; else &#123; logger.debug(\"Returning cached instance of singleton bean '\" + beanName + \"'\"); &#125; &#125; // 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance， // 如果是 FactoryBean 的话，返回它创建的那个实例对象 // (FactoryBean 知识，读者若不清楚请移步附录) bean = getObjectForBeanInstance(sharedInstance, name, beanName, null); &#125; else &#123; if (isPrototypeCurrentlyInCreation(beanName)) &#123; // 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常， // 往往是因为陷入了循环引用 throw new BeanCurrentlyInCreationException(beanName); &#125; // 检查一下这个 BeanDefinition 在容器中是否存在 BeanFactory parentBeanFactory = getParentBeanFactory(); if (parentBeanFactory != null &amp;&amp; !containsBeanDefinition(beanName)) &#123; // 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有 String nameToLookup = originalBeanName(name); if (args != null) &#123; // 返回父容器的查询结果 return (T) parentBeanFactory.getBean(nameToLookup, args); &#125; else &#123; // No args -&gt; delegate to standard getBean method. return parentBeanFactory.getBean(nameToLookup, requiredType); &#125; &#125; if (!typeCheckOnly) &#123; // typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。 markBeanAsCreated(beanName); &#125; /* * 稍稍总结一下： * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean； * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。 */ try &#123; final RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName); checkMergedBeanDefinition(mbd, beanName, args); // 先初始化依赖的所有 Bean，这个很好理解。 // 注意，这里的依赖指的是 depends-on 中定义的依赖 String[] dependsOn = mbd.getDependsOn(); if (dependsOn != null) &#123; for (String dep : dependsOn) &#123; // 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了 if (isDependent(beanName, dep)) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Circular depends-on relationship between '\" + beanName + \"' and '\" + dep + \"'\"); &#125; // 注册一下依赖关系 registerDependentBean(dep, beanName); // 先初始化被依赖项 getBean(dep); &#125; &#125; // 如果是 singleton scope 的，创建 singleton 的实例 if (mbd.isSingleton()) &#123; sharedInstance = getSingleton(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; try &#123; // 执行创建 Bean，详情后面再说 return createBean(beanName, mbd, args); &#125; catch (BeansException ex) &#123; destroySingleton(beanName); throw ex; &#125; &#125; &#125;); bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd); &#125; // 如果是 prototype scope 的，创建 prototype 的实例 else if (mbd.isPrototype()) &#123; // It's a prototype -&gt; create a new instance. Object prototypeInstance = null; try &#123; beforePrototypeCreation(beanName); // 执行创建 Bean prototypeInstance = createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd); &#125; // 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理 else &#123; String scopeName = mbd.getScope(); final Scope scope = this.scopes.get(scopeName); if (scope == null) &#123; throw new IllegalStateException(\"No Scope registered for scope name '\" + scopeName + \"'\"); &#125; try &#123; Object scopedInstance = scope.get(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; beforePrototypeCreation(beanName); try &#123; // 执行创建 Bean return createBean(beanName, mbd, args); &#125; finally &#123; afterPrototypeCreation(beanName); &#125; &#125; &#125;); bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd); &#125; catch (IllegalStateException ex) &#123; throw new BeanCreationException(beanName, \"Scope '\" + scopeName + \"' is not active for the current thread; consider \" + \"defining a scoped proxy for this bean if you intend to refer to it from a singleton\", ex); &#125; &#125; &#125; catch (BeansException ex) &#123; cleanupAfterBeanCreationFailure(beanName); throw ex; &#125; &#125; // 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了 if (requiredType != null &amp;&amp; bean != null &amp;&amp; !requiredType.isInstance(bean)) &#123; try &#123; return getTypeConverter().convertIfNecessary(bean, requiredType); &#125; catch (TypeMismatchException ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Failed to convert bean '\" + name + \"' to required type '\" + ClassUtils.getQualifiedName(requiredType) + \"'\", ex); &#125; throw new BeanNotOfRequiredTypeException(name, requiredType, bean.getClass()); &#125; &#125; return (T) bean;&#125; 大家应该也猜到了，接下来当然是分析 createBean 方法： 1protected abstract Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException; 第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。 这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。 主要是为了以下场景，采用 @Autowired 注解注入属性值： 12345678public class MessageServiceImpl implements MessageService &#123; @Autowired private UserService userService; public String getMessage() &#123; return userService.getMessage(); &#125;&#125; 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。 好了，读者要知道这么回事就可以了，继续向前。 // AbstractAutowireCapableBeanFactory 447 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * Central method of this class: creates a bean instance, * populates the bean instance, applies post-processors, etc. * @see #doCreateBean */@Overrideprotected Object createBean(String beanName, RootBeanDefinition mbd, Object[] args) throws BeanCreationException &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Creating instance of bean '\" + beanName + \"'\"); &#125; RootBeanDefinition mbdToUse = mbd; // 确保 BeanDefinition 中的 Class 被加载 Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName); if (resolvedClass != null &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != null) &#123; mbdToUse = new RootBeanDefinition(mbd); mbdToUse.setBeanClass(resolvedClass); &#125; // 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; // 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。 // 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看 try &#123; mbdToUse.prepareMethodOverrides(); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanDefinitionStoreException(mbdToUse.getResourceDescription(), beanName, \"Validation of method overrides failed\", ex); &#125; try &#123; // 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理， // 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过 Object bean = resolveBeforeInstantiation(beanName, mbdToUse); if (bean != null) &#123; return bean; &#125; &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbdToUse.getResourceDescription(), beanName, \"BeanPostProcessor before instantiation of bean failed\", ex); &#125; // 重头戏，创建 bean Object beanInstance = doCreateBean(beanName, mbdToUse, args); if (logger.isDebugEnabled()) &#123; logger.debug(\"Finished creating instance of bean '\" + beanName + \"'\"); &#125; return beanInstance;&#125; 创建 Bean我们继续往里看 doCreateBean 这个方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** * Actually create the specified bean. Pre-creation processing has already happened * at this point, e.g. checking &#123;@code postProcessBeforeInstantiation&#125; callbacks. * &lt;p&gt;Differentiates between default bean instantiation, use of a * factory method, and autowiring a constructor. * @param beanName the name of the bean * @param mbd the merged bean definition for the bean * @param args explicit arguments to use for constructor or factory method invocation * @return a new instance of the bean * @throws BeanCreationException if the bean could not be created * @see #instantiateBean * @see #instantiateUsingFactoryMethod * @see #autowireConstructor */protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args) throws BeanCreationException &#123; // Instantiate the bean. BeanWrapper instanceWrapper = null; if (mbd.isSingleton()) &#123; instanceWrapper = this.factoryBeanInstanceCache.remove(beanName); &#125; if (instanceWrapper == null) &#123; // 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说 instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; // 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 \"bean 实例\" final Object bean = (instanceWrapper != null ? instanceWrapper.getWrappedInstance() : null); // 类型 Class&lt;?&gt; beanType = (instanceWrapper != null ? instanceWrapper.getWrappedClass() : null); mbd.resolvedTargetType = beanType; // 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor synchronized (mbd.postProcessingLock) &#123; if (!mbd.postProcessed) &#123; try &#123; // MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的 applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName); &#125; catch (Throwable ex) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Post-processing of merged bean definition failed\", ex); &#125; mbd.postProcessed = true; &#125; &#125; // Eagerly cache singletons to be able to resolve circular references // even when triggered by lifecycle interfaces like BeanFactoryAware. // 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(\"Eagerly caching bean '\" + beanName + \"' to allow for resolving potential circular references\"); &#125; addSingletonFactory(beanName, new ObjectFactory&lt;Object&gt;() &#123; @Override public Object getObject() throws BeansException &#123; return getEarlyBeanReference(beanName, mbd, bean); &#125; &#125;); &#125; // Initialize the bean instance. Object exposedObject = bean; try &#123; // 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值 populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; // 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？ // 这里就是处理 bean 初始化完成后的各种回调 exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; &#125; catch (Throwable ex) &#123; if (ex instanceof BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123; throw (BeanCreationException) ex; &#125; else &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Initialization of bean failed\", ex); &#125; &#125; if (earlySingletonExposure) &#123; // Object earlySingletonReference = getSingleton(beanName, false); if (earlySingletonReference != null) &#123; if (exposedObject == bean) &#123; exposedObject = earlySingletonReference; &#125; else if (!this.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123; String[] dependentBeans = getDependentBeans(beanName); Set&lt;String&gt; actualDependentBeans = new LinkedHashSet&lt;String&gt;(dependentBeans.length); for (String dependentBean : dependentBeans) &#123; if (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123; actualDependentBeans.add(dependentBean); &#125; &#125; if (!actualDependentBeans.isEmpty()) &#123; throw new BeanCurrentlyInCreationException(beanName, \"Bean with name '\" + beanName + \"' has been injected into other beans [\" + StringUtils.collectionToCommaDelimitedString(actualDependentBeans) + \"] in its raw version as part of a circular reference, but has eventually been \" + \"wrapped. This means that said other beans do not use the final version of the \" + \"bean. This is often the result of over-eager type matching - consider using \" + \"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.\"); &#125; &#125; &#125; &#125; // Register bean as disposable. try &#123; registerDisposableBeanIfNecessary(beanName, bean, mbd); &#125; catch (BeanDefinitionValidationException ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Invalid destruction signature\", ex); &#125; return exposedObject;&#125; 到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。 接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。 创建 Bean 实例我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950protected BeanWrapper createBeanInstance(String beanName, RootBeanDefinition mbd, Object[] args) &#123; // 确保已经加载了此 class Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName); // 校验一下这个类的访问权限 if (beanClass != null &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123; throw new BeanCreationException(mbd.getResourceDescription(), beanName, \"Bean class isn't public, and non-public access not allowed: \" + beanClass.getName()); &#125; if (mbd.getFactoryMethodName() != null) &#123; // 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean return instantiateUsingFactoryMethod(beanName, mbd, args); &#125; // 如果不是第一次创建，比如第二次创建 prototype bean。 // 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化 boolean resolved = false; boolean autowireNecessary = false; if (args == null) &#123; synchronized (mbd.constructorArgumentLock) &#123; if (mbd.resolvedConstructorOrFactoryMethod != null) &#123; resolved = true; autowireNecessary = mbd.constructorArgumentsResolved; &#125; &#125; &#125; if (resolved) &#123; if (autowireNecessary) &#123; // 构造函数依赖注入 return autowireConstructor(beanName, mbd, null, null); &#125; else &#123; // 无参构造函数 return instantiateBean(beanName, mbd); &#125; &#125; // 判断是否采用有参构造函数 Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName); if (ctors != null || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR || mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123; // 构造函数依赖注入 return autowireConstructor(beanName, mbd, ctors, args); &#125; // 调用无参构造函数 return instantiateBean(beanName, mbd);&#125; 挑个简单的无参构造函数构造实例来看看： 123456789101112131415161718192021222324252627protected BeanWrapper instantiateBean(final String beanName, final RootBeanDefinition mbd) &#123; try &#123; Object beanInstance; final BeanFactory parent = this; if (System.getSecurityManager() != null) &#123; beanInstance = AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; return getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 实例化 beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); &#125; // 包装一下，返回 BeanWrapper bw = new BeanWrapperImpl(beanInstance); initBeanWrapper(bw); return bw; &#125; catch (Throwable ex) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Instantiation of bean failed\", ex); &#125;&#125; 我们可以看到，关键的地方在于： 1beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent); 这里会进行实际的实例化过程，我们进去看看: // SimpleInstantiationStrategy 59 123456789101112131415161718192021222324252627282930313233343536373839404142@Overridepublic Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB, // 方法覆写 请参见附录\"方法注入\"中对 lookup-method 和 replaced-method 的介绍 if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, \"Specified class is an interface\"); &#125; try &#123; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, \"No default constructor found\", ex); &#125; &#125; &#125; // 利用构造方法进行实例化 return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。 // tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持 return instantiateWithMethodInjection(bd, beanName, owner); &#125;&#125; 到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。 bean 属性注入看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。 // AbstractAutowireCapableBeanFactory 1203 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778protected void populateBean(String beanName, RootBeanDefinition mbd, BeanWrapper bw) &#123; // bean 实例的所有属性都在这里了 PropertyValues pvs = mbd.getPropertyValues(); if (bw == null) &#123; if (!pvs.isEmpty()) &#123; throw new BeanCreationException( mbd.getResourceDescription(), beanName, \"Cannot apply property values to null instance\"); &#125; else &#123; // Skip property population phase for null instance. return; &#125; &#125; // 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值， // InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改， // 我也没找到有实际的使用，所以我们暂且忽略这块吧 boolean continueWithPropertyPopulation = true; if (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理 if (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123; continueWithPropertyPopulation = false; break; &#125; &#125; &#125; &#125; if (!continueWithPropertyPopulation) &#123; return; &#125; if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); // 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; // 通过类型装配。复杂一些 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; pvs = newPvs; &#125; boolean hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors(); boolean needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE); if (hasInstAwareBpps || needsDepCheck) &#123; PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching); if (hasInstAwareBpps) &#123; for (BeanPostProcessor bp : getBeanPostProcessors()) &#123; if (bp instanceof InstantiationAwareBeanPostProcessor) &#123; InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp; // 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor // 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究 pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName); if (pvs == null) &#123; return; &#125; &#125; &#125; &#125; if (needsDepCheck) &#123; checkDependencies(beanName, mbd, filteredPds, pvs); &#125; &#125; // 设置 bean 实例的属性值 applyPropertyValues(beanName, mbd, bw, pvs);&#125; initializeBean属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。 1234567891011121314151617181920212223242526272829303132333435363738protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; // 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // BeanPostProcessor 的 postProcessBeforeInitialization 回调 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; // 处理 bean 中定义的 init-method， // 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, \"Invocation of init method failed\", ex); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // BeanPostProcessor 的 postProcessAfterInitialization 回调 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; 大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？ 附录id 和 name每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。 我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。 1beanFactory.getBean(\"beanName or alias\"); 在配置 &lt;bean /&gt; 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。 1&lt;bean id=\"messageService\" name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。 1&lt;bean name=\"m1, m2, m3\" class=\"com.javadoop.example.MessageServiceImpl\" /&gt; 以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。 1&lt;bean class=\"com.javadoop.example.MessageServiceImpl\"&gt; beanName 为：com.javadoop.example.MessageServiceImpl#0， 别名 1 个，为： com.javadoop.example.MessageServiceImpl 1&lt;bean id=\"messageService\" class=\"com.javadoop.example.MessageServiceImpl\"&gt; 以上配置的结果就是：beanName 为 messageService，没有别名。 配置是否允许 Bean 覆盖、是否允许循环依赖我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。 可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。 循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。 它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。 添加这两个属性的作者 Juergen Hoeller 在这个 jira 的讨论中说明了怎么配置这两个属性。 123456789public class NoBeanOverridingContextLoader extends ContextLoader &#123; @Override protected void customizeContext(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext) &#123; super.customizeContext(servletContext, applicationContext); AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext; arac.setAllowBeanDefinitionOverriding(false); &#125;&#125; 12345678public class MyContextLoaderListener extends org.springframework.web.context.ContextLoaderListener &#123; @Override protected ContextLoader createContextLoader() &#123; return new NoBeanOverridingContextLoader(); &#125; &#125; 123&lt;listener&gt; &lt;listener-class&gt;com.javadoop.MyContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; 如果以上方式不能满足你的需求，请参考这个链接：解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题 profile我们可以把不同环境的配置分别配置到单独的文件中，举个例子： 1234567891011&lt;beans profile=\"development\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xsi:schemaLocation=\"...\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt;&lt;/beans&gt; 12345678&lt;beans profile=\"production\" xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt;&lt;/beans&gt; 应该不必做过多解释了吧，看每个文件第一行的 profile=””。 当然，我们也可以在一个配置文件中使用： 1234567891011121314151617&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" xmlns:jee=\"http://www.springframework.org/schema/jee\" xsi:schemaLocation=\"...\"&gt; &lt;beans profile=\"development\"&gt; &lt;jdbc:embedded-database id=\"dataSource\"&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/&gt; &lt;jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile=\"production\"&gt; &lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/&gt; &lt;/beans&gt;&lt;/beans&gt; 理解起来也很简单吧。 接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？ Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。 最简单的方式莫过于在程序启动的时候指定： 1-Dspring.profiles.active=\"profile1,profile2\" profile 可以激活多个 当然，我们也可以通过代码的形式从 Environment 中设置 profile： 1234AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();ctx.getEnvironment().setActiveProfiles(\"development\");ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class);ctx.refresh(); // 重启 如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile： 1java -Dspring.profiles.active=prod -jar JavaDoop.jar 如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。 工厂模式生成 Bean请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。 设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。 静态工厂： 123&lt;bean id=\"clientService\" class=\"examples.ClientService\" factory-method=\"createInstance\"/&gt; 123456789public class ClientService &#123; private static ClientService clientService = new ClientService(); private ClientService() &#123;&#125; // 静态方法 public static ClientService createInstance() &#123; return clientService; &#125;&#125; 实例工厂： 1234567891011&lt;bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\"&gt; &lt;!-- inject any dependencies required by this locator bean --&gt;&lt;/bean&gt;&lt;bean id=\"clientService\" factory-bean=\"serviceLocator\" factory-method=\"createClientServiceInstance\"/&gt;&lt;bean id=\"accountService\" factory-bean=\"serviceLocator\" factory-method=\"createAccountServiceInstance\"/&gt; 1234567891011121314public class DefaultServiceLocator &#123; private static ClientService clientService = new ClientServiceImpl(); private static AccountService accountService = new AccountServiceImpl(); public ClientService createClientServiceInstance() &#123; return clientService; &#125; public AccountService createAccountServiceInstance() &#123; return accountService; &#125;&#125; FactoryBeanFactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。 12345public interface FactoryBean&lt;T&gt; &#123; T getObject() throws Exception; Class&lt;T&gt; getObjectType(); boolean isSingleton();&#125; 1234public class Person &#123; private Car car ; private void setCar(Car car)&#123; this.car = car; &#125; &#125; 我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来： 123456789101112131415161718192021public class MyCarFactoryBean implements FactoryBean&lt;Car&gt;&#123; private String make; private int year ; public void setMake(String m)&#123; this.make =m ; &#125; public void setYear(int y)&#123; this.year = y; &#125; public Car getObject()&#123; // 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种 CarBuilder cb = CarBuilder.car(); if(year!=0) cb.setYear(this.year); if(StringUtils.hasText(this.make)) cb.setMake( this.make ); return cb.factory(); &#125; public Class&lt;Car&gt; getObjectType() &#123; return Car.class ; &#125; public boolean isSingleton() &#123; return false; &#125;&#125; 我们看看装配的时候是怎么配置的： 1234567&lt;bean class = \"com.javadoop.MyCarFactoryBean\" id = \"car\"&gt; &lt;property name = \"make\" value =\"Honda\"/&gt; &lt;property name = \"year\" value =\"1984\"/&gt;&lt;/bean&gt;&lt;bean class = \"com.javadoop.Person\" id = \"josh\"&gt; &lt;property name = \"car\" ref = \"car\"/&gt;&lt;/bean&gt; 看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。 说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java config 的方式来配置，这里有什么不一样呢？ 12345678910111213141516171819@Configuration public class CarConfiguration &#123; @Bean public MyCarFactoryBean carFactoryBean()&#123; MyCarFactoryBean cfb = new MyCarFactoryBean(); cfb.setMake(\"Honda\"); cfb.setYear(1984); return cfb; &#125; @Bean public Person aPerson()&#123; Person person = new Person(); // 注意这里的不同 person.setCar(carFactoryBean().getObject()); return person; &#125; &#125; 这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。 初始化 Bean 的回调有以下四种方案： 1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" init-method=\"init\"/&gt; 123456public class AnotherExampleBean implements InitializingBean &#123; public void afterPropertiesSet() &#123; // do some initialization work &#125;&#125; 1234@Bean(initMethod = \"init\")public Foo foo() &#123; return new Foo();&#125; 1234@PostConstructpublic void init() &#123; &#125; 销毁 Bean 的回调1&lt;bean id=\"exampleInitBean\" class=\"examples.ExampleBean\" destroy-method=\"cleanup\"/&gt; 123456public class AnotherExampleBean implements DisposableBean &#123; public void destroy() &#123; // do some destruction work (like releasing pooled connections) &#125;&#125; 1234@Bean(destroyMethod = \"cleanup\")public Bar bar() &#123; return new Bar();&#125; 1234@PreDestroypublic void cleanup() &#123; &#125; ConversionService既然文中说到了这个，顺便提一下好了。 最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。 像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。 12345678&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;list&gt; &lt;bean class=\"com.javadoop.learning.utils.StringToEnumConverterFactory\"/&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。 下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。 来看一个很简单的例子，这样比什么都管用。 1234567891011public class StringToDateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; try &#123; return DateUtils.parseDate(source, \"yyyy-MM-dd\", \"yyyy-MM-dd HH:mm:ss\", \"yyyy-MM-dd HH:mm\", \"HH:mm:ss\", \"HH:mm\"); &#125; catch (ParseException e) &#123; return null; &#125; &#125;&#125; 只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。 Bean 继承在初始化 Bean 的地方，我们说过了这个： 1RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); 这里涉及到的就是 &lt;bean parent=&quot;&quot; /&gt; 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。 首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。 Spring 中提供了继承自 AbstractBeanDefinition 的 ChildBeanDefinition 来表示 child bean。 看如下一个例子: 12345678910&lt;bean id=\"inheritedTestBean\" abstract=\"true\" class=\"org.springframework.beans.TestBean\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt;&lt;bean id=\"inheritsWithDifferentClass\" class=\"org.springframework.beans.DerivedTestBean\" parent=\"inheritedTestBean\" init-method=\"initialize\"&gt; &lt;property name=\"name\" value=\"override\"/&gt;&lt;/bean&gt; parent bean 设置了 abstract=&quot;true&quot; 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。 child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。 当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。 比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。 1234&lt;bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\"&gt; &lt;property name=\"name\" value=\"parent\"/&gt; &lt;property name=\"age\" value=\"1\"/&gt;&lt;/bean&gt; 方法注入一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。 但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。 一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。 另一种解决方案就是这里要介绍的通过使用 Lookup method。 lookup-method我们来看一下 Spring Reference 中提供的一个例子： 1234567891011121314151617package fiona.apple;// no more Spring imports!public abstract class CommandManager &#123; public Object process(Object commandState) &#123; // grab a new instance of the appropriate Command interface Command command = createCommand(); // set the state on the (hopefully brand new) Command instance command.setState(commandState); return command.execute(); &#125; // okay... but where is the implementation of this method? protected abstract Command createCommand();&#125; xml 配置 &lt;lookup-method /&gt;： 123456789&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;&lt;bean id=\"myCommand\" class=\"fiona.apple.AsyncCommand\" scope=\"prototype\"&gt; &lt;!-- inject dependencies here as required --&gt;&lt;/bean&gt;&lt;!-- commandProcessor uses statefulCommandHelper --&gt;&lt;bean id=\"commandManager\" class=\"fiona.apple.CommandManager\"&gt; &lt;lookup-method name=\"createCommand\" bean=\"myCommand\"/&gt;&lt;/bean&gt; Spring 采用 CGLIB 生成字节码的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。 lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 &lt;lookup-method /&gt; 了，其他不变： 1234567891011public abstract class CommandManager &#123; public Object process(Object commandState) &#123; MyCommand command = createCommand(); command.setState(commandState); return command.execute(); &#125; @Lookup(\"myCommand\") protected abstract Command createCommand();&#125; 注意，既然用了注解，要配置注解扫描：&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt; 甚至，我们可以像下面这样： 1234567891011public abstract class CommandManager &#123; public Object process(Object commandState) &#123; MyCommand command = createCommand(); command.setState(commandState); return command.execute(); &#125; @Lookup protected abstract MyCommand createCommand();&#125; 上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。 replaced-method记住它的功能，就是替换掉 bean 中的一些方法。 12345678public class MyValueCalculator &#123; public String computeValue(String input) &#123; // some real code... &#125; // some other methods...&#125; 方法覆写，注意要实现 MethodReplacer 接口： 123456789public class ReplacementComputeValue implements org.springframework.beans.factory.support.MethodReplacer &#123; public Object reimplement(Object o, Method m, Object[] args) throws Throwable &#123; // get the input value, work with it, and return a computed result String input = (String) args[0]; ... return ...; &#125;&#125; 配置也很简单： 12345678&lt;bean id=\"myValueCalculator\" class=\"x.y.z.MyValueCalculator\"&gt; &lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt; &lt;replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"&gt; &lt;arg-type&gt;String&lt;/arg-type&gt; &lt;/replaced-method&gt;&lt;/bean&gt;&lt;bean id=\"replacementComputeValue\" class=\"a.b.c.ReplacementComputeValue\"/&gt; arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。 BeanPostProcessor应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义： 1234567public interface BeanPostProcessor &#123; Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。 首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。 我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。 那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。 最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？ 如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。 首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。 总结按理说，总结应该写在附录前面，我就不讲究了。 在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。 本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。 （全文完） 再次郑重声明 : 本文转载自我关注的一位大佬的博客,原文链接: https://www.javadoop.com/post/spring-ioc ,如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.","categories":[{"name":"框架","slug":"框架","permalink":"https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.enjoyican.com/tags/spring/"}]},{"title":"spring事件监听","date":"2019-09-06T12:29:30.000Z","path":"posts/spring-application-listener/","text":"业务场景：在一个加了事务的service方法中，有数据库操作，有MQ消息的发送，MQ发送后消息消费端需要回查数据库，目前存在的一个情况是在数据库操作事务尚未提交的情况下，消息就发送成功了，此时消息消费者回查数据库，数据依然是未更改的状态，导致消息消费失败。 需求：我们希望能够控制在事务提交成功之后消息再消费 方案：采用spring事件监听机制，当监听到事务成功提交后，开始发布消息： 1.事件发布者需要实现ApplicationEventPublisherAware接口：相关详细解释可以参考以下博客：深入理解spring容器内事件发布监听机制 代码如下： 123456789101112131415161718192021222324252627282930@Slf4j@Componentpublic class SendMqEventPublisher implements ApplicationEventPublisherAware &#123; private static ApplicationEventPublisher eventPublisher; @Override public void setApplicationEventPublisher(ApplicationEventPublisher applicationEventPublisher) &#123; if (eventPublisher == null) &#123; eventPublisher = applicationEventPublisher; &#125; &#125; /** * @description 发布事件 */ public void publishEvent(BaseEvent event) &#123; log.info(\"===&gt; 发布sendMq事件: &#123;&#125;\", event); eventPublisher.publishEvent(event); &#125; public void publishMqEvent(String topic, String tag, MessageObject messageObject) &#123; SendMqParam sendMqParam = new SendMqParam(); sendMqParam.setTopic(topic); sendMqParam.setTag(tag); sendMqParam.setMessageObject(messageObject); this.publishEvent(new BaseEvent(sendMqParam)); &#125;&#125; 其中要发布的事件体BaseEvent继承自ApplicationEvent： 123public class BaseEvent&lt;T&gt; extends ApplicationEvent &#123; //具体消息体自定义&#125; 2.在事务方法中进行事件发布：12345678910111213141516@Override @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) public void processOneAchieve(UpgradeStoreAchievementEntity storeAchievementEntity) &#123; //其他数据库操作相关的业务逻辑 //事件发布 UpgradeOperateMqo upgradeOperateMqo = new UpgradeOperateMqo(); upgradeOperateMqo.setStarstoreId(currentStarstoreId); sendMqEventPublisher.publishMqEvent(MessageConstant.STARSTORE_RELATION_TOPIC, MessageConstant.STARSTORE_UPGRADE_OPERATE_TAG, MessageBuilder.overMessage(upgradeOperateMqo)); &#125; finally &#123; distLockSservice.unlock(lockResult); &#125; &#125; 3.事件监听者通过注解监听发布的事件通过在方法上增加注解@TransactionalEventListener进行事件监听消费（该注解只监听事务相关的事件），其中参数phase参数可以控制监听到事件后处理事件与提交事务的前后关系： 参数值有下面四种：BEFORE_COMMIT,AFTER_COMMIT,AFTER_ROLLBACK,AFTER_COMPLETION; 1234567891011121314151617@Component@Slf4jpublic class SendMqEventListener &#123; @Autowired private RocketMQTemplate rocketMQTemplate; @TransactionalEventListener(fallbackExecution = true, phase = TransactionPhase.AFTER_COMMIT) public void onApplicationEvent(BaseEvent&lt;SendMqParam&gt; event) &#123; SendMqParam sendMqParam = (SendMqParam) event.getSource(); String name = Thread.currentThread().getName(); log.info(\"===&gt; 收到sendMq事件: &#123;&#125;，线程名为： &#123;&#125;\", sendMqParam, name); rocketMQTemplate.sendNormal(sendMqParam.getTopic(), sendMqParam.getTag(), sendMqParam.getMessageObject()); &#125;&#125; 注意spring事件发布者和监听者都需要加入spring管理，@Component注解不要忘记 永不言败","categories":[{"name":"框架","slug":"框架","permalink":"https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://www.enjoyican.com/tags/spring/"}]}]