<!DOCTYPE html>
<html>
<head>
    

    
<!-- Tencent Speed -->
<script>var _speedMark = new Date()</script>
<!-- End Tencent Speed -->
<!-- Tencent Analysis -->
<script async src="//tajs.qq.com/stats?sId=66530752"></script>
<!-- End Tencent Analysis -->


    


<!-- Baidu Push -->
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<!-- End Baidu Push -->


    <meta charset="utf-8">
    
    
    
    <link rel="canonical" href="https://www.enjoyican.com//posts/java-performance-tuning/">
    
    
    <title>java性能调优实战学习笔记 | Running | Better Late Than Never</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="note">
    <meta name="description" content="这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看了，后续有时间再看吧 有任何问题可在我的CSDN或者该博客下面留言即可">
<meta property="og:type" content="article">
<meta property="og:title" content="java性能调优实战学习笔记">
<meta property="og:url" content="https://www.enjoyican.com/posts/java-performance-tuning/index.html">
<meta property="og:site_name" content="Running">
<meta property="og:description" content="这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看了，后续有时间再看吧 有任何问题可在我的CSDN或者该博客下面留言即可">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/strategy.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/1.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/2.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/3.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/4.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/stream.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/explain-sql.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/system-const.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/eq-ref.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/ref.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/range.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/index.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/profile.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/show-profile.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/subquery1.jpg">
<meta property="og:image" content="https://www.enjoyican.com/img/java-performance-tuning/subquery2.jpg">
<meta property="article:published_time" content="2020-05-27T15:51:30.000Z">
<meta property="article:modified_time" content="2020-05-27T15:51:30.000Z">
<meta property="article:author" content="enjoycodingfun">
<meta property="article:tag" content="note">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.enjoyican.com/img/java-performance-tuning/strategy.jpg">
    
        <link rel="alternate" type="application/atom+xml" title="Running" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/timg.jpg">
    <link rel="stylesheet" href="/css/style.css?v=1.7.2">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/head.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">enjoycodingfun</h5>
          <a href="mailto:17364562230@163.com" title="17364562230@163.com" class="mail">17364562230@163.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                归档
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                分类
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/enjoycodingfun" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://blog.csdn.net/u010408502" target="_blank" rel="noopener"  >
                <i class="icon icon-lg icon-link"></i>
                CSDN
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/img/mywechat.png"  >
                <i class="icon icon-lg icon-wechat"></i>
                微信
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">java性能调优实战学习笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">java性能调优实战学习笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-05-27T15:51:30.000Z" itemprop="datePublished" class="page-time">
  2020-05-27
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>大纲</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何制定性能调优标准"><span class="post-toc-text">如何制定性能调优标准</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#如何制定性能调优策略"><span class="post-toc-text">如何制定性能调优策略</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#慎重使用正则表达式"><span class="post-toc-text">慎重使用正则表达式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#如何减少回溯问题？"><span class="post-toc-text">如何减少回溯问题？</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#正则表达式的优化"><span class="post-toc-text">正则表达式的优化</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#ArrayList和LinkedList"><span class="post-toc-text">ArrayList和LinkedList</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Stream如何提高遍历集合效率"><span class="post-toc-text">Stream如何提高遍历集合效率</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Hashmap"><span class="post-toc-text">Hashmap</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MySQL调优之SQL语句：如何写出高性能SQL语句？"><span class="post-toc-text">MySQL调优之SQL语句：如何写出高性能SQL语句？</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#慢-SQL-语句的几种常见诱因"><span class="post-toc-text">慢 SQL 语句的几种常见诱因</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#优化-SQL-语句的步骤"><span class="post-toc-text">优化 SQL 语句的步骤</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过-EXPLAIN-分析-SQL-执行计划"><span class="post-toc-text">通过 EXPLAIN 分析 SQL 执行计划</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#通过-Show-Profile-分析-SQL-执行性能"><span class="post-toc-text">通过 Show Profile 分析 SQL 执行性能</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#常用的-SQL-优化"><span class="post-toc-text">常用的 SQL 优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#优化分页查询"><span class="post-toc-text">优化分页查询</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#优化-SELECT-COUNT"><span class="post-toc-text">优化 SELECT COUNT(*)</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MySQL调优之事务：高并发场景下的数据库事务调优"><span class="post-toc-text">MySQL调优之事务：高并发场景下的数据库事务调优</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#优化高并发事务"><span class="post-toc-text">优化高并发事务</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#MySQL调优之索引：索引的失效与优化"><span class="post-toc-text">MySQL调优之索引：索引的失效与优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#覆盖索引优化查询"><span class="post-toc-text">覆盖索引优化查询</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#自增字段作主键优化查询"><span class="post-toc-text">自增字段作主键优化查询</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#前缀索引优化"><span class="post-toc-text">前缀索引优化</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#防止索引失效"><span class="post-toc-text">防止索引失效</span></a></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-java-performance-tuning"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">java性能调优实战学习笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-05-27 23:51:30" datetime="2020-05-27T15:51:30.000Z"  itemprop="datePublished">2020-05-27</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看了，后续有时间再看吧</p>
<p>有任何问题可在我的<a href="https://blog.csdn.net/u010408502/article/details/106394408" target="_blank" rel="noopener">CSDN</a>或者该博客下面留言即可</p>
<a id="more"></a>

<h2 id="如何制定性能调优标准"><a href="#如何制定性能调优标准" class="headerlink" title="如何制定性能调优标准"></a>如何制定性能调优标准</h2><p> 有哪些参考因素可以体现系统的性能？ </p>
<p> 在我们了解性能指标之前，我们先来了解下哪些计算机资源会成为系统的性能瓶颈。 </p>
<p> CPU 、内存、磁盘IO、网络、异常、数据库、锁竞争</p>
<ul>
<li>CPU：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。</li>
<li>内存：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。</li>
<li>磁盘 I/O：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。</li>
<li>网络：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。</li>
<li>异常：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。</li>
<li>数据库：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。</li>
<li>锁竞争：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。 </li>
</ul>
<p>可以用下面几个指标，来衡量一般系统的性能 ：</p>
<p> <strong>响应时间</strong> </p>
<ul>
<li><p>数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；</p>
</li>
<li><p>服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；</p>
</li>
<li><p>网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；</p>
</li>
<li><p>客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。 </p>
<p><strong>吞吐量</strong> </p>
</li>
</ul>
<p>在测试中，我们往往会比较注重系统接口的 TPS（每秒事务处理量），因为 TPS 体现了接口的性能，TPS 越大，性能越好。在系统中，我们也可以把吞吐量自下而上地分为两种：磁盘吞吐量和网络吞吐量。</p>
<p>我们先来看<strong>磁盘吞吐量</strong>，磁盘性能有两个关键衡量指标。</p>
<p>一种是<code>IOPS（Input/Output Per Second）</code>，即每秒的输入输出量（或读写次数），这种是指单位时间内系统能处理的 I/O 请求数量，I/O 请求通常为读或写数据操作请求，关注的是随机读写性能。适应于随机读写频繁的应用，如小文件存储（图片）、OLTP 数据库、邮件服务器。</p>
<p>另一种是数据吞吐量，这种是指单位时间内可以成功传输的数据量。对于大量顺序读写频繁的应用，传输大量连续数据，例如，电视台的视频编辑、视频点播 VOD（Video On Demand），数据吞吐量则是关键衡量指标。 </p>
<p> <strong>网络吞吐量</strong>这个是指网络传输时没有帧丢失的情况下，设备能够接受的最大数据速率。网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。而吞吐量的大小主要由网卡的处理能力、内部程序算法以及带宽大小决定。 </p>
<p> <strong>计算机资源分配使用率</strong></p>
<p>通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。这几个参数好比一个木桶，如果其中任何一块木板出现短板，任何一项分配不合理，对整个系统性能的影响都是毁灭性的。</p>
<p><strong>负载承受能力</strong></p>
<p>当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。例如，当你对系统进行压测时，系统的响应时间会随着系统并发数的增加而延长，直到系统无法处理这么多请求，抛出大量错误时，就到了极限。 </p>
<h2 id="如何制定性能调优策略"><a href="#如何制定性能调优策略" class="headerlink" title="如何制定性能调优策略"></a>如何制定性能调优策略</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://www.enjoyican.com/img/java-performance-tuning/strategy.jpg" alt="性能调优策略" title="">
                </div>
                <div class="image-caption">性能调优策略</div>
            </figure>

<h2 id="慎重使用正则表达式"><a href="#慎重使用正则表达式" class="headerlink" title="慎重使用正则表达式"></a>慎重使用正则表达式</h2><p><strong>正则表达式引擎</strong> </p>
<p> 正则表达式是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。</p>
<p>而这里的正则表达式引擎就是一套核心算法，用于建立状态机。</p>
<p>目前实现正则表达式引擎的方式有两种：DFA 自动机（Deterministic Final Automaton 确定有限状态自动机）和 NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。</p>
<p>对比来看，构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机。</p>
<p>假设一个字符串的长度是 n，如果用 DFA 自动机作为正则表达式引擎，则匹配的时间复杂度为 O(n)；如果用 NFA 自动机作为正则表达式引擎，由于 NFA 自动机在匹配过程中存在大量的分支和回溯，假设 NFA 的状态数为 s，则该匹配算法的时间复杂度为 O（ns）。</p>
<p>NFA 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 NFA 实现的。 </p>
<p><strong>用 NFA 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。</strong> </p>
<p>举例说明 :</p>
<blockquote>
<p> text=“abbc”</p>
<p>regex=“ab{1,3}c” </p>
</blockquote>
<p> 这个例子，匹配目的比较简单。匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 自动机对其解析的过程是这样的：首先，读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/1.jpg" alt=""></p>
<p> 然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。但因为 b{1,3} 表示 1-3 个 b 字符串，NFA 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 进行比较，结果还是匹配。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/2.jpg" alt=""></p>
<p> 接着继续使用 b{1,3} 和字符串的第四个字符 c 进行比较，发现不匹配了，<strong>此时就会发生回溯</strong>，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/3.jpg" alt=""></p>
<p> 那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/4.jpg" alt=""></p>
<h3 id="如何减少回溯问题？"><a href="#如何减少回溯问题？" class="headerlink" title="如何减少回溯问题？"></a>如何减少回溯问题？</h3><p>既然回溯会给系统带来性能开销，那我们如何应对呢？如果你有仔细看上面那个案例的话，你会发现 NFA 自动机的贪婪特性就是导火索，这和正则表达式的匹配模式息息相关。 </p>
<p><strong>贪婪模式（Greedy）</strong>顾名思义，就是在数量匹配中，如果单独使用<code>+、 ? 、* 或{min,max}</code> 等量词，正则表达式会匹配尽可能多的内容。例如，上边那个例子： </p>
<p><strong>懒惰模式（Reluctant）</strong>在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。 </p>
<p> 例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。 </p>
<blockquote>
<p> text=“abc”</p>
<p>regex=“ab{1,3}?c” </p>
</blockquote>
<p> 匹配结果是“abc”，该模式下 NFA 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。</p>
<p>懒惰模式是无法完全避免回溯的，我们再通过一个例子来了解下懒惰模式在什么情况下会发生回溯问题。 </p>
<blockquote>
<p> text=“abbc”</p>
<p>regex=“ab{1,3}?c” </p>
</blockquote>
<p>以上匹配结果依然是成功的，这又是为什么呢？我们可以通过懒惰模式的匹配过程来了解下原因。</p>
<p>首先，读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。</p>
<p>其次，由于懒惰模式下，正则表达式会尽可能少地重复匹配字符，匹配字符串中的下一个匹配字符 b 不会继续与 b{1,3}进行匹配，转而匹配正则表达式中的下一个字符 c。  </p>
<p>此时你会发现匹配字符 b 与正则表达式中的字符 c 是不匹配的，这个时候会发生一次回溯，这次的回溯与贪婪模式中的回溯刚好相反，<strong>懒惰模式的回溯是回溯正则表达式中一个匹配字符，与上一个字符再进行匹配</strong>。如果匹配，则将匹配字符串的下一个字符和正则表达式的下一个字符。 </p>
<p><strong>独占模式（Possessive）</strong> </p>
<p><strong>同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。</strong> </p>
<p> 还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。</p>
<blockquote>
<p>text=“abbc”</p>
<p>regex=“ab{1,3}+bc” </p>
</blockquote>
<p>结果是不匹配，结束匹配，不会发生回溯问题。</p>
<p>同样，独占模式也不能避免回溯的发生，我们再拿最开始的这个例子来分析下：</p>
<blockquote>
<p>text=“abbc”</p>
<p>regex=“ab{1,3}+c” </p>
</blockquote>
<p>结果是匹配的，这是因为<strong>与贪婪模式一样，独占模式一样会最大限度地匹配更多内容</strong>，即匹配完所有的 b 之后，再去匹配 c，则匹配成功了。 </p>
<p><strong>在很多情况下使用懒惰模式和独占模式可以减少回溯的发生。</strong> </p>
<h3 id="正则表达式的优化"><a href="#正则表达式的优化" class="headerlink" title="正则表达式的优化"></a>正则表达式的优化</h3><ol>
<li><p><strong>少用贪婪模式，多用独占模式</strong></p>
<p>贪婪模式会引起回溯问题，我们可以使用独占模式来避免回溯。前面详解过了，这里我就不再解释了。</p>
</li>
<li><p><strong>减少分支选择</strong></p>
<p>分支选择类型“(X|Y|Z)”的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：</p>
<p>首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；</p>
<p>其次，我们可以尝试提取共用模式，例如，将“(abcd|abef)”替换为“ab(cd|ef)”，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；</p>
<p>最后，如果是简单的分支选择类型，我们可以用三次 index 代替“(X|Y|Z)”，如果测试的话，你就会发现三次 index 的效率要比“(X|Y|Z)”高出一些。 </p>
</li>
<li><p><strong>减少捕获嵌套</strong> </p>
<p> 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。</p>
<p>非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成。</p>
<p>在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String text = <span class="string">"&lt;input high=\"20\" weight=\"70\"&gt;test&lt;/input&gt;"</span>;</span><br><span class="line">  String reg=<span class="string">"(&lt;input.*?&gt;)(.*?)(&lt;/input&gt;)"</span>;</span><br><span class="line">  Pattern p = Pattern.compile(reg);</span><br><span class="line">  Matcher m = p.matcher(text);</span><br><span class="line">  <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group(<span class="number">0</span>));<span class="comment">//整个匹配到的内容</span></span><br><span class="line">    System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(&lt;input.*?&gt;)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">2</span>));<span class="comment">//(.*?)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">3</span>));<span class="comment">//(&lt;/input&gt;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high=<span class="tag">\<span class="name">"</span></span>20<span class="tag">\<span class="name">"</span></span> weight=<span class="tag">\<span class="name">"</span></span>70<span class="tag">\<span class="name">"</span></span>&gt;test&lt;/input&gt;</span><br><span class="line">&lt;input high=<span class="tag">\<span class="name">"</span></span>20<span class="tag">\<span class="name">"</span></span> weight=<span class="tag">\<span class="name">"</span></span>70<span class="tag">\<span class="name">"</span></span>&gt;</span><br><span class="line">test</span><br><span class="line">&lt;/input&gt;</span><br></pre></td></tr></table></figure>

<p> 如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，我们再看下面的例子： </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String text = <span class="string">"&lt;input high=\"20\" weight=\"70\"&gt;test&lt;/input&gt;"</span>;</span><br><span class="line">  String reg=<span class="string">"(?:&lt;input.*?&gt;)(.*?)(?:&lt;/input&gt;)"</span>;</span><br><span class="line">  Pattern p = Pattern.compile(reg);</span><br><span class="line">  Matcher m = p.matcher(text);</span><br><span class="line">  <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group(<span class="number">0</span>));<span class="comment">//整个匹配到的内容</span></span><br><span class="line">    System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(.*?)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high&#x3D;\&quot;20\&quot; weight&#x3D;\&quot;70\&quot;&gt;test&lt;&#x2F;input&gt;</span><br><span class="line">test</span><br></pre></td></tr></table></figure>

<p> 综上可知：减少不需要获取的分组，可以提高正则表达式的性能。 </p>
</li>
</ol>
<p>正则表达式虽然小，却有着强大的匹配功能。我们经常用到它，比如，注册页面手机号或邮箱的校验。</p>
<p>但很多时候，我们又会因为它小而忽略它的使用规则，测试用例中又没有覆盖到一些特殊用例，不乏上线就中招的情况发生。</p>
<p>如果使用正则表达式能使你的代码简洁方便，那么在做好性能排查的前提下，可以去使用；如果不能，那么正则表达式能不用就不用，以此避免造成更多的性能问题。 </p>
<h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><p>我们在查看 ArrayList 的实现类源码时，你会发现对象数组 elementData 使用了 transient 修饰，我们知道 transient 关键字修饰该属性，则表示该属性不会被序列化，然而我们并没有看到文档中说明 ArrayList 不能被序列化，这是为什么？ </p>
<blockquote>
<p> ArrayList 属性主要由数组长度 size、对象数组 elementData、初始化容量 default_capacity 等组成， 其中初始化容量默认大小为 10。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">//对象数组</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">   <span class="comment">//数组长度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure>

<p>从 ArrayList 属性来看，它没有被任何的多线程关键字修饰，但 elementData 被关键字 transient 修饰了。</p>
<p>由于 ArrayList 的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。如果采用外部序列化法实现数组的序列化，会序列化整个数组。ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法 writeObject 以及 readObject 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p>
<p><strong>因此使用 transient 修饰数组，是防止对象数组被其他外部方法序列化</strong>。 </p>
</blockquote>
<h2 id="Stream如何提高遍历集合效率"><a href="#Stream如何提高遍历集合效率" class="headerlink" title="Stream如何提高遍历集合效率"></a>Stream如何提高遍历集合效率</h2><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。 </p>
<p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。 </p>
<p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。操作分类详情如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://www.enjoyican.com/img/java-performance-tuning/stream.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure> 

<p> 我们通常还会将中间操作称为懒操作，也正是由这种懒操作结合终结操作、数据源构成的处理管道（Pipeline），实现了 Stream 的高效。 </p>
<p>在循环迭代次数较少的情况下，常规的迭代方式性能反而更好；在单核 CPU 服务器配置环境中，也是常规迭代方式更有优势；而在大数据循环迭代中，如果服务器是多核 CPU 的情况下，Stream 的并行迭代优势明显。所以我们在平时处理大数据的集合时，应该尽量考虑将应用部署在多核 CPU 环境下，并且使用 Stream 的并行迭代方式进行处理。 </p>
<h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><p> HashMap 扩容优化 :</p>
<p> 在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p>
<p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</p>
<p>之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p>
<p>实际应用中，我们设置初始容量，一般得是 2 的整数次幂。你知道原因吗？ </p>
<blockquote>
<p> 1）通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；<br>2）如果 length 为 2 的次幂，则 length-1 转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 </p>
</blockquote>
<h2 id="MySQL调优之SQL语句：如何写出高性能SQL语句？"><a href="#MySQL调优之SQL语句：如何写出高性能SQL语句？" class="headerlink" title="MySQL调优之SQL语句：如何写出高性能SQL语句？"></a>MySQL调优之SQL语句：如何写出高性能SQL语句？</h2><h3 id="慢-SQL-语句的几种常见诱因"><a href="#慢-SQL-语句的几种常见诱因" class="headerlink" title="慢 SQL 语句的几种常见诱因"></a>慢 SQL 语句的几种常见诱因</h3><ul>
<li><p><strong>无索引、索引失效导致慢查询</strong> </p>
</li>
<li><p><strong>锁等待</strong> </p>
<p>我们常用的存储引擎有 InnoDB 和 MyISAM，前者支持行锁和表锁，后者只支持表锁。</p>
<p>如果数据库操作是基于表锁实现的，试想下，如果一张订单表在更新时，需要锁住整张表，那么其它大量数据库操作（包括查询）都将处于等待状态，这将严重影响到系统的并发性能。</p>
<p>这时，InnoDB 存储引擎支持的行锁更适合高并发场景。但在使用 InnoDB 存储引擎时，我们要特别注意行锁升级为表锁的可能。在批量更新操作时，行锁就很可能会升级为表锁。</p>
<p>MySQL 认为如果对一张表使用大量行锁，会导致事务执行效率下降，从而可能造成其它事务长时间锁等待和更多的锁冲突问题发生，致使性能严重下降，所以 MySQL 会将行锁升级为表锁。还有，行锁是基于索引加的锁，如果我们在更新操作时，条件索引失效，那么行锁也会升级为表锁。</p>
<p>因此，基于表锁的数据库操作，会导致 SQL 阻塞等待，从而影响执行速度。在一些更新操作（insert\update\delete）大于或等于读操作的情况下，MySQL 不建议使用 MyISAM 存储引擎。</p>
<p>除了锁升级之外，行锁相对表锁来说，虽然粒度更细，并发能力提升了，但也带来了新的问题，那就是死锁。因此，在使用行锁时，我们要注意避免死锁。关于死锁，我还会在第 35 讲中详解。 </p>
</li>
<li><p><strong>不恰当的 SQL 语句</strong> </p>
</li>
</ul>
<h3 id="优化-SQL-语句的步骤"><a href="#优化-SQL-语句的步骤" class="headerlink" title="优化 SQL 语句的步骤"></a>优化 SQL 语句的步骤</h3><p>通常，我们在执行一条 SQL 语句时，要想知道这个 SQL 先后查询了哪些表，是否使用了索引，这些数据从哪里获取到，获取到数据遍历了多少行数据等等，我们可以通过 EXPLAIN 命令来查看这些执行信息。这些执行信息被统称为<strong>执行计划</strong>。 </p>
<h4 id="通过-EXPLAIN-分析-SQL-执行计划"><a href="#通过-EXPLAIN-分析-SQL-执行计划" class="headerlink" title="通过 EXPLAIN 分析 SQL 执行计划"></a>通过 EXPLAIN 分析 SQL 执行计划</h4><p> 假设现在我们使用 EXPLAIN 命令查看当前 SQL 是否使用了索引，先通过 SQL EXPLAIN 导出相应的执行计划如下： </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/explain-sql.jpg" alt=""></p>
<ul>
<li>id：每个执行计划都有一个 id，如果是一个联合查询，这里还将有多个 id。 </li>
<li>select_type：表示 SELECT 查询类型，常见的有 SIMPLE（普通查询，即没有联合查询、子查询）、PRIMARY（主查询）、UNION（UNION 中后面的查询）、SUBQUERY（子查询）等。 </li>
<li>table：当前执行计划查询的表，如果给表起别名了，则显示别名信息。 </li>
<li>partitions：访问的分区表信息。 </li>
<li>type：表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，结果值从好到差依次是：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code>。 </li>
</ul>
<p><strong>system/const</strong>：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/system-const.jpg" alt=""></p>
<p><strong>eq_ref</strong>：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/eq-ref.jpg" alt=""></p>
<p> <strong>ref：</strong>非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/ref.jpg" alt=""></p>
<p> <strong>range</strong>：索引范围扫描，比如，<code>&lt;，&gt;，between</code>等操作。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/range.jpg" alt=""></p>
<p> <strong>index</strong>：索引全表扫描，此时遍历整个索引树。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/index.jpg" alt=""></p>
<p> <strong>ALL：</strong>表示全表扫描，需要遍历全表来找到对应的行。</p>
<p><strong>possible_keys：</strong>可能使用到的索引。</p>
<p><strong>key：</strong>实际使用到的索引。</p>
<p><strong>key_len：</strong>当前使用的索引的长度。</p>
<p><strong>ref</strong>：关联 id 等信息。</p>
<p><strong>rows</strong>：查找到记录所扫描的行数。</p>
<p><strong>filtered</strong>：查找到所需记录占总扫描记录数的比例。</p>
<p><strong>Extra</strong>：额外的信息。 </p>
<h4 id="通过-Show-Profile-分析-SQL-执行性能"><a href="#通过-Show-Profile-分析-SQL-执行性能" class="headerlink" title="通过 Show Profile 分析 SQL 执行性能"></a>通过 Show Profile 分析 SQL 执行性能</h4><p> 上述通过 EXPLAIN 分析执行计划，仅仅是停留在分析 SQL 的外部的执行情况，如果我们想要深入到 MySQL 内核中，从执行线程的状态和时间来分析的话，这个时候我们就可以选择 Profile。 </p>
<p> Profile 除了可以分析执行线程的状态和时间，还支持进一步选择 <code>ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES</code>等类型来查询 SQL 语句在不同系统资源上所消耗的时间。以下是相关命令的注释： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] ... ]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n]</span><br><span class="line">[<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>参数：</span><br><span class="line">| <span class="keyword">ALL</span>：显示所有开销信息</span><br><span class="line">| <span class="keyword">BLOCK</span> IO：阻塞的输入输出次数</span><br><span class="line">| <span class="keyword">CONTEXT</span> SWITCHES：上下文切换相关开销信息</span><br><span class="line">| CPU：显示CPU的相关开销信息 </span><br><span class="line">| IPC：接收和发送消息的相关开销信息</span><br><span class="line">| <span class="keyword">MEMORY</span> ：显示内存相关的开销，目前无用</span><br><span class="line">| PAGE FAULTS ：显示页面错误相关开销信息</span><br><span class="line">| <span class="keyword">SOURCE</span> ：列出相应操作对应的函数名及其在源码中的调用位置(行数) </span><br><span class="line">| SWAPS：显示swap交换次数的相关开销信息</span><br></pre></td></tr></table></figure>

<p> 可以通过 <code>select @@have_profiling</code> 查询是否支持profile功能 </p>
<p> Show Profiles 只显示最近发给服务器的 SQL 语句，默认情况下是记录最近已执行的 15 条记录，我们可以重新设置<code>profiling_history_size</code>增大该存储记录，最大值为 100。 </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/profile.jpg" alt=""></p>
<p>获取到 Query_ID 之后，我们再通过 <code>Show Profile for Query ID</code>语句，就能够查看到对应 Query_ID 的 SQL 语句在执行过程中线程的每个状态所消耗的时间了： </p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/show-profile.jpg" alt=""></p>
<p>通过以上分析可知：<code>SELECT COUNT(*) FROM order</code>; SQL 语句在 Sending data 状态所消耗的时间最长，这是因为在该状态下，MySQL 线程开始读取数据并返回到客户端，此时有大量磁盘 I/O 操作。 </p>
<h3 id="常用的-SQL-优化"><a href="#常用的-SQL-优化" class="headerlink" title="常用的 SQL 优化"></a>常用的 SQL 优化</h3><h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><p>通常我们是使用 + 合适的 order by 来实现分页查询，这种实现方式在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能将会非常得糟糕。如果有对应的索引，通常刚开始的分页查询效率会比较理想，但越往后，分页查询的性能就越差。</p>
<p>这是因为我们在使用 LIMIT 的时候，偏移量 M 在分页越靠后的时候，值就越大，数据库检索的数据也就越多。例如 LIMIT 10000,10 这样的查询，数据库需要查询 10010 条记录，最后返回 10 条记录。也就是说将会有 10000 条记录被查询出来没有被使用到。 </p>
<ul>
<li><p>利用子查询优化分页查询 </p>
<p> 以上分页查询的问题在于，我们查询获取的 10020 行数据结果都返回给我们了，我们能否先查询出所需要的 20 行数据中的最小 ID 值，然后通过偏移量返回所需要的 20 行数据给我们呢？我们可以通过索引覆盖扫描，使用子查询的方式来实现分页查询： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`demo`</span>.<span class="string">`order`</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt; (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="string">`demo`</span>.<span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> order_no <span class="keyword">limit</span> <span class="number">10000</span>, <span class="number">1</span>)  <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://www.enjoyican.com/img/java-performance-tuning/subquery1.jpg" alt=""></p>
<p><img src="https://www.enjoyican.com/img/java-performance-tuning/subquery2.jpg" alt=""></p>
</li>
</ul>
<h4 id="优化-SELECT-COUNT"><a href="#优化-SELECT-COUNT" class="headerlink" title="优化 SELECT COUNT(*)"></a>优化 SELECT COUNT(*)</h4><p>通常在没有任何查询条件下的 COUNT(*)，MyISAM 的查询速度要明显快于 InnoDB。这是因为 MyISAM 存储引擎记录的是整个表的行数，在 COUNT(*) 查询操作时无需遍历表计算，直接获取该值即可。而在 InnoDB 存储引擎中就需要扫描表来统计具体的行数。而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行行数的统计。 </p>
<p>如果对一张大表经常做 SELECT COUNT(*) 操作，这肯定是不明智的。那么我们该如何对大表的 COUNT() 进行优化呢？ </p>
<ul>
<li><p>使用近似值</p>
<p>有时候某些业务场景并不需要返回一个精确的 COUNT 值，此时我们可以使用近似值来代替。我们可以使用 EXPLAIN 对表进行估算，要知道，执行 EXPLAIN 并不会真正去执行查询，而是返回一个估算的近似值。</p>
</li>
<li><p>增加汇总统计</p>
<p>如果需要一个精确的 COUNT 值，我们可以额外新增一个汇总统计表或者缓存字段来统计需要的 COUNT 值，这种方式在新增和删除时有一定的成本，但却可以大大提升 COUNT() 的性能。 </p>
</li>
</ul>
<p>我们可以打开慢 SQL 配置项，记录下都有哪些 SQL 超过了预期的最大执行时间。首先，我们可以通过以下命令行查询是否开启了记录慢 SQL 的功能，以及最大的执行时间是多少： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure>

<p> 如果没有开启，我们可以通过以下设置来开启： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="string">'ON'</span>; //开启慢SQL日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=<span class="string">'/var/lib/mysql/test-slow.log'</span>;//记录日志地址</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>;//最大执行时间</span><br></pre></td></tr></table></figure>

<p>思考题：</p>
<p>假设有一张订单表 order，主要包含了主键订单编码 order_no、订单状态 status、提交时间 create_time 等列，并且创建了 status 列索引和 create_time 列索引。此时通过创建时间降序获取状态为 1 的订单编码，以下是具体实现代码： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_no <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> <span class="keyword">status</span> =<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure>

<p>你知道其中的问题所在吗？我们又该如何优化？ </p>
<blockquote>
<p>status和create_time单独建索引，在查询时只会遍历status索引对数据进行过滤，不会用到create_time列索引，将符合条件的数据返回到server层，在server对数据通过快排算法进行排序，Extra列会出现file sort；应该利用索引的有序性，在status和create_time列建立联合索引，这样根据status过滤后的数据就是按照create_time排好序的，避免在server层排序 </p>
</blockquote>
<h2 id="MySQL调优之事务：高并发场景下的数据库事务调优"><a href="#MySQL调优之事务：高并发场景下的数据库事务调优" class="headerlink" title="MySQL调优之事务：高并发场景下的数据库事务调优"></a>MySQL调优之事务：高并发场景下的数据库事务调优</h2><p>InnoDB 中的 RC 和 RR 隔离事务是基于多版本并发控制（MVCC）实现高性能事务。一旦数据被加上排他锁，其他事务将无法加入共享锁，且处于阻塞等待状态，如果一张表有大量的请求，这样的性能将是无法支持的。</p>
<p>MVCC 对普通的 Select 不加锁，如果读取的数据正在执行 Delete 或 Update 操作，这时读取操作不会等待排它锁的释放，而是直接利用 MVCC 读取该行的数据快照（数据快照是指在该行的之前版本的数据，而数据快照的版本是基于 undo 实现的，undo 是用来做事务回滚的，记录了回滚的不同版本的行记录）。MVCC 避免了对数据重复加锁的过程，大大提高了读操作的性能。 </p>
<p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。 </p>
<p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select 、Update 和 Delete 时，除了基于唯一索引的查询之外，其他索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。 </p>
<h3 id="优化高并发事务"><a href="#优化高并发事务" class="headerlink" title="优化高并发事务"></a>优化高并发事务</h3><ul>
<li>结合业务场景，使用低级别事务隔离 </li>
<li>避免行锁升级表锁 </li>
<li>控制事务的大小，减少锁定的资源量和锁定时间长度 </li>
</ul>
<h2 id="MySQL调优之索引：索引的失效与优化"><a href="#MySQL调优之索引：索引的失效与优化" class="headerlink" title="MySQL调优之索引：索引的失效与优化"></a>MySQL调优之索引：索引的失效与优化</h2><h3 id="覆盖索引优化查询"><a href="#覆盖索引优化查询" class="headerlink" title="覆盖索引优化查询"></a>覆盖索引优化查询</h3><p>假设我们只需要查询商品的名称、价格信息，我们有什么方式来避免回表呢？我们可以建立一个组合索引，即商品编码、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p>
<p> 从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得，MySQL 中将其称为覆盖索引。使用覆盖索引的好处很明显，我们不需要查询出包含整行记录的所有信息，因此可以减少大量的 I/O 操作。 </p>
<h3 id="自增字段作主键优化查询"><a href="#自增字段作主键优化查询" class="headerlink" title="自增字段作主键优化查询"></a>自增字段作主键优化查询</h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+ 树的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p>
<p>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为不需要重新移动数据，因此这种插入数据的方法效率非常高。</p>
<p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p>
<p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。  </p>
<h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p> 前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？我们知道，索引文件是存储在磁盘中的，而磁盘中最小分配单元是页，通常一个页的默认大小为 16KB，假设我们建立的索引的每个索引值大小为 2KB，则在一个页中，我们能记录 8 个索引值，假设我们有 8000 行记录，则需要 1000 个页来存储索引。如果我们使用该索引查询数据，可能需要遍历大量页，这显然会降低查询效率。减小索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。不过，前缀索引是有一定的局限性的，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。 </p>
<h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p> 在大多数情况下，我们习惯使用默认的 InnoDB 作为表存储引擎。在使用 InnoDB 作为存储引擎时，创建的索引默认为 B+ 树数据结构，如果是主键索引，则属于聚簇索引，非主键索引则属于辅助索引。基于主键查询可以直接获取到行信息，而基于辅助索引作为查询条件，则需要进行回表，然后再通过主键索引获取到数据。如果只是查询一列或少部分列的信息，我们可以基于覆盖索引来避免回表。覆盖索引只需要读取索引，且由于索引是顺序存储，对于范围或排序查询来说，可以极大地极少磁盘 I/O 操作。 </p>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    最后更新时间：<time datetime="2020-05-27T15:51:30.000Z" itemprop="dateUpdated">2020-05-27 23:51:30</time>
</span><br>


        
        每天一点成长，一点收获
        
    </div>
    
    <footer>
        <a href="https://www.enjoyican.com">
            <img src="/img/head.jpg" alt="enjoycodingfun">
            enjoycodingfun
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/note/" rel="tag">note</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.enjoyican.com/posts/java-performance-tuning/&title=《java性能调优实战学习笔记》 — Running&pic=https://www.enjoyican.com/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.enjoyican.com/posts/java-performance-tuning/&title=《java性能调优实战学习笔记》 — Running&source=这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.enjoyican.com/posts/java-performance-tuning/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java性能调优实战学习笔记》 — Running&url=https://www.enjoyican.com/posts/java-performance-tuning/&via=https://www.enjoyican.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.enjoyican.com/posts/java-performance-tuning/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between flex-row-reverse">
  

  
    <div class="waves-block waves-effect next">
      <a href="/posts/java-errorcase/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">JAVA业务开发常见错误100例学习笔记</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "ulrMiFi5yrRdTGP8FEHMehcm-gzGzoHsz",
            appKey: "JjlHLHV0knhiDfaMJgjSgdYz",
            avatar: "mm",
            placeholder: "写点什么吧(*￣︶￣)",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->










</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢关注~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/img/wechatpay.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechatpay.jpg" data-alipay="/img/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">CC BY-NC-SA 4.0</a>协议 转载请注明出处</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>enjoycodingfun &copy; 2015 - 2020</span>
            <span>
                
                <a href="http://www.beian.miit.gov.cn" target="_blank">浙ICP备20006880号-1</a><br>
                
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://www.enjoyican.com/posts/java-performance-tuning/&title=《java性能调优实战学习笔记》 — Running&pic=https://www.enjoyican.com/img/head.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://www.enjoyican.com/posts/java-performance-tuning/&title=《java性能调优实战学习笔记》 — Running&source=这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://www.enjoyican.com/posts/java-performance-tuning/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《java性能调优实战学习笔记》 — Running&url=https://www.enjoyican.com/posts/java-performance-tuning/&via=https://www.enjoyican.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://www.enjoyican.com/posts/java-performance-tuning/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACL0lEQVR42u3aS27jQAwFwNz/0s56MBPlPdJjQK3Sykgsi6UF0fx8fcXXK7j+/v71r/30+fre1YWBgXFbRhJc8vc86OtfTv77jydiYGA8gJGnxet7iwdf3tU+FwMDAyMPd5N2N68PAwMDY5ZY8ySb8DAwMDDygJLiNu+G5UXy22pxDAyMGzLyrvvnP/+X+QYGBsatGK/yShLubGywuTAwMM5m5AlufyzLeW08GBgYZzM2CXfTaMvbbdfNvjccDTEwMG7CyEeS1ykySaN54Zq8mj8SLgYGxmMYeet/P0hov1kkXAwMjOMYeTHZrly0Cb1N7hgYGE9gtKk2OcBtAkpe03DKioGBcRAjaeVvDnbJb84ixMDAeAIjadO3KTIJNx8hFOdcDAyMgxifOdK17blhLY6BgXEoo10Fy4eU+eLFJuFiYGA8gdGWkUlRmpSs7VAhWrbAwMA4lJEvQOSF7iYF18e+/MSKgYFxc8YeNjvkta291dkWAwPj5ox2DNk23dqXNcRgYGA8gDFbAtscEzclbtR0w8DAOI7Rrkq07Nn613Aei4GBcSgjX/9qF8VmpLx5h4GBcTbjVV7XabFtvbXhDs+2GBgYN2e8LWeP2nOz4cFq2ImBgXFbRptk2xWuWSlbv28MDIwHMPaLEW3Qs3B/KWUxMDAw4hWKNqBNIw8DAwMjSalt865lJw0+DAyMJzDyta22cT9r1dUraBgYGEcz2l5Wuwo2GyG0Q00MDIxDGd8hlhkGsTsCNwAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?b9131a5ca31e54205078b286dad06616";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>

<script>
  (function () {
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js'
    } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js'
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s)
  })();
</script>

    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


</script>

<script src="/js/main.min.js?v=1.7.2"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="/js/search.min.js?v=1.7.2" async></script>






<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '欢迎再来！';
            clearTimeout(titleTime);
        } else {
            document.title = '悦码小站';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
