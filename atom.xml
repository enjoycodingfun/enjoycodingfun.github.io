<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Running</title>
  <icon>https://www.gravatar.com/avatar/4d4a481fd290e237dedc9f93763f8130</icon>
  <subtitle>Better Late Than Never</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.enjoyican.com/"/>
  <updated>2020-08-21T12:19:30.000Z</updated>
  <id>https://www.enjoyican.com/</id>
  
  <author>
    <name>enjoycodingfun</name>
    <email>17364562230@163.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>shell中使用正则及脚本输入处理</title>
    <link href="https://www.enjoyican.com/posts/shell-txt/"/>
    <id>https://www.enjoyican.com/posts/shell-txt/</id>
    <published>2020-08-21T12:19:30.000Z</published>
    <updated>2020-08-21T12:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这篇博文接前面两篇介绍shell中使用正则和shell脚本输入处理，有问题及时在本文下或<a href="https://blog.csdn.net/u010408502/article/details/108238438" target="_blank" rel="noopener">CSDN</a>留言。</p><a id="more"></a><h2 id="shell中使用正则"><a href="#shell中使用正则" class="headerlink" title="shell中使用正则"></a>shell中使用正则</h2><p>关于正则表达式的基础知识，这里不展开，只说怎么用。</p><h3 id="正则表达式类型"><a href="#正则表达式类型" class="headerlink" title="正则表达式类型"></a>正则表达式类型</h3><p><strong>正则表达式包括基本正则表达式和拓展正则表达式</strong></p><p>基本表达式：</p><h3 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h3><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>句号匹配任意单个字符除了换行符。</td></tr><tr><td>[ ]</td><td>字符种类。匹配方括号内的任意字符。</td></tr><tr><td>[^ ]</td><td>否定的字符种类。匹配除了方括号里的任意字符</td></tr><tr><td>*</td><td>匹配&gt;=0个重复的在*号之前的字符。</td></tr><tr><td>+</td><td>匹配&gt;=1个重复的+号前的字符。</td></tr><tr><td>?</td><td>标记?之前的字符为可选.</td></tr><tr><td>{n,m}</td><td>匹配num个大括号之前的字符或字符集 (n &lt;= num &lt;= m).</td></tr><tr><td>(xyz)</td><td>字符集，匹配与 xyz 完全相等的字符串.</td></tr><tr><td>|</td><td>或运算符，匹配符号前或后的字符.</td></tr><tr><td>\</td><td>转义字符,用于匹配一些保留的字符 `[ ] ( ) { } . * + ? ^ $ \</td></tr><tr><td>^</td><td>从开始行开始匹配.</td></tr><tr><td>$</td><td>从末端开始匹配.</td></tr></tbody></table><h4 id="点运算符"><a href="#点运算符" class="headerlink" title="点运算符 ."></a>点运算符 <code>.</code></h4><p><code>.</code>是元字符中最简单的例子。 <code>.</code>匹配任意单个字符，但不匹配换行符。 例如，表达式<code>.ar</code>匹配一个任意字符后面跟着是<code>a</code>和<code>r</code>的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;.ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><p>字符集也叫做字符类。 方括号用来指定一个字符集。 在方括号中使用连字符来指定字符集的范围。 在方括号中的字符集不关心顺序。 例如，表达式<code>[Tt]he</code> 匹配 <code>the</code> 和 <code>The</code>。</p><figure class="highlight re"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"[Tt]he"</span> =&gt; The car parked <span class="keyword">in</span> the garage.</span><br></pre></td></tr></table></figure><p>方括号的句号就表示句号。 表达式 <code>ar[.]</code> 匹配 <code>ar.</code>字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ar[.]&quot; &#x3D;&gt; A garage is a good place to park a car.</span><br></pre></td></tr></table></figure><h4 id="否定字符集"><a href="#否定字符集" class="headerlink" title="否定字符集"></a>否定字符集</h4><p>一般来说 <code>^</code> 表示一个字符串的开头，但它用在一个方括号的开头的时候，它表示这个字符集是否定的。 例如，表达式<code>[^c]ar</code> 匹配一个后面跟着<code>ar</code>的除了<code>c</code>的任意字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[^c]ar&quot; &#x3D;&gt; The car parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="重复次数"><a href="#重复次数" class="headerlink" title="重复次数"></a>重复次数</h4><p>后面跟着元字符 <code>+</code>，<code>*</code> or <code>?</code> 的，用来指定匹配子模式的次数。 这些元字符在不同的情况下有着不同的意思。</p><h5 id="号"><a href="#号" class="headerlink" title="* 号"></a><code>*</code> 号</h5><p><code>*</code>号匹配 在<code>*</code>之前的字符出现<code>大于等于0</code>次。 例如，表达式 <code>a*</code> 匹配0或更多个以a开头的字符。表达式<code>[a-z]*</code> 匹配一个行中所有以小写字母开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[a-z]*&quot; &#x3D;&gt; The car parked in the garage #21.</span><br></pre></td></tr></table></figure><p><code>*</code>字符和<code>.</code>字符搭配可以匹配所有的字符<code>.*</code>。 <code>*</code>和表示匹配空格的符号<code>\s</code>连起来用，如表达式<code>\s*cat\s*</code>匹配0或更多个空格开头和0或更多个空格结尾的cat字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;\s*cat\s*&quot; &#x3D;&gt; The fat cat sat on the concatenation.</span><br></pre></td></tr></table></figure><h5 id="号-1"><a href="#号-1" class="headerlink" title="+ 号"></a><code>+</code> 号</h5><p><code>+</code>号匹配<code>+</code>号之前的字符出现 &gt;=1 次。 例如表达式<code>c.+t</code> 匹配以首字母<code>c</code>开头以<code>t</code>结尾，中间跟着至少一个字符的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;c.+t&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h5 id="号-2"><a href="#号-2" class="headerlink" title="? 号"></a><code>?</code> 号</h5><p>在正则表达式中元字符 <code>?</code> 标记在符号前面的字符为可选，即出现 0 或 1 次。 例如，表达式 <code>[T]?he</code> 匹配字符串 <code>he</code> 和 <code>The</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[T]?he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="号-3"><a href="#号-3" class="headerlink" title="{} 号"></a><code>{}</code> 号</h4><p>在正则表达式中 <code>{}</code> 是一个量词，常用来限定一个或一组字符可以重复出现的次数。 例如， 表达式 <code>[0-9]{2,3}</code> 匹配最少 2 位最多 3 位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,3&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><p>我们可以省略第二个参数。 例如，<code>[0-9]{2,}</code> 匹配至少两位 0~9 的数字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;2,&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><p>如果逗号也省略掉则表示重复固定的次数。 例如，<code>[0-9]{3}</code> 匹配3位数字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;[0-9]&#123;3&#125;&quot; &#x3D;&gt; The number was 9.9997 but we rounded it off to 10.0.</span><br></pre></td></tr></table></figure><h4 id="特征标群"><a href="#特征标群" class="headerlink" title="(...) 特征标群"></a><code>(...)</code> 特征标群</h4><p>特征标群是一组写在 <code>(...)</code> 中的子模式。<code>(...)</code> 中包含的内容将会被看成一个整体，和数学中小括号（ ）的作用相同。例如, 表达式 <code>(ab)*</code> 匹配连续出现 0 或更多个 <code>ab</code>。如果没有使用 <code>(...)</code> ，那么表达式 <code>ab*</code> 将匹配连续出现 0 或更多个 <code>b</code> 。再比如之前说的 <code>{}</code> 是用来表示前面一个字符出现指定次数。但如果在 <code>{}</code> 前加上特征标群 <code>(...)</code> 则表示整个标群内的字符重复 N 次。</p><p>我们还可以在 <code>()</code> 中用或字符 <code>|</code> 表示或。例如，<code>(c|g|p)ar</code> 匹配 <code>car</code> 或 <code>gar</code> 或 <code>par</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(c|g|p)ar&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="或运算符"><a href="#或运算符" class="headerlink" title="| 或运算符"></a><code>|</code> 或运算符</h4><p>或运算符就表示或，用作判断条件。</p><p>例如 <code>(T|t)he|car</code> 匹配 <code>(T|t)he</code> 或 <code>car</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he|car&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h4 id="转码特殊字符"><a href="#转码特殊字符" class="headerlink" title="转码特殊字符"></a>转码特殊字符</h4><p>反斜线 <code>\</code> 在表达式中用于转码紧跟其后的字符。用于指定 <code>{ } [ ] / \ + * . $ ^ | ?</code> 这些特殊字符。如果想要匹配这些特殊字符则要在其前面加上反斜线 <code>\</code>。</p><p>例如 <code>.</code> 是用来匹配除换行符外的所有字符的。如果想要匹配句子中的 <code>.</code> 则要写成 <code>\.</code> 以下这个例子 <code>\.?</code>是选择性匹配<code>.</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(f|c|m)at\.?&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="锚点"><a href="#锚点" class="headerlink" title="锚点"></a>锚点</h4><p>在正则表达式中，想要匹配指定开头或结尾的字符串就要使用到锚点。<code>^</code> 指定开头，<code>$</code> 指定结尾。</p><h5 id="号-4"><a href="#号-4" class="headerlink" title="^ 号"></a><code>^</code> 号</h5><p><code>^</code> 用来检查匹配的字符串是否在所匹配字符串的开头。</p><p>例如，在 <code>abc</code> 中使用表达式 <code>^a</code> 会得到结果 <code>a</code>。但如果使用 <code>^b</code> 将匹配不到任何结果。因为在字符串 <code>abc</code> 中并不是以 <code>b</code> 开头。</p><p>例如，<code>^(T|t)he</code> 匹配以 <code>The</code> 或 <code>the</code> 开头的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;^(T|t)he&quot; &#x3D;&gt; The car is parked in the garage.</span><br></pre></td></tr></table></figure><h5 id="号-5"><a href="#号-5" class="headerlink" title="$ 号"></a><code>$</code> 号</h5><p>同理于 <code>^</code> 号，<code>$</code> 号用来匹配字符是否是最后一个。</p><p>例如，<code>(at\.)$</code> 匹配以 <code>at.</code> 结尾的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(at\.)&quot; &#x3D;&gt; The fat cat. sat. on the mat.</span><br></pre></td></tr></table></figure><h3 id="简写字符集"><a href="#简写字符集" class="headerlink" title="简写字符集"></a>简写字符集</h3><table><thead><tr><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>.</td><td>除换行符外的所有字符</td></tr><tr><td>\w</td><td>匹配所有字母数字，等同于 <code>[a-zA-Z0-9_]</code></td></tr><tr><td>\W</td><td>匹配所有非字母数字，即符号，等同于： <code>[^\w]</code></td></tr><tr><td>\d</td><td>匹配数字： <code>[0-9]</code></td></tr><tr><td>\D</td><td>匹配非数字： <code>[^\d]</code></td></tr><tr><td>\s</td><td>匹配所有空格字符，等同于： <code>[\t\n\f\r\p{Z}]</code></td></tr><tr><td>\S</td><td>匹配所有非空格字符： <code>[^\s]</code></td></tr><tr><td>\f</td><td>匹配一个换页符</td></tr><tr><td>\n</td><td>匹配一个换行符</td></tr><tr><td>\r</td><td>匹配一个回车符</td></tr><tr><td>\t</td><td>匹配一个制表符</td></tr><tr><td>\v</td><td>匹配一个垂直制表符</td></tr><tr><td>\p</td><td>匹配 CR/LF（等同于 <code>\r\n</code>），用来匹配 DOS 行终止符</td></tr></tbody></table><h3 id="零宽度断言（前后预查）"><a href="#零宽度断言（前后预查）" class="headerlink" title="零宽度断言（前后预查）"></a>零宽度断言（前后预查）</h3><p>先行断言和后发断言都属于<strong>非捕获簇</strong>（不捕获文本 ，也不针对组合计进行计数）。 先行断言用于判断所匹配的格式是否在另一个确定的格式之前，匹配结果不包含该确定格式（仅作为约束）。</p><p>例如，我们想要获得所有跟在 <code>$</code> 符号后的数字，我们可以使用正后发断言 <code>(?&lt;=\$)[0-9\.]*</code>。 这个表达式匹配 <code>$</code> 开头，之后跟着 <code>0,1,2,3,4,5,6,7,8,9,.</code> 这些字符可以出现大于等于 0 次。</p><p>零宽度断言如下：</p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>?=</td><td>正先行断言-存在</td></tr><tr><td>?!</td><td>负先行断言-排除</td></tr><tr><td>?&lt;=</td><td>正后发断言-存在</td></tr><tr><td>?&lt;!</td><td>负后发断言-排除</td></tr></tbody></table><h4 id="正先行断言"><a href="#正先行断言" class="headerlink" title="?=... 正先行断言"></a><code>?=...</code> 正先行断言</h4><p><code>?=...</code> 正先行断言，表示第一部分表达式之后必须跟着 <code>?=...</code>定义的表达式。</p><p>返回结果只包含满足匹配条件的第一部分表达式。 定义一个正先行断言要使用 <code>()</code>。在括号内部使用一个问号和等号： <code>(?=...)</code>。</p><p>正先行断言的内容写在括号中的等号后面。 例如，表达式 <code>(T|t)he(?=\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，在括号中我们又定义了正先行断言 <code>(?=\sfat)</code> ，即 <code>The</code> 和 <code>the</code> 后面紧跟着 <code>(空格)fat</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?&#x3D;\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="负先行断言"><a href="#负先行断言" class="headerlink" title="?!... 负先行断言"></a><code>?!...</code> 负先行断言</h4><p>负先行断言 <code>?!</code> 用于筛选所有匹配结果，筛选条件为 其后不跟随着断言中定义的格式。 <code>正先行断言</code> 定义和 <code>负先行断言</code> 一样，区别就是 <code>=</code> 替换成 <code>!</code> 也就是 <code>(?!...)</code>。</p><p>表达式 <code>(T|t)he(?!\sfat)</code> 匹配 <code>The</code> 和 <code>the</code>，且其后不跟着 <code>(空格)fat</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(T|t)he(?!\sfat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="lt-正后发断言"><a href="#lt-正后发断言" class="headerlink" title="?&lt;= ... 正后发断言"></a><code>?&lt;= ...</code> 正后发断言</h4><p>正后发断言 记作<code>(?&lt;=...)</code> 用于筛选所有匹配结果，筛选条件为 其前跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code> 匹配 <code>fat</code> 和 <code>mat</code>，且其前跟着 <code>The</code> 或 <code>the</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;(?&lt;&#x3D;(T|t)he\s)(fat|mat)&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="lt-负后发断言"><a href="#lt-负后发断言" class="headerlink" title="?&lt;!... 负后发断言"></a><code>?&lt;!...</code> 负后发断言</h4><p>负后发断言 记作 <code>(?&lt;!...)</code> 用于筛选所有匹配结果，筛选条件为 其前不跟随着断言中定义的格式。 例如，表达式 <code>(?&lt;!(T|t)he\s)(cat)</code> 匹配 <code>cat</code>，且其前不跟着 <code>The</code> 或 <code>the</code>。</p><h3 id="标志"><a href="#标志" class="headerlink" title="标志"></a>标志</h3><p>标志也叫模式修正符，因为它可以用来修改表达式的搜索结果。 这些标志可以任意的组合使用，它也是整个正则表达式的一部分。</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>忽略大小写。</td></tr><tr><td>g</td><td>全局搜索。</td></tr><tr><td>m</td><td>多行修饰符：锚点元字符 <code>^</code> <code>$</code> 工作范围在每行的起始。</td></tr></tbody></table><h4 id="忽略大小写-Case-Insensitive"><a href="#忽略大小写-Case-Insensitive" class="headerlink" title="忽略大小写 (Case Insensitive)"></a>忽略大小写 (Case Insensitive)</h4><p>修饰语 <code>i</code> 用于忽略大小写。 例如，表达式 <code>/The/gi</code> 表示在全局搜索 <code>The</code>，在后面的 <code>i</code> 将其条件修改为忽略大小写，则变成搜索 <code>the</code> 和 <code>The</code>，<code>g</code> 表示全局搜索。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;The&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;The&#x2F;gi&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="全局搜索-Global-search"><a href="#全局搜索-Global-search" class="headerlink" title="全局搜索 (Global search)"></a>全局搜索 (Global search)</h4><p>修饰符 <code>g</code> 常用于执行一个全局搜索匹配，即（不仅仅返回第一个匹配的，而是返回全部）。 例如，表达式 <code>/.(at)/g</code> 表示搜索 任意字符（除了换行）+ <code>at</code>，并返回全部结果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;.(at)&#x2F;&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;.(at)&#x2F;g&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><h4 id="多行修饰符-Multiline"><a href="#多行修饰符-Multiline" class="headerlink" title="多行修饰符 (Multiline)"></a>多行修饰符 (Multiline)</h4><p>多行修饰符 <code>m</code> 常用于执行一个多行匹配。</p><p>像之前介绍的 <code>(^,$)</code> 用于检查格式是否是在待检测字符串的开头或结尾。但我们如果想要它在每行的开头和结尾生效，我们需要用到多行修饰符 <code>m</code>。</p><p>例如，表达式 <code>/at(.)?$/gm</code> 表示小写字符 <code>a</code> 后跟小写字符 <code>t</code> ，末尾可选除换行符外任意字符。根据 <code>m</code> 修饰符，现在表达式匹配每行的结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;.at(.)?$&#x2F;&quot; &#x3D;&gt; The fat</span><br><span class="line">                cat sat</span><br><span class="line">                on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;.at(.)?$&#x2F;gm&quot; &#x3D;&gt; The fat</span><br><span class="line">                  cat sat</span><br><span class="line">                  on the mat.</span><br></pre></td></tr></table></figure><h3 id="贪婪匹配与惰性匹配-Greedy-vs-lazy-matching"><a href="#贪婪匹配与惰性匹配-Greedy-vs-lazy-matching" class="headerlink" title="贪婪匹配与惰性匹配 (Greedy vs lazy matching)"></a>贪婪匹配与惰性匹配 (Greedy vs lazy matching)</h3><p>正则表达式默认采用贪婪匹配模式，在该模式下意味着会匹配尽可能长的子串。我们可以使用 <code>?</code> 将贪婪匹配模式转化为惰性匹配模式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;(.*at)&#x2F;&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&#x2F;(.*?at)&#x2F;&quot; &#x3D;&gt; The fat cat sat on the mat.</span><br></pre></td></tr></table></figure><blockquote><p>以上正则基础知识内容来源于<a href="https://github.com/ziishaned/learn-regex/blob/master/translations/README-cn.md" target="_blank" rel="noopener">learn-regex</a></p></blockquote><p>下面介绍下POSIX字符类：</p><h3 id="POSIX字符类"><a href="#POSIX字符类" class="headerlink" title="POSIX字符类"></a>POSIX字符类</h3><blockquote><p>[:alnum:]：匹配字面和数字字符。等同于A<del>Z,a</del>z,0~9</p><p>[:alpha:]：匹配字母字符。等同于A<del>Z，a</del>z</p><p>[:blank:]：匹配空格或制表符</p><p>[:cntrl:]：匹配控制字符<br>[:digit:]：匹配十进制数字。等同于0~9</p><p>[:graph:]：匹配ASCII码值范围33~126的字符。与[:print:]相似，但不包括空格字符</p><p>[:print:]：与[:graph:]相同，但多了空格字符</p><p>[:lower:]：匹配小写字母，等同于a~z</p><p>[:upper:]：匹配大写字母，等同于A~Z</p><p>[:space:]：匹配空白字符（空格和制表符）</p><p>[:xdigit:]：匹配十六进制数字。等同于0<del>9，A</del>F，a~f</p></blockquote><p><strong>POSIX字符类通常需要引用或双方括号（[[]]）括起来</strong></p><h3 id="bash正则"><a href="#bash正则" class="headerlink" title="bash正则"></a>bash正则</h3><p>bash中使用”=~”表示正则表达式比较操作符，正则表达式匹配成功，返回状态码0，匹配失败，返回状态码1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取用户从键盘的输入，存入变量num</span></span><br><span class="line"><span class="built_in">read</span><span class="params"> -p</span> <span class="string">"please input a number,please: "</span> num</span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$num</span> =~ ^[0-9]+$ ]];</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"输入正确"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"输入有误，请重新输入"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#执行正则</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh</span></span><br><span class="line">please input a number,please: 3</span><br><span class="line">输入正确</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh</span></span><br><span class="line">please input a number,please: v</span><br><span class="line">输入有误，请重新输入</span><br></pre></td></tr></table></figure><p>在bash中使用正则匹配的语法为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">"regex"</span> 文件</span><br></pre></td></tr></table></figure><h2 id="脚本输入处理"><a href="#脚本输入处理" class="headerlink" title="脚本输入处理"></a>脚本输入处理</h2><h3 id="参数处理"><a href="#参数处理" class="headerlink" title="参数处理"></a>参数处理</h3><h4 id="输入参数大小写不敏感"><a href="#输入参数大小写不敏感" class="headerlink" title="输入参数大小写不敏感"></a>输入参数大小写不敏感</h4><p>之前博文中已经讲过给函数传递参数的知识点，给脚本传递参数也是类似的，当我们执行脚本的时候也可以通过位置参数传递参数，内部通过case或”[[“条件命令，来确定shell执行路径，但是shell对于参数默认是大小写敏感的，如果我们想使脚本大小写不敏感，可以在脚本首行中加入<code>shopt -s nocasematch</code>来<code>开启</code>nocasematch选项，在末尾加入<code>shopt -u nocasematch</code>来<code>关闭</code>nocasematch选项,也可以通过正则匹配大小写来实现，不过这种不是很方便</p><h4 id="使用shift命令处理命令行参数"><a href="#使用shift命令处理命令行参数" class="headerlink" title="使用shift命令处理命令行参数"></a>使用shift命令处理命令行参数</h4><p>当脚本只有一个命令行参数时，内部用case来分不同情况很方便，但是当脚本有多个参数时，使用case就不方便了，这时候可以使用<code>shift</code>命令在一个变量中一个接一个的获取多个命令行参数，语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">shift</span> [n]</span><br></pre></td></tr></table></figure><p>n必须是一个小于或等于”$#”（参数个数）的非负整数。n为0或者大于”$#”,位置参数都不会改变，如果不指定n，默认设为1，如果n大于”$#”或小于0，此命令返回状态码将大于0，否则为0.</p><p>当我们使用shift 1 命令时，位置参数将移动一位，原来$2位置参数赋值给$1,以此类推，原来的变量$1的值将被废弃。同理，如果我们使用shift 5，位置参数原来$6的参数值赋值给$1,$7的值赋值给$2，以此类推，原来的变量$1-$5的值将被废弃。</p><p>在每次移动之后，特殊变量$#（位置参数个数）的值也会调整，而特殊变量$0（当前运行脚本名称）不参与移位操作。如果我们读取$1的值，然后运行命令<code>shift</code>,再次读取特殊变量$1的值，将得到$2的值，然后再次运行命令shift，再次读取特殊变量$1的值，将得到$3的值，依次类推。因此，只要$#的值不为0，就可以在while循环中进行迭代，获取特殊变量$1的值，运行shift命令，然后再次读取$1的值，来依次获取所有传递的命令行参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建test.sh文件如下：</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span><span class="params"> -ne</span> 0 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前打印参数：<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh one two three</span></span><br><span class="line">当前打印参数：one</span><br><span class="line">当前打印参数：two</span><br><span class="line">当前打印参数：three</span><br></pre></td></tr></table></figure><p>有时候我们传入的参数个数和shift后面的n不是整除关系，比如传入的参数个数是7个，n是5，当第一次随时用shift5时，会将$6的值给到$1，但是第二次执行时，由于只剩下两个元素，$#的值变为2，第二次移位不会再发生，while循环将无限进行下去。</p><p>为了解决以上问题，我们可以判断每次执行shift命令的结果，如果正确执行了，就继续，没有执行就退出循环，通过特殊变量$?判断命令返回码是否为0，为0说明正确执行，否则没有正确执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span><span class="params"> -ne</span> 0 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前打印参数：<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">shift</span> 2</span><br><span class="line"><span class="keyword">if</span> [ $?<span class="params"> -ne</span> 0 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="使用for循环读取多个参数"><a href="#使用for循环读取多个参数" class="headerlink" title="使用for循环读取多个参数"></a>使用for循环读取多个参数</h4><p>当命令行参数比较多的时候，使用$1,$2一个一个参数获取，编程就不是很方便了，这个时候可以通过for循环，配合$*及$@来列出传递给脚本的所有命令行参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ !<span class="params"> -n</span> <span class="string">"<span class="variable">$1</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"参数为空，退出脚本"</span></span><br><span class="line">  <span class="built_in">exit</span> 1;</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">index=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"通过\$*遍历元素"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前打印参数为：#<span class="variable">$index</span> = <span class="variable">$arg</span>"</span></span><br><span class="line">  <span class="comment">#将变量index的值加1</span></span><br><span class="line">  <span class="built_in">let</span> index+=1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将变量index的值重新置为1</span></span><br><span class="line">index=1</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"通过\"\$@\"遍历元素"</span></span><br><span class="line"><span class="keyword">for</span> arg <span class="keyword">in</span> <span class="string">"<span class="variable">$@</span>"</span>; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前打印参数为：#<span class="variable">$index</span> = <span class="variable">$arg</span>"</span></span><br><span class="line">  <span class="comment">#将变量index的值加1</span></span><br><span class="line">  <span class="built_in">let</span> index+=1</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh one two three four five six</span></span><br><span class="line">通过$*遍历元素</span><br><span class="line">当前打印参数为：<span class="comment">#1 = one</span></span><br><span class="line">当前打印参数为：<span class="comment">#2 = two</span></span><br><span class="line">当前打印参数为：<span class="comment">#3 = three</span></span><br><span class="line">当前打印参数为：<span class="comment">#4 = four</span></span><br><span class="line">当前打印参数为：<span class="comment">#5 = five</span></span><br><span class="line">当前打印参数为：<span class="comment">#6 = six</span></span><br><span class="line">通过<span class="string">"<span class="variable">$@</span>"</span>遍历元素</span><br><span class="line">当前打印参数为：<span class="comment">#1 = one</span></span><br><span class="line">当前打印参数为：<span class="comment">#2 = two</span></span><br><span class="line">当前打印参数为：<span class="comment">#3 = three</span></span><br><span class="line">当前打印参数为：<span class="comment">#4 = four</span></span><br><span class="line">当前打印参数为：<span class="comment">#5 = five</span></span><br><span class="line">当前打印参数为：<span class="comment">#6 = six</span></span><br></pre></td></tr></table></figure><p>上面脚本中，引用$*没有加双引号，是因为如果加了双引号,其值将被扩展为包含所有位置参数的值的单个字符串，这样for循环只能进行一次，参考<a href="https://www.enjoyican.com/posts/shell-grammar/#特殊参数">特殊参数</a></p><h4 id="读取脚本名称"><a href="#读取脚本名称" class="headerlink" title="读取脚本名称"></a>读取脚本名称</h4><p>在shell脚本中，特殊变量$0是脚本的名称，在脚本中我们运行一段脚本之前可以将脚本名输出，当脚本输入参数有误时，也可以将脚本名及使用方法打印出来，总之，读取脚本名有其特定的应用场合。</p><h3 id="选项处理"><a href="#选项处理" class="headerlink" title="选项处理"></a>选项处理</h3><p>我们在执行脚本时候，如果有多个参数，有时候我们脚本的要求不仅要参数个数正确，还需要参数顺序正确。为此，我们通过处理，使shell脚本的执行命令可以通过选项指定参数顺序和类型。比如一个脚本需要三个参数，一个配置文件，一个输入文件，一个输出文件，我们可以通过-c选项指定配置文件，通过-in指定输入文件，通过-out指定输出文件，那么执行脚本时候就可以</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx.sh<span class="params"> -c</span> my.cof<span class="params"> -in</span> input.txt<span class="params"> -out</span> out.txt</span><br></pre></td></tr></table></figure><p>下面介绍如何在shell脚本中实现命令行选项的处理</p><h4 id="使用case语句处理命令行选项"><a href="#使用case语句处理命令行选项" class="headerlink" title="使用case语句处理命令行选项"></a>使用case语句处理命令行选项</h4><p>当参数只有一个的时候，使用case来处理选项是很方便的，比如一个脚本copy.sh执行时一次只能有一个参数，当使用-c时，拷贝指定的文件，当时用-m时移动指定的文件，那么我们的命令行参数有两个，一个是选项(-c /-m)，另一个是文件名，在脚本中我们就可以通过对第一个参数进行验证，来执行不同的指令，此处不再举例。</p><h4 id="使用getopts处理多命令行选项"><a href="#使用getopts处理多命令行选项" class="headerlink" title="使用getopts处理多命令行选项"></a>使用getopts处理多命令行选项</h4><p><strong>注意</strong>：<code>getopts</code>不能解析GNU风格的长选项（–myoption）或XF86风格的长选项（-myoptions）</p><p>假设有如下脚本，调用此脚本时指定如下选项参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>.sh<span class="params"> -x</span><span class="params"> -f</span> /etc/<span class="built_in">test</span>.conf<span class="params"> -r</span> ./<span class="built_in">source</span>.txt ./destination.txt</span><br></pre></td></tr></table></figure><p>上述选项参数可以划分为如下逻辑组：</p><p>-x,-r都是一个单独的选项，后面不跟参数</p><p>-f也是一个选项，且选项后跟一个参数/etc/test.conf，并且参数与选项之间用空格隔开</p><p>./source.txt ./destination.txt是不与任何选项关联的两个参数</p><p>当我们在test.sh脚本中使用getopts来处理命令行选项和参数，上面的命令还可以写成</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span>.sh<span class="params"> -xrf</span> /etc/<span class="built_in">test</span>.conf ./<span class="built_in">source</span>.txt ./destination.txt</span><br></pre></td></tr></table></figure><p><code>getopts</code>可以识别所有这些选项格式，<strong>指定的选项可以是大写或者小写字母，或者数字</strong>，其他字符也能识别，但是不推荐使用。在处理命令行选项和参数时，需要多次调用getopts，且该命令本身不会更改位置参数的设置，要想将位置参数移位，必须使用shift命令来处理位置参数。</p><p>当没有内容可以解析时，getopts会设置一个退出状态FALSE，所以在循环中可以很容易使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> ...; <span class="keyword">do</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>getopts将会解析选项和它们可能的参数，它将在第一个非选项参数（不以连字符”-“开头的，且不是它前面的任何选项的参数的字符串）的位置停止解析。当遇到双连字符”–”(表示选项的结束)时，也将停止解析。</p><p>getopts会使用到以下3个变量</p><p><code>OPTIND</code> : 存放下一个要处理的参数的索引，这是getopts在调用过程中记住自己状态的方式，同样可以用于移位使用getopts处理后的位置参数。OPTIND初始被设为1，想再次使用getopts解析任何内容，需要将其重置为1.</p><p><code>OPTARG</code> : 这个变量被设置为由getopts找到的选项所对应的参数。</p><p><code>OPTERR</code> : 值为0或1，指示bash是否应该显示由getopts产生的错误信息。在每个shell启动时，它的值被初始化为1，如果不想看到相关信息，请确保设置为0</p><blockquote><p>getopts命令的基本语法是：getopts OPTSTRING VARNAME ARGS…</p></blockquote><p><code>OPTSTRING</code> :告诉getopts会有哪些选项和在哪会有参数（用选项后加冒号”:”表示）</p><p><code>VANAME</code> : 告诉getopts哪个变量用于选项</p><p><code>ARGS</code> : 告诉getopts解析这些可选的参数，而不是位置参数</p><p>比如下面的命令告诉getopts查找-f、-A和-x</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> fAx VARNAME</span><br></pre></td></tr></table></figure><p>下面的命令告诉getopts命令，-A选项后面会有一个参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getopts</span> fA:x VARNAME</span><br></pre></td></tr></table></figure><p>默认情况下，getopts命令是解析当前shell或者函数的位置参数，也可以指定自己的参数让getopts来解析。</p><p>getopts支持两种错误报告模式，详细模式和抑制错误报告模式。</p><p>详细模式下，如果getopts遇到无效选项或者需要的参数没找到，VARNAME值会被设置为问号(?),并且变量OPTARG不会被设置；</p><p>抑制错误报告模式下：如果遇到无效选项，VARNAME值会被设置为问号(?)，并且OPTARG会被设置为选项字符；如果需要的参数没有找到，VARNAME值会被设置为冒号(:)，并且变量OPTARG中会包含选项字符。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#test</span>.sh</span><br><span class="line"><span class="comment">#使用getopts解析命令行选项，这里仅解析-a选项，选项字符串中第一个字符为冒号(:)</span></span><br><span class="line"><span class="comment">#表示抑制错误报告</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> <span class="string">":a"</span> opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">  a)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"选项参数-a 已获取"</span></span><br><span class="line">    ;;</span><br><span class="line">  <span class="comment">#匹配其他选项</span></span><br><span class="line">  \?)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"无效的参数选项： -<span class="variable">$&#123;OPTARG&#125;</span>"</span></span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下面执行脚本</span></span><br><span class="line"><span class="comment">#下面这个getopts没有看到任何有效或无效的选项，所以没有被触发</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh</span></span><br><span class="line"><span class="comment">#下面这个运行脚本时指定的是一个命令行参数而不是选项，所以没有任何输出</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh /usr</span></span><br><span class="line"><span class="keyword">#getopts</span>被触发了，并且将?放到了变量opt中，将无效选项字符b放入变量OPTARG中</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -b</span></span><br><span class="line">无效的参数选项：<span class="params"> -b</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -a</span></span><br><span class="line">选项参数-a 已获取</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -a -a -a -a</span></span><br><span class="line">选项参数-a 已获取</span><br><span class="line">选项参数-a 已获取</span><br><span class="line">选项参数-a 已获取</span><br><span class="line">选项参数-a 已获取</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -a -b -c -d</span></span><br><span class="line">选项参数-a 已获取</span><br><span class="line">无效的参数选项：<span class="params"> -b</span></span><br><span class="line">无效的参数选项：<span class="params"> -c</span></span><br><span class="line">无效的参数选项：<span class="params"> -d</span></span><br></pre></td></tr></table></figure><p>从上面脚本执行情况可以看出，无效的选项不会停止处理：如果我们希望遇到无效选项就开始停止处理，必须做一些完善操作（在正确的位置执行退出操作）；多个相同的选项是可能的，如果想禁止重复的选项，必须在脚本中做一些检查操作。</p><p>下面是一个接受多参数的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量vflag</span></span><br><span class="line">vflag=off</span><br><span class="line"><span class="comment">#定义变量filename</span></span><br><span class="line">filename=<span class="string">""</span></span><br><span class="line"><span class="comment">#定义变量output</span></span><br><span class="line">output=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数usage</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前脚本用法如下"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"./test.sh [-h] [-v] [-f &lt;filename&gt;] [-o &lt;filename&gt;]"</span></span><br><span class="line">  <span class="built_in">exit</span><span class="params"> -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#在while循环中使用getopts解析命令行选项-h、-v、-f和-o，其中-f和-o选项带有参数</span></span><br><span class="line"><span class="comment">#字符串选项中第一个冒号表示getopts使用抑制错误报告模式</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">getopts</span> :hvf:o: opt</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$opt</span> <span class="keyword">in</span></span><br><span class="line">  v)</span><br><span class="line">    vflag=on</span><br><span class="line">    ;;</span><br><span class="line">  f)</span><br><span class="line">    <span class="comment">#将-f选项的参数赋值给filename</span></span><br><span class="line">    filename=<span class="variable">$OPTARG</span></span><br><span class="line">    <span class="comment">#如果文件不存在，则显示提示信息，并退出脚本的执行</span></span><br><span class="line">    <span class="keyword">if</span> [ !<span class="params"> -f</span> <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"输入的参数<span class="variable">$filename</span>不存在"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">  o)</span><br><span class="line">    <span class="comment">#将-o选项的参数赋值给output</span></span><br><span class="line">    output=<span class="variable">$OPTARG</span></span><br><span class="line">    <span class="comment">#如果指定的输出文件的目录不存在，则显示提示信息，并退出</span></span><br><span class="line">    <span class="keyword">if</span> [ !<span class="params"> -d</span> <span class="variable">$output</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"输出文件的目录 <span class="variable">$output</span> 不存在"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line">  h)</span><br><span class="line">    <span class="comment">#显示脚本使用信息</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">    ;;</span><br><span class="line">  :)</span><br><span class="line">    <span class="comment">#如果没有为需要参数的选项指定参数，则显示提示信息，并退出脚本的运行</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"选项 -<span class="variable">$OPTARG</span> 需要一个参数"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line">  \?)</span><br><span class="line">    <span class="comment">#如果指定的选项为无效选项，则显示提示信息，及脚本的使用方法信息，并退出脚本的运行</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"无效的选项 -<span class="variable">$OPTARG</span>"</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本如下</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -h</span></span><br><span class="line">当前脚本用法如下</span><br><span class="line">./<span class="built_in">test</span>.sh [-h] [-v] [-f &lt;filename&gt;] [-o &lt;filename&gt;]</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vf</span></span><br><span class="line">选项<span class="params"> -f</span> 需要一个参数</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vf /tmp/no</span></span><br><span class="line">输入的参数/tmp/no不存在</span><br></pre></td></tr></table></figure><h4 id="使用getopt处理多命令行选项"><a href="#使用getopt处理多命令行选项" class="headerlink" title="使用getopt处理多命令行选项"></a>使用getopt处理多命令行选项</h4><p><code>getopt</code>命令与<code>getopts</code>命令功能相似，也是用于解析命令行的选项和参数，不同的是<code>getopt</code>是linux下的命令行工具，并且支持命令行的长选项（–）另外，在脚本中调用方式也不同</p><p>使用getopt语法如下：</p><blockquote><p>getopt options – optstring parameters</p><p>getopt options -o|–options optstring options – parameters</p></blockquote><p>下面是一个getopt的例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getopt f:vl<span class="params"> -vl</span><span class="params"> -f</span>/<span class="built_in">local</span>/filename.conf param</span><br></pre></td></tr></table></figure><p>上例中，f:vl对应getopt语法中的optstring（选项字符串），”-vl -f/local/filename.conf param”对应语法中的parameters（命令的参数），因此getopt会按照optstring的设置，将paramteers解析为相应的选项和参数</p><p>所以上例子中，-vl被解析为-v和-l，f后面有一个冒号(:)所以-f/local/filename.conf被解析为”-f  /local/filename.conf”,然后解析后的命令行选项和参数之间使用双连字符（–）分隔</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-v<span class="params"> -l</span><span class="params"> -f</span> /<span class="built_in">local</span>/filename.conf<span class="params"> --param</span></span><br></pre></td></tr></table></figure><p>下面看一个shell脚本解析的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将getopt命令解析后的内容设置到位置参数</span></span><br><span class="line"><span class="built_in">set</span> -- `getopt f:vl <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"><span class="comment">#如果位置参数个数大于0就执行while循环</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span><span class="params"> -gt</span> 0 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$1</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vl  -f/tmp/no testparam</span></span><br><span class="line">-v</span><br><span class="line">-l</span><br><span class="line">-f</span><br><span class="line">/tmp/no</span><br><span class="line">--</span><br><span class="line">testparam</span><br></pre></td></tr></table></figure><p>这是一个简单的通过位置参数循环解析命令行参数的例子，下面示例使用getopt来解析，下面脚本改编自上面getopts的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量vflag</span></span><br><span class="line">vflag=off</span><br><span class="line"><span class="comment">#定义变量filename</span></span><br><span class="line">filename=<span class="string">""</span></span><br><span class="line"><span class="comment">#定义变量output</span></span><br><span class="line">output=<span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用getopt命令处理后的命令行选项和参数重新设置位置参数</span></span><br><span class="line"><span class="built_in">set</span> -- `getopt hvf:o: <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义函数usage</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">usage</span></span>() &#123;</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前脚本用法如下"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"./test.sh [-h] [-v] [-f &lt;filename&gt;] [-o &lt;filename&gt;]"</span></span><br><span class="line">  <span class="built_in">exit</span><span class="params"> -1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#如果位置参数的个数大于0就执行while循环</span></span><br><span class="line"><span class="keyword">while</span> [ <span class="variable">$#</span><span class="params"> -gt</span> 0 ]</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$1</span> <span class="keyword">in</span></span><br><span class="line"><span class="params">  -v</span>)</span><br><span class="line">    vflag=on</span><br><span class="line">    ;;</span><br><span class="line"><span class="params">  -f</span>)</span><br><span class="line">    <span class="comment">#将-f选项的参数赋值给filename</span></span><br><span class="line">    filename=<span class="variable">$2</span></span><br><span class="line">    <span class="comment">#如果文件不存在，则显示提示信息，并退出脚本的执行,否则将位置参数左移，移动到-f选项的参数的位置</span></span><br><span class="line">    <span class="keyword">if</span> [ !<span class="params"> -f</span> <span class="variable">$filename</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"输入的参数<span class="variable">$filename</span>不存在"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="params">  -o</span>)</span><br><span class="line">    <span class="comment">#将-o选项的参数赋值给output</span></span><br><span class="line">    output=<span class="variable">$2</span></span><br><span class="line">    <span class="comment">#如果指定的输出文件的目录不存在，则显示提示信息，并退出，否则将位置参数左移，移动到-o选项的参数的位置</span></span><br><span class="line">    <span class="keyword">if</span> [ !<span class="params"> -d</span> <span class="variable">$output</span> ]; <span class="keyword">then</span></span><br><span class="line">        <span class="built_in">echo</span> <span class="string">"输出文件的目录 <span class="variable">$output</span> 不存在"</span></span><br><span class="line">        <span class="built_in">exit</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">shift</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    ;;</span><br><span class="line"><span class="params">  -h</span>)</span><br><span class="line">    <span class="comment">#显示脚本使用信息</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line">    ;;</span><br><span class="line">  --)</span><br><span class="line">    <span class="comment">#如果是双连字符，则跳过，并退出while循环</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">    ;;</span><br><span class="line">  -*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"无效的选项 <span class="variable">$1</span>"</span></span><br><span class="line">    usage</span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#执行脚本结果如下</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -h</span></span><br><span class="line">当前脚本用法如下</span><br><span class="line">./<span class="built_in">test</span>.sh [-h] [-v] [-f &lt;filename&gt;] [-o &lt;filename&gt;]</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vf</span></span><br><span class="line">getopt: option requires an argument -- <span class="string">'f'</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vf /etc/passwd -o</span></span><br><span class="line">getopt: option requires an argument -- <span class="string">'o'</span></span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -vf /etc/passwd -o /temp/no</span></span><br><span class="line">输出文件的目录 /temp/no 不存在</span><br></pre></td></tr></table></figure><p>getopt还有一个功能是支持长选项（–long-options）,下面通过一个例子来看下如何解析：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量param2</span></span><br><span class="line">param2=0</span><br><span class="line"><span class="comment">#使用getopt命令处理脚本的命令行选项和参数，再讲处理后的结果重新赋值给位置参数</span></span><br><span class="line"><span class="keyword">#eval</span>命令用于将其后的内容作为单个命令读取和执行，这里用于处理getopt命令生成的参数的转义字符</span><br><span class="line"><span class="built_in">eval</span> <span class="built_in">set</span> -- `getopt<span class="params"> -o</span> a::bc:<span class="params"> --long</span> arga::,argb,argc:<span class="params"> -n</span> <span class="string">'test.sh'</span> -- <span class="string">"<span class="variable">$@</span>"</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行while循环</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span></span><br><span class="line"><span class="params">    -a</span>|--arga)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></span><br><span class="line">      <span class="string">""</span>)</span><br><span class="line">        <span class="comment">#当没有给具有可选参数的选项-a(或--arga)指定参数时，使用默认赋值给变量param1</span></span><br><span class="line">        param1=<span class="string">'default value'</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        ;;</span><br><span class="line">      *)</span><br><span class="line">        <span class="comment">#当给具有可选参数的选项-a(或--arga指定了参数时，使用指定的参数赋值给变量param1)</span></span><br><span class="line">        param1=<span class="variable">$2</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        ;;</span><br><span class="line">      <span class="keyword">esac</span></span><br><span class="line">      ;;</span><br><span class="line"><span class="params">  -b</span>|--argb)</span><br><span class="line">  <span class="comment">#如果指定了选项-b(或--argb)，则将变量param2赋值为1</span></span><br><span class="line">    param2=1</span><br><span class="line">    ;;</span><br><span class="line"><span class="params">    -c</span>|--argc)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"<span class="variable">$2</span>"</span> <span class="keyword">in</span></span><br><span class="line">      <span class="string">""</span>)</span><br><span class="line">      <span class="comment">#如果为-c(或argc)选项没有指定参数，则跳过</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        ;;</span><br><span class="line">      *)</span><br><span class="line">        <span class="comment">#如果为-c(或argc)选项指定了参数，则将指定的参数赋值给变量param3</span></span><br><span class="line">        param3=<span class="variable">$2</span></span><br><span class="line">        <span class="built_in">shift</span></span><br><span class="line">        ;;</span><br><span class="line">      <span class="keyword">esac</span></span><br><span class="line">      ;;</span><br><span class="line">  --)</span><br><span class="line">    <span class="comment">#如果为双连字符则退出while循环，表示选项的结束</span></span><br><span class="line">    <span class="built_in">shift</span></span><br><span class="line">    <span class="built_in">break</span></span><br><span class="line">    ;;</span><br><span class="line">  *)</span><br><span class="line">    <span class="comment">#若为其他选项，则显示错误信息，并退出</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"内部错误"</span></span><br><span class="line">    <span class="built_in">exit</span> 1</span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line">  <span class="built_in">shift</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#打印变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param1 = <span class="variable">$param1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param2 = <span class="variable">$param2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param3 = <span class="variable">$param3</span>"</span></span><br></pre></td></tr></table></figure><p>上述脚本中，我们使用getopt命令<code>getopt -o a::bc: --long arga::,argb,argc: -n &#39;test.sh&#39; -- &quot;$@&quot;</code>来处理指定给脚本的命令行参数。-o选项表示告诉getopt识别哪些短（一个字符）选项。–long（或-l）选项告诉getopt识别哪些长（多个字符）选项，-n选项告诉getopt在报告错误时使用什么文件名（或程序名）</p><p>getopt命令的-o选项所指定的选项字符串遵循如下规则：</p><ul><li>每个字符发表一个选项</li><li>字符后面跟一个冒号(:)表示选项需要一个参数，两个冒号(::)表示选项有个可选参数</li></ul><p>例如上面的脚本，”a::”表示识别选项-a，且-a具有一个可选参数，如果在命令行指定参数给-a选项，那么选项-a与参数之间不能有任何空格。”b”表示识别选项-b，没有参数，”c:”表示识别选项-c，有一个参数。下面看几个指定脚本短选项运行的示例</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -c 456</span></span><br><span class="line">param1 =</span><br><span class="line">param2 = 0</span><br><span class="line">param3 = 456</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -a123 -b -c 456</span></span><br><span class="line">param1 = 123</span><br><span class="line">param2 = 1</span><br><span class="line">param3 = 456</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh -a -b -c 456</span></span><br><span class="line">param1 = default value</span><br><span class="line">param2 = 1</span><br><span class="line">param3 = 456</span><br></pre></td></tr></table></figure><p>getopt命令的–long选项遵循如下规则：</p><ul><li>每个选项之间由逗号(,)分隔</li><li>字符串后面跟一个冒号(:)表示选项需要一个参数，跟两个冒号(::)表示有可选参数</li></ul><p>下面看几个指定脚本长选项运行的示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh --arga --argb --argc 456</span></span><br><span class="line">param1 = default value</span><br><span class="line">param2 = 1</span><br><span class="line">param3 = 456</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh --arga='123' --argb --argc 456</span></span><br><span class="line">param1 = 123</span><br><span class="line">param2 = 1</span><br><span class="line">param3 = 456</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh --argc 456</span></span><br><span class="line">param1 =</span><br><span class="line">param2 = 0</span><br><span class="line">param3 = 456</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh --arga 456</span></span><br><span class="line">param1 = default value</span><br><span class="line">param2 = 0</span><br><span class="line">param3 =</span><br><span class="line">[root@<span class="built_in">test</span> ~]<span class="comment"># ./test.sh --argb 456</span></span><br><span class="line">param1 =</span><br><span class="line">param2 = 1</span><br><span class="line">param3 =</span><br></pre></td></tr></table></figure><h3 id="获得用户输入"><a href="#获得用户输入" class="headerlink" title="获得用户输入"></a>获得用户输入</h3><p>bash下通过内部命令<code>read</code>接收用户键盘的输入，并可以将输入的内容赋值给一个变量</p><h4 id="基本的读取"><a href="#基本的读取" class="headerlink" title="基本的读取"></a>基本的读取</h4><p>read命令基本读取的语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span><span class="params"> -p</span> prompt variable1 variable2</span><br></pre></td></tr></table></figure><p>-p选项用于输出提示信息，来提示用户输入，read命令会每次从标准输入或者（-u 指定的文件描述符中）读取一行内容，它会将第一个单词赋值给变量variable1，第二个赋值给变量variable2，以此类推。如果输入的单词少于指定的变量数，剩下的变量会被设为空，环境变量IFS中的字符作为分隔符来将输入的内容分隔为单词。下面是一个示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span><span class="params"> -p</span> <span class="string">"请输入您的用户名："</span> username</span><br><span class="line"><span class="built_in">read</span><span class="params"> -p</span> <span class="string">"请输入您的电话："</span> tel</span><br><span class="line"><span class="built_in">read</span><span class="params"> -p</span> <span class="string">"是否继续？[y/n]"</span> input</span><br><span class="line"><span class="keyword">case</span> <span class="variable">$input</span> <span class="keyword">in</span></span><br><span class="line">[yY]*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"您输入的用户名是：<span class="variable">$username</span>"</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"您输入的电话号码是：<span class="variable">$tel</span>"</span></span><br><span class="line">  ;;</span><br><span class="line">[nN]*)</span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line">  ;;</span><br><span class="line">*)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"只能输入y或者n"</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="comment">#执行脚本</span></span><br><span class="line">./<span class="built_in">test</span>.sh</span><br><span class="line">请输入您的用户名：zhangsan</span><br><span class="line">请输入您的电话：123456</span><br><span class="line">是否继续？[y/n]y</span><br><span class="line">您输入的用户名是：zhangsan</span><br><span class="line">您输入的电话号码是：123456</span><br></pre></td></tr></table></figure><h4 id="输入超时"><a href="#输入超时" class="headerlink" title="输入超时"></a>输入超时</h4><p>通过-t选项可以指定在某个时间内输入，如果没有输入就超时退出，比如上面的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span><span class="params"> -t</span> 5<span class="params"> -p</span> <span class="string">"请输入您的用户名："</span> username</span><br></pre></td></tr></table></figure><p>每个参数等待5秒，如果没有输入提示下一个参数，直到退出</p><h4 id="隐藏方式读取"><a href="#隐藏方式读取" class="headerlink" title="隐藏方式读取"></a>隐藏方式读取</h4><p>-s选项可以隐藏用户的输入，比如密码输入的时候，比如上面的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span><span class="params"> -s</span><span class="params"> -p</span> <span class="string">"请输入您的用户名："</span> username</span><br></pre></td></tr></table></figure><h4 id="从文件中读取"><a href="#从文件中读取" class="headerlink" title="从文件中读取"></a>从文件中读取</h4><p>read命令从文件中读取数据的方法主要有两种：通过文件描述符一行一行的读取文件内容（本节不讲），一种是在循环中使用命令<code>cat filename</code>，其语法如下：</p><blockquote><p>for data in $(cat filename)</p><p>do</p><p>执行命令</p><p>done</p></blockquote><p>默认情况下这种方法是逐个单词的读取文件内容，因为在读取时它以环境变量IFS的值为分隔符，默认值为空格|tab|newline，所以默认回以空格为界限读取，如果想要一次读取一行需要修改环境变量IFS的值。下面演示一个循环按行读取文件内容的例子</p><p>首先创建一个文件at.txt如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 3 5 7 9</span><br><span class="line">2 4 6 8 0</span><br><span class="line">a b c d e</span><br></pre></td></tr></table></figure><p>其次，构建如下脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用临时变量保存$IFS的值</span></span><br><span class="line">tmp=<span class="variable">$IFS</span></span><br><span class="line"><span class="comment">#如果指定的命令行参数个数不为1，则显示脚本的使用方法，然后退出</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span><span class="params"> -ne</span> 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前脚本使用方法为：<span class="variable">$0</span> filename"</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#如果指定的文件不存在，则显示提示信息，并退出脚本执行，退出状态码为1</span></span><br><span class="line"><span class="keyword">if</span> [ !<span class="params"> -f</span> <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前文件<span class="variable">$1</span>不存在"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#修改环境变量IFS的值，以换行符为分隔读取文件</span></span><br><span class="line">IFS=$<span class="string">'\n'</span></span><br><span class="line"><span class="comment">#使用for循环来读取文件的内容，将读取的内容存入变量line</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat <span class="variable">$1</span>) ; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#恢复环境变量的值</span></span><br><span class="line">IFS=<span class="variable">$tmp</span></span><br></pre></td></tr></table></figure><p>执行脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span>.sh at.txt</span><br><span class="line">1 3 5 7 9</span><br><span class="line">2 4 6 8 0</span><br><span class="line">a b c d e</span><br><span class="line">./<span class="built_in">test</span>.sh a.txt</span><br><span class="line">当前文件a.txt不存在</span><br></pre></td></tr></table></figure><p>假如上面脚本中我们不修改环境变量IFS的值，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果指定的命令行参数个数不为1，则显示脚本的使用方法，然后退出</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$#</span><span class="params"> -ne</span> 1 ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前脚本使用方法为：<span class="variable">$0</span> filename"</span></span><br><span class="line">  <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#如果指定的文件不存在，则显示提示信息，并退出脚本执行，退出状态码为1</span></span><br><span class="line"><span class="keyword">if</span> [ !<span class="params"> -f</span> <span class="variable">$1</span> ]; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"当前文件<span class="variable">$1</span>不存在"</span></span><br><span class="line">  <span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="comment">#使用for循环来读取文件的内容，将读取的内容存入变量line</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> $(cat <span class="variable">$1</span>) ; <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$line</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>再次执行脚本如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span>.sh at.txt</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用while循环也可以读取文件内容，但是会消除每行原有的格式，去掉重复的空格和制表符，而将for循环结合环境变量$IFS使用可以保留每行原有的格式，按照自己的需求来决定使用哪种方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇博文接前面两篇介绍shell中使用正则和shell脚本输入处理，有问题及时在本文下或&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/108238438&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="shell" scheme="https://www.enjoyican.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell语法基础</title>
    <link href="https://www.enjoyican.com/posts/shell-grammar/"/>
    <id>https://www.enjoyican.com/posts/shell-grammar/</id>
    <published>2020-08-21T10:01:30.000Z</published>
    <updated>2020-08-21T10:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文总结常用的shell编程语法，有问题可及时在本博客或<a href="https://blog.csdn.net/u010408502/article/details/108158300" target="_blank" rel="noopener">CSDN</a>下留言。</p><a id="more"></a><h2 id="shell编程基础"><a href="#shell编程基础" class="headerlink" title="shell编程基础"></a>shell编程基础</h2><h3 id="shell脚本首行"><a href="#shell脚本首行" class="headerlink" title="shell脚本首行"></a>shell脚本首行</h3><p>bash shell脚本首行<code>#!/bin/bash</code>,用于确保bash作为脚本的解释程序，固定格式，记住即可，当不指定首行时，默认采用/bin/sh作为解释程序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br></pre></td></tr></table></figure><h3 id="shell脚本注释"><a href="#shell脚本注释" class="headerlink" title="shell脚本注释"></a>shell脚本注释</h3><p>shell中添加注释方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#第一种，"#"用于注释单行</span></span><br><span class="line"><span class="comment">#第二种，:&lt;&lt;! 注释内容 ！</span></span><br><span class="line"><span class="comment">#第三种，&lt;&lt;COMMENT 注释内容 COMMENT</span></span><br><span class="line"><span class="comment">#第四种，&lt;&lt;EOF 注释内容 EOF</span></span><br><span class="line">执行如下脚本</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"first word"</span></span><br><span class="line">:&lt;&lt;!</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"这是第一种注释方法"</span></span><br><span class="line">!</span><br><span class="line"><span class="keyword">#echo</span> 这是第二种注释方法</span><br><span class="line">&lt;&lt;COMMENT</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"这是第三种注释方法"</span></span><br><span class="line">COMMENT</span><br><span class="line">&lt;&lt;EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"这是第四种注释方法"</span></span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"last word"</span></span><br><span class="line">输出</span><br><span class="line">first word</span><br><span class="line">last word</span><br></pre></td></tr></table></figure><h3 id="shell脚本执行权限"><a href="#shell脚本执行权限" class="headerlink" title="shell脚本执行权限"></a>shell脚本执行权限</h3><p>shell脚本要想执行，必须具有执行权限，设置权限的命令可以查看<a href="https://www.enjoyican.com/posts/shell-command/">权限设置</a>，下面给出例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给当前用户添加执行权限</span></span><br><span class="line">chmod u+x xxx.sh</span><br><span class="line"><span class="comment">#给所有用户添加执行权限</span></span><br><span class="line">chmod +x xxx.sh </span><br><span class="line">chmod 777 xxx.sh</span><br></pre></td></tr></table></figure><p>运行shell脚本，可以通过绝对路径或相对路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/home/scripts/myshell.sh</span><br><span class="line"><span class="comment">#或者先进入路径目录，在执行</span></span><br><span class="line"><span class="built_in">cd</span> /home/scripts/</span><br><span class="line">./myshell.sh</span><br></pre></td></tr></table></figure><p>想要在任何路径都能直接通过脚本名执行脚本，需要将shell脚本所在路径添加到path环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/home/scripts</span><br></pre></td></tr></table></figure><p>之后在任意路径直接myshell.sh即可执行脚本</p><h3 id="shell变量扩展"><a href="#shell变量扩展" class="headerlink" title="shell变量扩展"></a>shell变量扩展</h3><h4 id="基本的shell变量拓展"><a href="#基本的shell变量拓展" class="headerlink" title="基本的shell变量拓展"></a>基本的shell变量拓展</h4><p>在之前已经讲过，采用<code>${param}</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;param&#125;</span></span><br></pre></td></tr></table></figure><h4 id="间接参数拓展"><a href="#间接参数拓展" class="headerlink" title="间接参数拓展"></a>间接参数拓展</h4><p><code>${!param}</code>表示引用的参数不是param自身，而是其对应的值，比如param的值是temp，通过${!param}将拓展为参数temp的值，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var=temp</span><br><span class="line">temp=<span class="string">"this is realme"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">temp</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">temp</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!var&#125;</span></span><br><span class="line">this is realme</span><br></pre></td></tr></table></figure><p>####大小写修改</p><p><code>${param^}</code>，将首字符改为大写,<code>${param^^}</code>所有字符改为大写</p><p><code>${param,}</code>将首字符改为小写,<code>${param,,}</code>所有字符改为小写</p><p><code>${param~}</code>将首字符大小写反转（原来大写改为小写，原来小写改为大写）；<code>${param~~}</code>将所有字符大小写反转</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">"this is real me"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var^&#125;</span></span><br><span class="line">This is real me</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var^^&#125;</span></span><br><span class="line">THIS IS REAL ME</span><br><span class="line">var2=<span class="string">"THIS IS REAL ME"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var2,&#125;</span></span><br><span class="line">tHIS IS REAL ME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var2,,&#125;</span></span><br><span class="line">this is real me</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var2~&#125;</span></span><br><span class="line">tHIS iS rEAL mE</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var2~~&#125;</span></span><br><span class="line">this is real me</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var~&#125;</span></span><br><span class="line">This Is Real Me</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var~~&#125;</span></span><br><span class="line">THIS IS REAL ME</span><br><span class="line">var3=<span class="string">"tHis Is mE"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var3~&#125;</span></span><br><span class="line">THis is ME</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var3~~&#125;</span></span><br><span class="line">ThIS iS Me</span><br></pre></td></tr></table></figure><h4 id="变量名拓展"><a href="#变量名拓展" class="headerlink" title="变量名拓展"></a>变量名拓展</h4><p><code>${!prefix*}或${!prefix@}</code>，使用变量名拓展将列出以字符串prefix为前缀的所有变量名，默认以空格隔开</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var=1</span><br><span class="line">var2=2</span><br><span class="line">var3=3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!var*&#125;</span></span><br><span class="line">var var2 var3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;!var@&#125;</span></span><br><span class="line">var var2 var3</span><br></pre></td></tr></table></figure><h4 id="字符串移除"><a href="#字符串移除" class="headerlink" title="字符串移除"></a>字符串移除</h4><blockquote><p>${param#parttern}</p><p>${param##parttern}</p><p>${param%parttern}</p><p>${param%%parttern}</p></blockquote><p>上述前两个语句从开头开始匹配移除，后两个语句从结尾开始匹配移除，其中单个的”#”,”%”表示移除匹配指定模式的最短文本，两个的表示移除匹配指定模式的最长文本，直接看例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">filename=myshell.sh</span><br><span class="line"><span class="comment">#保留文件名后缀</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename##*.&#125;</span></span><br><span class="line">sh</span><br><span class="line"><span class="comment">#移除后缀保留文件名</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename%.*&#125;</span></span><br><span class="line">myshell</span><br><span class="line">filename2=/usr/logs/mylog.<span class="built_in">log</span></span><br><span class="line"><span class="comment">#移除文件名保留路径</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;filename2%/*&#125;</span></span><br><span class="line">/usr/logs</span><br><span class="line"><span class="comment">#移除路径保留文件名</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;filename2##*/&#125;</span></span><br><span class="line">mylog.<span class="built_in">log</span></span><br></pre></td></tr></table></figure><h4 id="字符串搜索与替换"><a href="#字符串搜索与替换" class="headerlink" title="字符串搜索与替换"></a>字符串搜索与替换</h4><blockquote><p>${param/pattern/string}</p><p>${param//pattern/string}</p><p>${param/pattern}</p><p>${param//pattern}</p></blockquote><p>操作符”/“表示替换一个匹配的字符串，操作符”//“表示替换所有匹配的字符串，如果没有指定匹配的字符串，那么匹配的内容将会被替换为空字符串也就是删除掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">"I think I understand you"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var/I/U&#125;</span></span><br><span class="line">U think I understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var//I/U&#125;</span></span><br><span class="line">U think U understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var//I/&#125;</span></span><br><span class="line">think understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var/I/&#125;</span></span><br><span class="line">think I understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var/I&#125;</span></span><br><span class="line">think I understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var//I&#125;</span></span><br><span class="line">think understand you</span><br></pre></td></tr></table></figure><h4 id="求字符串长度"><a href="#求字符串长度" class="headerlink" title="求字符串长度"></a>求字符串长度</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;#param&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;#var&#125;</span></span><br><span class="line">24</span><br></pre></td></tr></table></figure><h4 id="子字符串扩展"><a href="#子字符串扩展" class="headerlink" title="子字符串扩展"></a>子字符串扩展</h4><blockquote><p>${param:offset}</p><p>${param:offset:length}</p></blockquote><p>从指定位置开始截取指定长度的字符串，如果省略length，将截取到参数值末尾。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:1&#125;</span></span><br><span class="line">think I understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0&#125;</span></span><br><span class="line">I think I understand you</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:0:9&#125;</span></span><br><span class="line">I think I</span><br></pre></td></tr></table></figure><h4 id="使用默认值"><a href="#使用默认值" class="headerlink" title="使用默认值"></a>使用默认值</h4><blockquote><p>${param:-word}</p><p>${param-word}</p></blockquote><p>第一种，当param参数为未定义或者为null（shell中指为空字符串而不是null）时，输出word，否则输出param；第二种只用在param未定义，才会输出word。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var=<span class="string">"I know U"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:haha&#125;</span></span><br><span class="line">I know U</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:-haha&#125;</span></span><br><span class="line">I know U</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var-haha&#125;</span></span><br><span class="line">I know U</span><br><span class="line"><span class="comment">#以下为var为null字符串时，注意此时不是null，和上面的字符串结果一样</span></span><br><span class="line">var=null</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">null</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var:haha&#125;</span></span><br><span class="line">null</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var:-haha&#125;</span></span><br><span class="line">null</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var-haha&#125;</span></span><br><span class="line">null</span><br><span class="line"><span class="comment">#以下为var未定义时</span></span><br><span class="line"><span class="built_in">unset</span> var</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:haha&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var-haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:-haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="comment">#以下为var为null时，直接理解成为空字符串</span></span><br><span class="line"> var=<span class="string">""</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var-haha&#125;</span></span><br><span class="line"></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var:-haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;var:haha&#125;</span></span><br></pre></td></tr></table></figure><h4 id="指定默认值"><a href="#指定默认值" class="headerlink" title="指定默认值"></a>指定默认值</h4><blockquote><p>${param:=word}</p><p>${param=word}</p></blockquote><p>这种模式和使用默认值的输出类似，区别在于这种模式会将word赋值给param，作为param的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:=haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var=haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">haha</span><br><span class="line">var=<span class="string">""</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:=haha&#125;</span></span><br><span class="line">haha</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var=haha&#125;</span></span><br><span class="line">haha</span><br><span class="line">var=nihao</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var=haha&#125;</span></span><br><span class="line">nihao</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:=haha&#125;</span></span><br><span class="line">nihao</span><br></pre></td></tr></table></figure><h4 id="使用替代值"><a href="#使用替代值" class="headerlink" title="使用替代值"></a>使用替代值</h4><blockquote><p>${param:+word}</p><p>${param+word}</p></blockquote><p>如果param未定义或者为空，不输出任何内容，如果已定义且不为空，输出word，且不会拓展为param的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age:+"nihao"&#125;</span></span><br><span class="line"></span><br><span class="line">age=<span class="string">""</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age:+"nihao"&#125;</span></span><br><span class="line"></span><br><span class="line">age=<span class="string">"18"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age:+"nihao"&#125;</span></span><br><span class="line">nihao</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age+"nihao"&#125;</span></span><br><span class="line">nihao</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;age&#125;</span></span><br><span class="line">18</span><br></pre></td></tr></table></figure><h3 id="Bash内部变量"><a href="#Bash内部变量" class="headerlink" title="Bash内部变量"></a>Bash内部变量</h3><p>编写shell脚本时注意不要与shell内部变量重合，可以通过<code>env</code>查看现有的系统变量，下面是一些内部变量（使用env不一定会展示下面变量）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$BASH-引用Bash实例的全路径名</span><br><span class="line">$HOME-当前用户的home目录</span><br><span class="line">$IFS-内部字段分隔符</span><br><span class="line">$OSTYPE-操作系统的类型</span><br><span class="line">$SECONDS-脚本已运行的秒数</span><br><span class="line">$UID-当前用户的账号标识码（ID），与&#x2F;etc&#x2F;passwd中记录的相同</span><br></pre></td></tr></table></figure><h3 id="Bash中的位置参数和特殊参数"><a href="#Bash中的位置参数和特殊参数" class="headerlink" title="Bash中的位置参数和特殊参数"></a>Bash中的位置参数和特殊参数</h3><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数是由除0意外的一个或多个数字表示的参数，当shell或shell的函数被引用时，由shell或shell函数的参数赋值，并且可以使用bash内部命令<code>set</code>来重新赋值，位置参数N引用时语法为${N},当位置顺序为个位数时，可以写成$N,<strong>超过一位数必须加大括号</strong>。</p><p>位置参数可以用来给shell脚本指定参数，不能通过赋值语句来赋值，只能通过bash内部命令<code>set</code>和<code>shift</code>来设置和取消，shell脚本运行是，位置参数会被临时地替换。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如下脚本test.sh</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param1:<span class="variable">$1</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param2:<span class="variable">$2</span>"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"param3:<span class="variable">$&#123;3&#125;</span>"</span></span><br><span class="line"><span class="comment">#运行脚本并输入参数</span></span><br><span class="line">./<span class="built_in">test</span>.sh <span class="string">"参数一"</span> <span class="string">"参数二"</span> <span class="string">"3"</span></span><br><span class="line">param1:参数一</span><br><span class="line">param2:参数二</span><br><span class="line">param3:3</span><br></pre></td></tr></table></figure><p><strong>某些特殊参数只能被引用，不能改变值，这些参数是*，@，#，？，-，$，！，0，_</strong></p><h4 id="特殊参数"><a href="#特殊参数" class="headerlink" title="特殊参数*"></a>特殊参数*</h4><p>引用特殊参数* 将输出从位置1开始的所有位置参数（有几个位置参数就输出几个单词），如果是在双引号内引用，如”$*”则输出一个包含所有位置参数的单词（多个位置参数合并为一个单词），此时每个单词中间用内部变量$IFS的第一个字符连接，如果变量IFS没有定义，则默认使用空格连接，如果为空””,则参数直接相连。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> one two three</span><br><span class="line"><span class="comment">#此时变量IFS未定义</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$IFS</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> $*</span><br><span class="line">one two three</span><br><span class="line"><span class="comment">#虽然输出结果和上一个看起来一样，但其实下面的是一个单词，中间包含空格"one two three"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"$*"</span></span><br><span class="line">one two three</span><br><span class="line"><span class="comment">#验证上下两种引用的不同</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $*</span><br><span class="line"><span class="keyword">&gt; do</span></span><br><span class="line"><span class="keyword">&gt; echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">&gt; done</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> <span class="string">"$*"</span></span><br><span class="line"><span class="keyword">&gt; do</span></span><br><span class="line"><span class="keyword">&gt; echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">&gt; done</span></span><br><span class="line">one two three</span><br></pre></td></tr></table></figure><h4 id="特殊参数-1"><a href="#特殊参数-1" class="headerlink" title="特殊参数@"></a>特殊参数@</h4><p>引用特殊参数@也将输出从位置1开始的所有位置参数，但是当在双引号内引用时，它的输出还是将多个参数认为是不同的多个参数，这点会在for循环调用中体现出来，例子可以参考上面，此处不再举例。</p><h4 id="特殊参数-2"><a href="#特殊参数-2" class="headerlink" title="特殊参数#"></a>特殊参数#</h4><p>引用特殊参数#将输出位置参数的个数，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$#</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="特殊参数？"><a href="#特殊参数？" class="headerlink" title="特殊参数？"></a>特殊参数？</h4><p>将输出最近一个在前台执行的命令的退出状态，命令正确执行没报错，退出状态返回0，否则将是其他数字，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> ll</span><br><span class="line">total 1369052</span><br><span class="line">...</span><br><span class="line">-rwxrwxrwx. 1 root root         65 Aug 19 21:50 <span class="built_in">test</span>.sh</span><br><span class="line">...</span><br><span class="line"> <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line"> cat test1.sh</span><br><span class="line">cat: test1.sh: No such file or directory</span><br><span class="line"> <span class="built_in">echo</span> $?</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="特殊参数-3"><a href="#特殊参数-3" class="headerlink" title="特殊参数-"></a>特殊参数-</h4><p>输出当前的选项标志，这个标志是调用时内部命令<code>set</code>指定，或者shell自身指定，和用户无关，了解即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $-</span><br><span class="line">himBH</span><br></pre></td></tr></table></figure><h4 id="特殊参数-4"><a href="#特殊参数-4" class="headerlink" title="特殊参数$"></a>特殊参数$</h4><p>输出当前shell的进程号，在子shell中输出的是调用该子shell的进程号，而不是子shell的进程号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> $$</span><br><span class="line">24448</span><br></pre></td></tr></table></figure><h4 id="特殊参数0"><a href="#特殊参数0" class="headerlink" title="特殊参数0"></a>特殊参数0</h4><p>输出当前shell或当前shell脚本的名称，在shell初始化时设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设当前脚本test.sh内容如下</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前执行的脚本名称是:<span class="variable">$0</span>"</span></span><br><span class="line">sh ./<span class="built_in">test</span>.sh</span><br><span class="line">当前执行的脚本名称是:./<span class="built_in">test</span>.sh</span><br></pre></td></tr></table></figure><h4 id="特殊参数-5"><a href="#特殊参数-5" class="headerlink" title="特殊参数_"></a>特殊参数_</h4><p>在shell启动时，设置为开始运行的shell或shell脚本的路径，随后输出前一个命令的最后一个参数，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">假设当前的<span class="built_in">test</span>.sh脚本内容如下</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前\$_ 是 <span class="variable">$_</span>"</span></span><br><span class="line">df<span class="params"> -h</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"运行完是<span class="variable">$_</span>"</span></span><br><span class="line">下面运行脚本</span><br><span class="line">bash ./<span class="built_in">test</span>.sh</span><br><span class="line">当前<span class="variable">$_</span> 是 /usr/bin/bash</span><br><span class="line">...省略df<span class="params"> -h</span>输出内容</span><br><span class="line">运行完是-h</span><br><span class="line"></span><br><span class="line">./<span class="built_in">test</span>.sh</span><br><span class="line">当前<span class="variable">$_</span> 是 ./<span class="built_in">test</span>.sh</span><br><span class="line">...省略df<span class="params"> -h</span>输出内容</span><br><span class="line">运行完是-h</span><br></pre></td></tr></table></figure><h3 id="declare指定变量类型"><a href="#declare指定变量类型" class="headerlink" title="declare指定变量类型"></a>declare指定变量类型</h3><p><code>declare</code>命令是Bash的内部命令，用于声明变量和修改变量的属性，它与Bash的另一个内部命令<code>typeset</code>用法和用途完全相同</p><h4 id="declare"><a href="#declare" class="headerlink" title="declare"></a>declare</h4><p>直接使用declare命令，不指定变量，将显示所有变量的值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span></span><br><span class="line">ABRT_DEBUG_LOG=/dev/null</span><br><span class="line">BASH=/bin/bash</span><br><span class="line">BASHOPTS=checkwinsize:cmdhist:expand_aliases:extglob:extquote:force_fignore:histappend:interactive_comments:login_shell:progcomp:promptvars:sourcepath</span><br><span class="line">BASH_ALIASES=()</span><br><span class="line">BASH_ARGC=()</span><br><span class="line">BASH_ARGV=()</span><br><span class="line">BASH_CMDS=()</span><br><span class="line">BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d</span><br><span class="line">BASH_LINENO=()</span><br><span class="line">BASH_REMATCH=()</span><br><span class="line">BASH_SOURCE=()</span><br><span class="line">BASH_VERSINFO=([0]=<span class="string">"4"</span> [1]=<span class="string">"2"</span> [2]=<span class="string">"46"</span> [3]=<span class="string">"2"</span> [4]=<span class="string">"release"</span> [5]=<span class="string">"x86_64-redhat-linux-gnu"</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="declare-r定义变量为只读"><a href="#declare-r定义变量为只读" class="headerlink" title="declare -r定义变量为只读"></a>declare -r定义变量为只读</h4><p>将指定变量定义为只读变量，这个变量不能被赋予新值或清除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span><span class="params"> -r</span> qq=123</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$qq</span></span><br><span class="line">123</span><br><span class="line">qq=234</span><br><span class="line">-bash: qq: <span class="built_in">readonly</span> variable</span><br><span class="line"><span class="built_in">unset</span> qq</span><br><span class="line">-bash: <span class="built_in">unset</span>: qq: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure><h4 id="declare-i定义变量为整数型"><a href="#declare-i定义变量为整数型" class="headerlink" title="declare -i定义变量为整数型"></a>declare -i定义变量为整数型</h4><p>将指定变量定义为整数型变量，对该变量的任何赋值将会被转化为整数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">declare</span><span class="params"> -i</span> var</span><br><span class="line">var=1</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">1</span><br><span class="line">var=<span class="string">"这下是个字符串"</span></span><br><span class="line">-bash: 这下是个字符串: syntax error: operand expected (error token is <span class="string">"这下是个字符串"</span>)</span><br><span class="line">var=<span class="string">"this"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">0</span><br><span class="line">var=10%4</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var&#125;</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="declare-x声明环境变量"><a href="#declare-x声明环境变量" class="headerlink" title="declare -x声明环境变量"></a>declare -x声明环境变量</h4><p>指定的变量会成为环境变量，可供shell以外的程序来使用</p><h4 id="declare-p显示指定变量的属性和值"><a href="#declare-p显示指定变量的属性和值" class="headerlink" title="declare -p显示指定变量的属性和值"></a>declare -p显示指定变量的属性和值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接上文</span><br><span class="line"><span class="built_in">declare</span><span class="params"> -p</span> var</span><br><span class="line">输出:<span class="built_in">declare</span><span class="params"> -i</span> var=<span class="string">"2"</span></span><br></pre></td></tr></table></figure><h4 id="declare-a声明数组"><a href="#declare-a声明数组" class="headerlink" title="declare -a声明数组"></a>declare -a声明数组</h4><p>声明数组可以采用<code>arrname=(v1 v2 v3)</code>或者<code>declare -a arrname=(v1 v2 v3)</code></p><p>数组属性可以通过declare声明，作用于数组每个成员</p><p>引用数组成员时，从下标0开始引用，${arr[0]}(<strong>花括号是必须要的</strong>) ，改变某个位置的值通过arr[i]=v来实现，如果下标是@或者*会引用所有的变量,不指定下标时输出第一个位置的元素</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">arr=(1 2 3)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[1]&#125;</span></span><br><span class="line">2</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span></span><br><span class="line">1 2 3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line">1 2 3</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr&#125;</span></span><br><span class="line">1</span><br><span class="line">arr[2]=4</span><br><span class="line"><span class="variable">$&#123;arr[@]&#125;</span></span><br><span class="line">1 2 4</span><br><span class="line">arr[4]=6</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;arr[*]&#125;</span></span><br><span class="line">1 2 4 6</span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$&#123;arr[3]&#125;</span></span><br></pre></td></tr></table></figure><h3 id="shell算术运算"><a href="#shell算术运算" class="headerlink" title="shell算术运算"></a>shell算术运算</h3><p>shell可以进行算数运算，可以通过算数拓展或者通过内部命令<code>let</code>实现</p><h4 id="bash运算符"><a href="#bash运算符" class="headerlink" title="bash运算符"></a>bash运算符</h4><p>bash运算符的优先级，结合性和值都与C语言相同，下面是优先级从高到低排列：</p><table><thead><tr><th>操作符</th><th>用途</th></tr></thead><tbody><tr><td>id++ id–</td><td>后递增，后递减</td></tr><tr><td>++id –id</td><td>前递增，前递减</td></tr><tr><td>-+</td><td>单目负号和正号(用在数字前边)</td></tr><tr><td>！~</td><td>逻辑取反，按位取反</td></tr><tr><td>**</td><td>求n次方，如5**2=25</td></tr><tr><td>*、/、%</td><td>乘、除、取余</td></tr><tr><td>+-</td><td>加减</td></tr><tr><td>&lt;&lt;、   &gt;&gt;</td><td>按位左移，按位右移</td></tr><tr><td>&lt;= 、&gt;=、&lt;、&gt;</td><td>比较符号</td></tr><tr><td>==、！=</td><td>相等，不等</td></tr><tr><td>&amp;、^、|</td><td>按位与、按位异或、按位或</td></tr><tr><td>&amp;&amp;、||</td><td>逻辑与、逻辑或</td></tr><tr><td>expr？expr：expr</td><td>条件运算符</td></tr><tr><td>=、*=、/=、%=、+=、-=、&lt;&lt;=、&gt;&gt;=、&amp;=、^=、|=</td><td>赋值</td></tr><tr><td>expr1，expr2</td><td>逗号运算，连接多个运算，只有最后一个运算值返回</td></tr></tbody></table><h4 id="数字常量"><a href="#数字常量" class="headerlink" title="数字常量"></a>数字常量</h4><p>默认情况，shell运算采用十进制，除非数字有特定前缀标志，以0开头的常量将被当做八进制数解释，而以”0x”或”0X”开头的为十六进制数。如果数值格式是BASE#NUMBER,BASE是介于2-64之间的十进制数，表示算数进制技术，例如BASE为12,12#NUMBER表示12进制数，NUMBER是该进制下的数值。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> dec=20</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"十进制数 dec=<span class="variable">$&#123;dec&#125;</span>"</span></span><br><span class="line">十进制数 dec=20</span><br><span class="line"><span class="built_in">let</span> oct=071</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"八进制数 oct=<span class="variable">$&#123;oct&#125;</span>"</span></span><br><span class="line">八进制数 oct=57</span><br><span class="line"><span class="built_in">let</span> hex=0X91</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"十六进制数 hex=<span class="variable">$&#123;hex&#125;</span>"</span></span><br><span class="line">十六进制数 hex=145</span><br><span class="line"><span class="built_in">let</span> bin=0110</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"二进制数 bin=<span class="variable">$&#123;bin&#125;</span>"</span></span><br><span class="line">二进制数 bin=72</span><br><span class="line"><span class="built_in">let</span> bin=2<span class="comment">#0110</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"二进制数 bin=<span class="variable">$&#123;bin&#125;</span>"</span></span><br><span class="line">二进制数 bin=6</span><br><span class="line"><span class="built_in">let</span> base64=64<span class="comment">#@_</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"六十四进制数 base64=<span class="variable">$&#123;base64&#125;</span>"</span></span><br><span class="line">六十四进制数 base64=4031</span><br></pre></td></tr></table></figure><p>在64进制中，0-9即使用0-9表示，10-35用a-z表示，36-61用A-Z表示，62和63分别用@和_表示</p><h4 id="使用算术扩展和let进行算数运算"><a href="#使用算术扩展和let进行算数运算" class="headerlink" title="使用算术扩展和let进行算数运算"></a>使用算术扩展和let进行算数运算</h4><p><strong>算数扩展只能运算整数，不能对浮点数进行算术运算</strong></p><p>直接上示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var=5</span><br><span class="line">var=$((<span class="variable">$var</span>+8))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span></span><br><span class="line">13</span><br><span class="line">x=17</span><br><span class="line">y=2</span><br><span class="line">z=$(x%y)</span><br><span class="line">-bash: x%y: <span class="built_in">command</span> not found</span><br><span class="line">z=$((x%y))</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;z&#125;</span></span><br><span class="line">1</span><br><span class="line"><span class="comment">#条件为真返回1，条件为假返回0</span></span><br><span class="line"><span class="built_in">echo</span> $((10&gt;3))</span><br><span class="line">1</span><br><span class="line"> a=28</span><br><span class="line"> b=25</span><br><span class="line"> <span class="built_in">echo</span> $(($((a&gt;b))?a:b))</span><br><span class="line">28</span><br><span class="line"> <span class="built_in">echo</span> $((a&gt;b?a:b))</span><br><span class="line">28</span><br></pre></td></tr></table></figure><p><code>let</code>也可以进行算数运算，<strong>默认情况下运算符左右两边不允许有空格，如果有空格，需要用双引号包起来</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> i=i+5</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">5</span><br><span class="line"><span class="built_in">let</span> i = i+5</span><br><span class="line">-bash: <span class="built_in">let</span>: =: syntax error: operand expected (error token is <span class="string">"="</span>)</span><br><span class="line"><span class="built_in">let</span> <span class="string">"i = i+5"</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure><h4 id="使用expr命令"><a href="#使用expr命令" class="headerlink" title="使用expr命令"></a>使用expr命令</h4><p><code>expr</code>命令用于对表达式进行求值并输出相应结果，只支持整数运算，不支持浮点数运算。与命令相反，使用该命令，运算符左右两边必须包含空格，如果没有空格，将不会求值而是直接输出算数表达式，有些运算符需要使用”\“进行转义，否则会提示语法错误（包括*、&lt;、&gt;、&lt;=、&gt;=、|、&amp;）。通过<code>expr</code>给变量赋值时需要使用<a href="https://www.enjoyican.com/posts/shell-command/#命令替换">shell拓展中的命令替换</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">expr 6 + 8</span><br><span class="line">14</span><br><span class="line">expr 6+8</span><br><span class="line">6+8</span><br><span class="line">expr 6 * 8</span><br><span class="line">expr: syntax error</span><br><span class="line">expr 6 \* 8</span><br><span class="line">48</span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"><span class="comment">#通过命令替换给C赋值</span></span><br><span class="line">c=$(expr <span class="variable">$a</span> \* <span class="variable">$b</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$c</span></span><br><span class="line">30</span><br></pre></td></tr></table></figure><h3 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h3><p><code>exit</code>命令用于结束并退出一个shell脚本</p><p>一个运行成功的命令会返回一个0，不成功会返回其他值，shell脚本及里面的函数也会返回一个退出状态码，在shell脚本或函数中，最后执行的一条命令决定其退出状态。通过特殊参数？可以得知退出状态码。</p><p>校验程序的退出状态码是有用且必要的（某些危险指令下），比如下面两条：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$DIR</span></span><br><span class="line">rm<span class="params"> -rf</span> *</span><br></pre></td></tr></table></figure><p>脚本的本意是切换到DIR目录下，删除该目录下所有文件，加入我们不对cd命令结果进行验证，假如该文件夹不存在，那么rm命令将在当前文件夹下执行，这可能产生不可预料的损失。</p><p>在shell脚本中，通过<code>exit N</code>命令可以用于提交一个退出状态码给shell（N必须是介于0-255之间的整数）,如果省略了退出状态码N，则将把最后一条运行的命令的退出状态作为脚本的退出状态码。</p><p>结合退出状态码，对上面的脚本进行改写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="variable">$DIR</span></span><br><span class="line"><span class="keyword">if</span> [$?<span class="params"> -eq</span> 0];<span class="keyword">then</span></span><br><span class="line">rm<span class="params"> -rf</span> *</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"找不到切换的文件夹"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 1</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="调试脚本"><a href="#调试脚本" class="headerlink" title="调试脚本"></a>调试脚本</h3><p>通过<code>bash -x xxx.sh</code>可以调试脚本，该命令会启动子shell，以调试模式运行脚本，在执行过程中将实际执行的命令显示出来，其中的参数也是实际的运行时参数，每个命令行前面有个+号，如下例子中+号后面是实际运行的命令，其他是运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">bash<span class="params"> -x</span> <span class="built_in">test</span>.sh</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">'当前$_ 是 /usr/bin/bash'</span></span><br><span class="line">当前<span class="variable">$_</span> 是 /usr/bin/bash</span><br><span class="line">+ df<span class="params"> -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda1       40G   28G   10G  74% /</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   89M  3.8G   3% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/xvdb1       59G   56M   56G   1% /data-disk</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/0</span><br><span class="line">+ <span class="built_in">echo</span> $<span class="string">'\350\277\220\350\241\214\345\256\214\346\230\257-h'</span></span><br><span class="line">运行完是-h</span><br></pre></td></tr></table></figure><p>在shell脚本中使用’”set -x”表示启动某选项，”set +x”表示关闭某选项，通过这两个命令可以只调试shell中的某一段脚本。比如我们先将前述test.sh脚本修改成如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">set</span><span class="params"> -x</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前\$_ 是 <span class="variable">$_</span>"</span></span><br><span class="line"><span class="built_in">set</span> +x</span><br><span class="line">df<span class="params"> -h</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"运行完是<span class="variable">$_</span>"</span></span><br><span class="line"><span class="comment">#上述脚本中我们当前想调试的是这段脚本echo "当前\$_ 是 $_"，执行后结果如下：</span></span><br><span class="line"> ./<span class="built_in">test</span>.sh</span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">'当前$_ 是 -x'</span></span><br><span class="line">当前<span class="variable">$_</span> 是<span class="params"> -x</span></span><br><span class="line">+ <span class="built_in">set</span> +x</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda1       40G   28G   10G  74% /</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   89M  3.8G   3% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/xvdb1       59G   56M   56G   1% /data-disk</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/0</span><br><span class="line">运行完是-h</span><br></pre></td></tr></table></figure><p>bash中<code>-v</code>选项可以激活详细输出模式，通常调试是会将-v和-x配合使用，得到更详细的脚本信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> bash<span class="params"> -xv</span> <span class="built_in">test</span>.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"当前\$_ 是 <span class="variable">$_</span>"</span></span><br><span class="line">+ <span class="built_in">echo</span> <span class="string">'当前$_ 是 /usr/bin/bash'</span></span><br><span class="line">当前<span class="variable">$_</span> 是 /usr/bin/bash</span><br><span class="line">df<span class="params"> -h</span></span><br><span class="line">+ df<span class="params"> -h</span></span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/xvda1       40G   28G   10G  74% /</span><br><span class="line">devtmpfs        3.9G     0  3.9G   0% /dev</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /dev/shm</span><br><span class="line">tmpfs           3.9G   89M  3.8G   3% /run</span><br><span class="line">tmpfs           3.9G     0  3.9G   0% /sys/fs/cgroup</span><br><span class="line">/dev/xvdb1       59G   56M   56G   1% /data-disk</span><br><span class="line">tmpfs           783M     0  783M   0% /run/user/0</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"运行完是<span class="variable">$_</span>"</span></span><br><span class="line">+ <span class="built_in">echo</span> $<span class="string">'\350\277\220\350\241\214\345\256\214\346\230\257-h'</span></span><br><span class="line">运行完是-h</span><br></pre></td></tr></table></figure><p>使用-x虽然方便，但是没有显示代码行号等信息，下面几个bash内部环境变量配合起来可以更方便显示调试信息：</p><p>$LINENO：表示shell脚本的当前行号</p><p>$FUNCNAME:包含当前在执行调用堆栈中的所有shell函数名称的数组变量。${FUNCNAME[0]}表示当前正在执行的shell函数的名称，${FUNCNAME[1]}代表调用函数${FUNCNAME[0]}的函数名字，依次类推</p><p>$PS4:之前调试中每一行命令前的+号就是该变量的默认值</p><p>通过这几个变量配合，我们可以通过重新定义$PS4,增强-x输出的信息</p><p>此外还可以通过<code>bash -n</code>检查脚本是否有语法错误。</p><h2 id="shell条件执行"><a href="#shell条件执行" class="headerlink" title="shell条件执行"></a>shell条件执行</h2><h3 id="条件测试"><a href="#条件测试" class="headerlink" title="条件测试"></a>条件测试</h3><p><code>test</code>命令测试成功返回0（真），失败返回1（假），test命令可以用于文件属性，字符串，算术测试，语法为test expression或[空格expression空格]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="built_in">test</span><span class="params"> -d</span> <span class="string">"<span class="variable">$HOME</span>"</span>;<span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line"> [<span class="string">"abc"</span> != <span class="string">"bcd"</span>];<span class="built_in">echo</span> $?</span><br><span class="line">-bash: [abc: <span class="built_in">command</span> not found</span><br><span class="line">127</span><br><span class="line"> [ <span class="string">"abc"</span> != <span class="string">"bcd"</span> ];<span class="built_in">echo</span> $?</span><br><span class="line">0</span><br><span class="line"> <span class="built_in">test</span> 7<span class="params"> -gt</span> 3 &amp;&amp; <span class="built_in">echo</span> TRUE || <span class="built_in">echo</span> FALSE</span><br><span class="line">TRUE</span><br></pre></td></tr></table></figure><h4 id="常用文件属性测试操作符"><a href="#常用文件属性测试操作符" class="headerlink" title="常用文件属性测试操作符"></a>常用文件属性测试操作符</h4><p>-e：文件存在则为真</p><p>-f：存在且为常规文件则为真</p><p>-d：存在且是一个目录则为真</p><p>-r：存在且是可读的则为真</p><p>-w：存在且是可写的则为真</p><p>-x：存在且是可执行的则为真</p><p>-s：存在且不为空则为真</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span><span class="params"> -e</span> /bin/cp &amp;&amp; <span class="built_in">echo</span> <span class="string">"The command <span class="variable">$_</span> found"</span> || <span class="built_in">echo</span> <span class="string">"The command <span class="variable">$_</span> not found."</span></span><br><span class="line">The <span class="built_in">command</span> /bin/cp found</span><br></pre></td></tr></table></figure><p>命令中$_表示前一个执行的命令中的最后一个参数。</p><h4 id="常用字符串操作符如下"><a href="#常用字符串操作符如下" class="headerlink" title="常用字符串操作符如下"></a>常用字符串操作符如下</h4><p>-z：字符串为空则为真</p><p>-n：字符串不为空则为真</p><p>=（两字符串相等）!=、&lt;(比较字典序)、&gt;</p><p>由于大于小于在shell中也被用于重定向，因此比较字符串的时候需要加转义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> <span class="string">"abc"</span> \&lt; <span class="string">"def"</span>;<span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="常用算数测试操作符"><a href="#常用算数测试操作符" class="headerlink" title="常用算数测试操作符"></a>常用算数测试操作符</h4><p>-eq：等于;-ne：不等于;-le：小于等于;-ge：大于等于;-lt：小于;-gt：大于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 5<span class="params"> -eq</span> 5 &amp;&amp; <span class="built_in">echo</span> YES || <span class="built_in">echo</span> NO</span><br><span class="line">YES</span><br></pre></td></tr></table></figure><h4 id="if结构语法格式"><a href="#if结构语法格式" class="headerlink" title="if结构语法格式"></a>if结构语法格式</h4><p>if语句的条件判断命令可以使用test命令，也可以是其他运行成功返回状态码0，失败返回其他状态码的命令，if语法格式如下；</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="built_in">test</span>-commands ]; <span class="keyword">then</span></span><br><span class="line">  其他指令</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span>-commands</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  其他指令</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">或者</span><br><span class="line"><span class="keyword">if</span> [ <span class="built_in">test</span>-commands ]; <span class="keyword">then</span> 其他指令;<span class="keyword">fi</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="if…else…fi语句"><a href="#if…else…fi语句" class="headerlink" title="if…else…fi语句"></a>if…else…fi语句</h4><p>语法如下：</p><blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">&gt;if</span> [ <span class="built_in">test</span>-commands ]</span><br><span class="line"><span class="keyword">&gt;then</span></span><br><span class="line"> 其他指令</span><br><span class="line"><span class="keyword">&gt;else</span></span><br><span class="line"> 其他指令（或者继续跟着<span class="keyword">if</span>语句）</span><br><span class="line"><span class="keyword">&gt;fi</span></span><br><span class="line">&gt;还可以嵌套</span><br><span class="line"><span class="keyword">&gt;if</span> [ <span class="built_in">test</span>-commands1 ]</span><br><span class="line"><span class="keyword">&gt;then</span></span><br><span class="line"> 执行指令1</span><br><span class="line"> <span class="keyword">if</span> [ <span class="built_in">test</span>-commands2 ]; </span><br><span class="line"> <span class="keyword">then</span></span><br><span class="line">   执行指令2</span><br><span class="line"> <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">&gt;else</span></span><br><span class="line"> 执行指令3</span><br><span class="line"><span class="keyword">&gt;fi</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="if…elif…elif…fi"><a href="#if…elif…elif…fi" class="headerlink" title="if…elif…elif…fi"></a>if…elif…elif…fi</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> [ <span class="built_in">test</span>-commands1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  其他指令</span><br><span class="line"><span class="keyword">elif</span> [ <span class="built_in">test</span>-commands1 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">   其他指令</span><br><span class="line"><span class="keyword">elif</span> [ <span class="built_in">test</span>-commands1 ] </span><br><span class="line"><span class="keyword">then</span></span><br><span class="line">  其他指令</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  其他指令</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><h3 id="条件执行"><a href="#条件执行" class="headerlink" title="条件执行"></a>条件执行</h3><p>bash下可以根据最后一个命令的退出状态使用条件执行来连接两个命令，也可以直接在if语句中使用条件执行，bash支持以下两种条件执行：</p><p>逻辑与—只有当前一个命令执行成功时才执行后一个命令</p><p>逻辑或—只有当前一个命令执行失败时才执行后一个命令</p><h4 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与&amp;&amp;"></a>逻辑与&amp;&amp;</h4><p>逻辑与<code>&amp;&amp;</code>用法为<code>command1&amp;&amp;command2</code>,只有当command1返回一个退出状态码0时，才会执行command2，也就是1执行成功才会执行2，前面已经有例子，此处不再举例。</p><p>也可以通过<code>&amp;&amp;</code>在if语句中将多个test命令连接在一起，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var=123</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;var&#125;</span><span class="params"> -ge</span> 100 ] &amp;&amp; [ <span class="variable">$&#123;var&#125;</span><span class="params"> -lt</span> 150 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"haha"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$&#123;var&#125;</span><span class="params"> -ge</span> 100 &amp;&amp; <span class="variable">$&#123;var&#125;</span><span class="params"> -lt</span> 150 ]]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"haha"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">#test</span>命令中还可以使用-a表示逻辑与</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;var&#125;</span><span class="params"> -ge</span> 100 ]<span class="params"> -a</span> [ <span class="variable">$&#123;var&#125;</span><span class="params"> -lt</span> 150 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"haha"</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$&#123;var&#125;</span><span class="params"> -ge</span> 100<span class="params"> -a</span> <span class="variable">$&#123;var&#125;</span><span class="params"> -lt</span> 150 ]</span><br><span class="line"><span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"haha"</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure><p><strong>需要注意的是使用-a代替&amp;&amp;有一点不同，-a会将前后两个test命令参数都拓展执行，但是&amp;&amp;只有前一个为真才执行后一个，假如两个命令前一个结果是假，后一个为echo语句，使用&amp;&amp;不会执行后面的输出语句，但使用-a会执行后面的输出语句，此外从可读性方面也不建议使用-a代替&amp;&amp;</strong></p><h4 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或||"></a>逻辑或||</h4><p>用法<code>command1||command2</code>,只有当command1返回假（非0）时才会运行command2，也就是只有command1执行失败才会执行command2</p><p><code>||</code>可以与逻辑与<code>&amp;&amp;</code>联合使用，也可以多个逻辑或联合使用，因概念比较简单，不再举例</p><p>在逻辑或语句中可以使用<code>-o</code>代替<code>||</code>，但是从可读性，运行效率方面看也不建议这么做。</p><h4 id="逻辑非！"><a href="#逻辑非！" class="headerlink" title="逻辑非！"></a>逻辑非！</h4><p>用法<code>!command</code>用来测试真假，比较简单，不展开了。</p><h3 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h3><p>case语句是多级if…then…else…fi语句的替代方式，可以让一个条件与多个模式比较，类似java中switch，case。语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> EXPRESSION <span class="keyword">in</span></span><br><span class="line">PATTERN1)</span><br><span class="line">  执行命令1;;</span><br><span class="line">PATTERN2)</span><br><span class="line">  执行命令2;;</span><br><span class="line">PATTERN3)</span><br><span class="line">  执行命令3</span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="keyword">case</span> <span class="variable">$var</span> <span class="keyword">in</span></span><br><span class="line">123)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"命中123"</span>;;</span><br><span class="line">234)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"命中234"</span>;;</span><br><span class="line">345)</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"命中345"</span></span><br><span class="line">  ;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure><p>case语句一定要以<code>esac</code>结尾，每一个命令列表都以两个分号”;;”为终结，只有最后一个命令列表（即esac语句之前）的”;;”可以省略</p><h3 id="bash循环"><a href="#bash循环" class="headerlink" title="bash循环"></a>bash循环</h3><h4 id="for循环语法"><a href="#for循环语法" class="headerlink" title="for循环语法"></a>for循环语法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#基本语法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> &#123;item1 item1 item1 ...itemN&#125; </span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    执行语句</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#循环取变量内容语法</span></span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $变量</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">执行语句</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">#for</span>循环命令替换(去命令执行结果)的语法如下</span><br><span class="line"><span class="keyword">for</span> var <span class="keyword">in</span> $(<span class="built_in">command</span>)<span class="comment">#或者for var in 'command'</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">执行语句</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#也可以使用常见的循环</span></span><br><span class="line"><span class="keyword">for</span> (( i = 0; i &lt; n; i++ ))</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#同样可以嵌套循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; ; </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"haha"</span>    </span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> i</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> [ condition ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    其他指令</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>使用<code>true</code>,<code>false</code>或<code>:</code>可以定义无限循环，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"nihao"</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="keyword">while</span> :</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"nihao"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="until循环"><a href="#until循环" class="headerlink" title="until循环"></a>until循环</h4><p>until循环与while循环类似，也是基于一个条件，但<strong>其与while循环的逻辑正好相反，当条件被满足时退出循环，不满足时才持续运行</strong>。until循环语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until [ EXPRESSION ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"你好"</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将test.sh修改为如下内容</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">var=1</span><br><span class="line">until [ <span class="variable">$&#123;var&#125;</span><span class="params"> -gt</span> 3 ];</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"this is the <span class="variable">$&#123;var&#125;</span> time to print"</span></span><br><span class="line">  var=$((<span class="variable">$&#123;var&#125;</span>+1))</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#执行</span></span><br><span class="line">./<span class="built_in">test</span>.sh</span><br><span class="line">this is the 1 time to <span class="built_in">print</span></span><br><span class="line">this is the 2 time to <span class="built_in">print</span></span><br><span class="line">this is the 3 time to <span class="built_in">print</span></span><br></pre></td></tr></table></figure><h4 id="select循环"><a href="#select循环" class="headerlink" title="select循环"></a>select循环</h4><p>语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select var <span class="keyword">in</span> list</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">command1</span><br><span class="line">command2</span><br><span class="line">...</span><br><span class="line">commandn</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p><strong>select循环特点：</strong></p><ul><li>select语句使用bash内部变量PS3的值作为提示符</li><li>打印到屏幕上的列表list当中的每一项会在前面加上数字编号</li><li>当用户输入的数字与某一个数字编号一致是，列表中相应的项即被赋予变量var</li><li>如果用户输入的内容为空，则重新显示列表list中的项和提示符信息</li><li>可以添加一个退出选项，或者按ctrl+C或者ctrl+D组合键退出select循环</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#test</span>.sh</span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">myArray=(a b c d)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="variable">$&#123;myArray[*]&#125;</span> ;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line"> <span class="built_in">echo</span> <span class="variable">$i</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line">PS3=<span class="string">"please enter your choice："</span></span><br><span class="line">select item <span class="keyword">in</span> <span class="variable">$&#123;myArray[*]&#125;</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="variable">$item</span> <span class="keyword">in</span></span><br><span class="line">  a)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"您选择了a选项..."</span></span><br><span class="line">    ;;</span><br><span class="line">  b)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"您选择了b选项..."</span></span><br><span class="line">    ;;</span><br><span class="line">  c)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"您选择了c选项..."</span></span><br><span class="line">    ;;</span><br><span class="line">  d)</span><br><span class="line">   <span class="built_in">echo</span> <span class="string">"您选择了d选项...即将退出脚本"</span></span><br><span class="line">   <span class="built_in">exit</span></span><br><span class="line">    ;;</span><br><span class="line">  <span class="keyword">esac</span></span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"><span class="comment">#执行脚本test.sh</span></span><br><span class="line">./<span class="built_in">test</span>.sh</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">1) a</span><br><span class="line">2) b</span><br><span class="line">3) c</span><br><span class="line">4) d</span><br><span class="line">please enter your choice：1</span><br><span class="line">您选择了a选项...</span><br><span class="line">please enter your choice：2</span><br><span class="line">您选择了b选项...</span><br><span class="line">please enter your choice：3</span><br><span class="line">您选择了c选项...</span><br><span class="line">please enter your choice：4</span><br><span class="line">您选择了d选项...即将退出脚本</span><br></pre></td></tr></table></figure><h3 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h3><p><code>break</code>,<code>continue</code>用来进行循环控制，与其他语句含义一致。</p><h4 id="break"><a href="#break" class="headerlink" title="break"></a>break</h4><p>用于从for、while、until或select循环中退出，停止，语法如下：<code>break n</code></p><p>其中n代表嵌套循环的层级，指定了n，将退出n级嵌套循环，没有指定或者n小于1，则退出状态码为0，否则退出状态码为n</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#退出两层嵌套循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125; ; </span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  <span class="built_in">echo</span> <span class="string">"haha"</span> </span><br><span class="line">  <span class="built_in">break</span> 2</span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">    <span class="built_in">echo</span> i</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h4><p>continue语句用于跳过循环体中剩余的命令直接跳转到循环体的顶部，重新开始循环的下一次重复，continue用于for、while或until循环</p><p>语法为<code>continue n</code></p><h2 id="shell函数"><a href="#shell函数" class="headerlink" title="shell函数"></a>shell函数</h2><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>函数的目的就是为了复用，函数定义语法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function_name()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">#函数体</span></span><br><span class="line"><span class="built_in">command</span></span><br><span class="line"><span class="comment">#参数返回，return语句可选，没有return语句，则以函数最后一条命令的运行结果作为返回值；如果使用return语句，则return后跟数值n(0-255)</span></span><br><span class="line">[<span class="built_in">return</span> int]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#或者可在前面加上function关键字,有function可以省略圆括号()</span></span><br><span class="line"><span class="keyword">function</span> name()</span><br><span class="line">&#123;</span><br><span class="line">commands</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#也可以在一行内定义一个函数，此时函数体内各命令之间必须用分号“;”隔开，语法如下</span></span><br><span class="line"><span class="keyword">function</span> name &#123; command1;command2;commandN &#125;</span><br><span class="line">或<span class="function"><span class="title">name</span></span>()&#123; command1;command2;commandN &#125;</span><br></pre></td></tr></table></figure><p><strong>可以使用内部命令unset的”-f”选项来取消函数的定义，通常情况下函数体外的大括号与函数体之间必须用空白符（空格、回车或制表符等）或换行符分开。</strong></p><h3 id="函数的参数、变量与返回值"><a href="#函数的参数、变量与返回值" class="headerlink" title="函数的参数、变量与返回值"></a>函数的参数、变量与返回值</h3><h4 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h4><p>函数中使用参数的语法规则如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">name</span></span>()&#123;</span><br><span class="line"> arg1=<span class="variable">$1</span></span><br><span class="line"> arg1=<span class="variable">$2</span></span><br><span class="line"> //指令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用如下语法调用函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">#name</span>-函数名；param1-参数1；param-参数2</span><br><span class="line">name param1 param2</span><br></pre></td></tr></table></figure><p>回顾下之前提到的位置参数：</p><ul><li>所有函数参数都可以通过$1,$2,…即位置参数来访问</li><li>$0指代脚本名称</li><li>$*或$@保存传递给函数的所有参数</li><li>$#保存传递给函数的参数个数</li></ul><h4 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h4><p>默认情况下函数的变量为全局变量，在函数内改变变量值之后外面的变量值也会变化，<code>local</code>命令用来创建一个本地变量，其语法如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">local</span> var=value</span><br><span class="line"><span class="built_in">local</span> varName</span><br><span class="line">或者</span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">name</span></span>()&#123;</span><br><span class="line">    <span class="comment">#定义一个本地变量</span></span><br><span class="line">    <span class="built_in">local</span> var=<span class="variable">$1</span></span><br><span class="line">    其他命令</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>local命令只能在函数内部使用；local命令将变量名的可见范围限制在函数内部</p><h4 id="return命令"><a href="#return命令" class="headerlink" title="return命令"></a>return命令</h4><p>return语句可选，没有return语句，则以函数最后一条命令的运行结果作为返回值；如果使用return语句，则return后跟数值n(0-255)</p><h3 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h3><p>函数调用方式有多种，可以直接在shell命令行调用，或者脚本内部调用，或者从其他函数文件中调用，也可以递归调用。</p><h4 id="在命令行中调用"><a href="#在命令行中调用" class="headerlink" title="在命令行中调用"></a>在命令行中调用</h4><p>可以通过直接输入函数的名字，来调用或引用函数</p><p>function_name</p><h4 id="在脚本中调用"><a href="#在脚本中调用" class="headerlink" title="在脚本中调用"></a>在脚本中调用</h4><p>在脚本中定义并且调用函数的方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionname</span></span>()&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br><span class="line">调用函数</span><br><span class="line">functionname</span><br></pre></td></tr></table></figure><p><strong>要在脚本中调用函数，首先要定义函数，并且保证位于调用此函数的语句之前，所以脚本对于变量和函数的定义尽量放在脚本最前面</strong></p><h4 id="从函数文件中调用函数"><a href="#从函数文件中调用函数" class="headerlink" title="从函数文件中调用函数"></a>从函数文件中调用函数</h4><p>可以把所有的函数存储在一个函数文件中，或者把所有的函数加载到当前脚本或是命令行。加载函数文件中所有函数的语法如下,可以在命令行调用或者脚本文件中调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">. /path/to/your/<span class="built_in">functions</span>.sh</span><br></pre></td></tr></table></figure><p><code>source</code>命令也可以用于加载任何函数文件到当前shell脚本或者命令行，语法如下：<code>source filename [arguments]</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> <span class="built_in">functions</span>.sh</span><br><span class="line"><span class="built_in">source</span> /path/to/your/<span class="built_in">functions</span>.sh</span><br><span class="line"><span class="built_in">source</span> <span class="built_in">functions</span>.sh param1=xxx param2=xxx</span><br></pre></td></tr></table></figure><h4 id="递归函数调用"><a href="#递归函数调用" class="headerlink" title="递归函数调用"></a>递归函数调用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">fact</span></span>()&#123;</span><br><span class="line">   <span class="built_in">local</span> number=<span class="variable">$1</span></span><br><span class="line">   <span class="keyword">if</span> [ <span class="variable">$number</span><span class="params"> -le</span> 0 ];<span class="keyword">then</span> <span class="comment">#判断条件</span></span><br><span class="line">     res=1</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">     fact $((number-1)) <span class="comment">#递归调用fact函数</span></span><br><span class="line">     temp=<span class="variable">$res</span><span class="comment">#存储该层级之前的阶乘值</span></span><br><span class="line">     number=<span class="variable">$number</span></span><br><span class="line">     res=$((number*temp)) <span class="comment">#当前层级和之前层级的总阶乘数</span></span><br><span class="line">   <span class="keyword">fi</span></span><br><span class="line"> &#125;</span><br><span class="line">fact <span class="variable">$1</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$res</span></span><br></pre></td></tr></table></figure><p>bash下函数递归调用很慢，尽量避免</p><h4 id="将函数放在后台运行"><a href="#将函数放在后台运行" class="headerlink" title="将函数放在后台运行"></a>将函数放在后台运行</h4><p>将函数放在后台运行如下，在脚本中调用函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">functionname</span></span>()&#123;</span><br><span class="line">函数体</span><br><span class="line">&#125;</span><br><span class="line">调用函数</span><br><span class="line">functionname &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文总结常用的shell编程语法，有问题可及时在本博客或&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/108158300&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;下留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="shell" scheme="https://www.enjoyican.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>shell脚本常用命令</title>
    <link href="https://www.enjoyican.com/posts/shell-command/"/>
    <id>https://www.enjoyican.com/posts/shell-command/</id>
    <published>2020-08-17T13:19:30.000Z</published>
    <updated>2020-08-17T13:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博文总结常用的shell命令，比较基础，作为备忘待使用时查阅吧，有问题可及时在本博客或<a href="https://blog.csdn.net/u010408502/article/details/108077742" target="_blank" rel="noopener">CSDN</a>下留言。</p><a id="more"></a><h2 id="shell基础"><a href="#shell基础" class="headerlink" title="shell基础"></a>shell基础</h2><h3 id="快捷键："><a href="#快捷键：" class="headerlink" title="快捷键："></a>快捷键：</h3><p><code>Ctrl+W</code> ：删除光标位置前单词</p><p><code>Ctrl+U</code> ：清空行</p><p>上下方向键：查看历史命令</p><p><code>Tab</code> ：自动补全</p><p><code>Ctrl+R</code>：搜索先前使用的命令</p><p><code>Ctrl+C</code> ：中止当前命令</p><p><code>Ctrl+D/logout/exit</code> : 退出登录shell</p><p><code>ESC+T</code> : 调换光标前的两个单词</p><p><code>cat /etc/shells</code> : 查看系统中所有可用的shell</p><p><code>echo $SHELL或ps -p $$</code> : 查看账号当前使用的Shell类型</p><h3 id="shell脚本构成："><a href="#shell脚本构成：" class="headerlink" title="shell脚本构成："></a>shell脚本构成：</h3><ul><li>shell关键字：例如if…else,for do…done</li><li>shell命令：例如export，echo，exit，pwd，return</li><li>linux命令：如date，rm，mkdir</li><li>文本处理功能：如awk，cut，sed，grep</li><li>函数：通过函数将一些常用的功能放在一起，例如/etc/init.d目录中的大部分或全部系统shell脚本所使用的函数都包含在文件/etc/init.d/functions中</li><li>控制流语句：例如if…then…else或执行重复操作的shell循环</li></ul><p>创建一个shell脚本需要以下三步：写一个脚本，允许shell执行它，把它放到可以找到的地方</p><p>下面是一个脚本示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"><span class="keyword">#My</span> first script</span><br><span class="line">ls<span class="params"> -l</span> .*</span><br></pre></td></tr></table></figure><p>第一行告诉shell使用什么程序解释脚本，本例中使用/bin/bash，其他脚本语言如Perl，awk，python等也同样使用这个机制</p><p>第二行是一个注释，#后面的任何内容都会被bash忽略</p><p>文件保存后，默认情况下linux是不允许执行的，需要通过chmod命令授予可执行权限<code>chmod 755 文件名</code></p><p>之后就可以直接运行脚本了</p><p><strong>用户登录时，登录shell调用的初始化文件和脚本的次序依次是：/etc/profile,/etc/profile.d目录下的脚本、$HOME/.bash_profile,$HOME/.bashrc和/etc/bashrc</strong></p><h3 id="shell中变量类型"><a href="#shell中变量类型" class="headerlink" title="shell中变量类型"></a>shell中变量类型</h3><p><strong>shell中变量类型有系统变量和用户自定义变量两种：</strong></p><p><code>env/printenv</code> ：查看当前shell的所有系统变量和用户自定义变量</p><h4 id="如何定义变量和给变量赋值"><a href="#如何定义变量和给变量赋值" class="headerlink" title="如何定义变量和给变量赋值"></a>如何定义变量和给变量赋值</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">varname=varvalue</span><br></pre></td></tr></table></figure><p>注意等号的周围不要有任何的空格，否则会报command not found的错误</p><p>可以将任意字符集合赋值给一个变量，比如<strong>给一个变量赋值一个字符串</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=xiaowang 或者 username=<span class="string">"xiaowang"</span></span><br></pre></td></tr></table></figure><p>给变量赋值一个数字值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var=1</span><br></pre></td></tr></table></figure><p>使用变量通过$符号，</p><p>比如上面定义好了变量var，使用的时候，通过$var即可使用</p><p><strong>默认情况下shell赋值是字符串赋值</strong>：比如下面示例，说明var变量被当做字符串了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=1</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var+1</span></span><br><span class="line">1+1</span><br></pre></td></tr></table></figure><p>在Bash中，如果要将算数表达式的数值赋给一个变量，可以使用<code>let</code>命令，如下示例(注意下面的区别)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># let age=1</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $age+1</span></span><br><span class="line">1+1</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># let age=1+1</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $age</span></span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="将一个变量的值赋值给另一个变量："><a href="#将一个变量的值赋值给另一个变量：" class="headerlink" title="将一个变量的值赋值给另一个变量："></a><strong>将一个变量的值赋值给另一个变量</strong>：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># a=3</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># b=$a</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $b</span></span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="将命令的执行结果赋值给变量（注意命令使用倾斜的单引号括起来）："><a href="#将命令的执行结果赋值给变量（注意命令使用倾斜的单引号括起来）：" class="headerlink" title="将命令的执行结果赋值给变量（注意命令使用倾斜的单引号括起来）："></a><strong>将命令的执行结果赋值给变量</strong>（<strong>注意命令使用倾斜的单引号括起来</strong>）：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># pwd</span></span><br><span class="line">/root</span><br><span class="line"><span class="comment">#下面例子没有使用倾斜双引号``，结果还是字符串赋值</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var='pwd'</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"><span class="comment">#下面例子是正确的赋值操作</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=`pwd`</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">/root</span><br><span class="line"><span class="comment">#使用$()将命令包起来也是正确的（推荐这种不容易写错）</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=$(pwd)</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure><h4 id="将bash的内置命令read读入的值赋值给变量"><a href="#将bash的内置命令read读入的值赋值给变量" class="headerlink" title="将bash的内置命令read读入的值赋值给变量"></a><strong>将bash的内置命令<code>read</code>读入的值赋值给变量</strong></h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo -n "Enter var:";read var</span></span><br><span class="line">Enter var:123</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure><p>上例的意思是打印内容”Enter var”,不换行，之后再将用户输入的值赋值给变量var，所以我们通过<code>echo $var</code>命令即得到变量var的值</p><h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4><p><strong>变量命名必须以字母，下划线_开头，后面跟字母，数字或者下划线字符，第一个字符不能为数字，中间不能使用？、*等特殊符号</strong></p><p><strong>变量名大小写敏感，不同大小写是不同的变量</strong>，如下例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=123</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># Var=345</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">123</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># ?var=123</span></span><br><span class="line">-bash: ?var=123: <span class="built_in">command</span> not found</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># 1var=123</span></span><br><span class="line">-bash: 1var=123: <span class="built_in">command</span> not found</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># _var=111</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $_var</span></span><br><span class="line">111</span><br></pre></td></tr></table></figure><h4 id="使用echo和printf打印变量的值"><a href="#使用echo和printf打印变量的值" class="headerlink" title="使用echo和printf打印变量的值"></a>使用<code>echo</code>和<code>printf</code>打印变量的值</h4><p>打印显示变量的值除了<code>echo</code>命令外还有<code>printf</code>命令，该命令语法格式如下：printf &lt;FORMAT&gt;  &lt;ARGUMENTS…&gt;即根据指定格式打印参数，具体的允许格式如下：</p><table><thead><tr><th align="center">分类符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">%b</td><td align="center">打印相关参数并解释其中带有反斜杠\的特殊字符</td></tr><tr><td align="center">%q</td><td align="center">以Shell引用的格式打印相关参数，使其可以在标准输入中重用</td></tr><tr><td align="center">%d</td><td align="center">以带符号十进制数的格式打印相关参数</td></tr><tr><td align="center">%i</td><td align="center">与%d相同</td></tr><tr><td align="center">%o</td><td align="center">以无符号八进制数的格式打印相关参数</td></tr><tr><td align="center">%u</td><td align="center">以无符号十进制数的格式打印相关参数</td></tr><tr><td align="center">%x</td><td align="center">以无符号小写十六进制数的格式打印相关参数</td></tr><tr><td align="center">%X</td><td align="center">与%x相同，只是十六进制数为大写</td></tr><tr><td align="center">%f</td><td align="center">以浮点数的格式解析并打印相关参数</td></tr><tr><td align="center">%e</td><td align="center">以双精度浮点数<N>±e<N>的格式打印相关参数</td></tr><tr><td align="center">%E</td><td align="center">与%e相同，只是用大写字母E</td></tr><tr><td align="center">%g</td><td align="center">以%f或%e的格式打印相关参数</td></tr><tr><td align="center">%G</td><td align="center">以%f或%E的格式打印相关参数</td></tr><tr><td align="center">%c</td><td align="center">以字符的格式打印相关参数，并且只打印参数中的第一个字符</td></tr><tr><td align="center">%s</td><td align="center">以字符串的格式打印相关参数</td></tr><tr><td align="center">%n</td><td align="center">指定打印的字符个数</td></tr><tr><td align="center">%%</td><td align="center">打印一个字符”%”</td></tr></tbody></table><p>printf命令的格式用字符串&lt;Format&gt;中还可以使用一些转义字符，如下所示</p><table><thead><tr><th align="center">转义符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\&quot;</td><td align="center">打印双引号</td></tr><tr><td align="center">\NNN</td><td align="center">用八进制的值表示一个ASCII字符，例如\101，即65，表示字符’A’</td></tr><tr><td align="center">\\</td><td align="center">打印一个反斜杠”\“</td></tr><tr><td align="center">\a</td><td align="center">发出告警音</td></tr><tr><td align="center">\b</td><td align="center">删除前一个字符</td></tr><tr><td align="center">\f</td><td align="center">换页符，在某些实现中会清屏，有些会换行</td></tr><tr><td align="center">\n</td><td align="center">换行</td></tr><tr><td align="center">\r</td><td align="center">从行头开始，和换行不一样，仍在本行</td></tr><tr><td align="center">\t</td><td align="center">Tab键</td></tr><tr><td align="center">\v</td><td align="center">竖直tab，和\f相似，不同机器显示有所不同，通常会引起换行</td></tr><tr><td align="center">\xHH</td><td align="center">用十六进制的值表示一个ASCII字符，例如/x41，即65，表示字符’A’</td></tr></tbody></table><p>下面是一些示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=shell</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%s\n" $var</span></span><br><span class="line">shell</span><br><span class="line"><span class="comment">#指定长度小于实际长度时，按照实际长度打印</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%1s\n" $var</span></span><br><span class="line">shell</span><br><span class="line"><span class="comment">#原点符右边的数字表示打印参数中字符的个数，左边表示打印字符串的总长度</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%1.1s\n" $var</span></span><br><span class="line">s</span><br><span class="line"><span class="comment">#当左边要求打印的总长度超过输出实际长度时，左边用空格补全</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%10.4s\n" $var</span></span><br><span class="line">      shel</span><br><span class="line"> </span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># str=123.45678</span></span><br><span class="line"><span class="comment">#打印的数值长度为5，保留小数点后1位数字</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%5.1f\n" $str</span></span><br><span class="line">123.5</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%5.2f\n" $str</span></span><br><span class="line">123.46</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%5.3f\n" $str</span></span><br><span class="line">123.457</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%2.3f\n" $str</span></span><br><span class="line">123.457</span><br><span class="line"><span class="comment">#小数点后不够的补零</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%2.8f\n" $str</span></span><br><span class="line">123.45678000</span><br><span class="line"><span class="comment">#打印的数值长度为9，数值的实际长度为7，保留小数点后3位，左边用空格补齐</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># printf "%9.3f\n" $str</span></span><br><span class="line">  123.457</span><br></pre></td></tr></table></figure><p>echo命令没有提供格式化的选项，但是支持转义符功能，在使用转义符时需要使用”-e”选项激活转义字符功能，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo -e "SHELL: $SHELL\n User：$USER\t"</span></span><br><span class="line">SHELL: /bin/bash</span><br><span class="line"> User：root</span><br></pre></td></tr></table></figure><p>有时需要通过${}来避免一些歧义，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo "the shell path is $SHELL haha"</span></span><br><span class="line">the shell path is /bin/bash haha</span><br><span class="line"><span class="comment">#下面的指令，shell会去查找SHELLhaha这个变量，没有找到所以打印出来为空</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo "the shell path is $SHELLhaha"</span></span><br><span class="line">the shell path is</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo "the shell path is $&#123;SHELL&#125;haha"</span></span><br><span class="line">the shell path is /bin/bashhaha</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo "the shell path is $&#123;SHELL&#125;/haha"</span></span><br><span class="line">the shell path is /bin/bash/haha</span><br></pre></td></tr></table></figure><h4 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h4><p>引用变量时，最好将变量用双引号””括起来，比如”$var”以免变量中的特殊字符（除$、和\）被错误解释。使用双引号可以防止变量中由多个单词组成的字符串分离，一个用双引号括起来的变量使它自身变成一个单词，即使它包含空格，请看如下例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将变量LIST的值分成了三个参数传递给了for循环</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># LIST="ONE TWO THREE"</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># for var in $LIST</span></span><br><span class="line"><span class="keyword">&gt; do</span></span><br><span class="line"><span class="keyword">&gt; echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">&gt; done</span></span><br><span class="line">ONE</span><br><span class="line">TWO</span><br><span class="line">THREE</span><br><span class="line"><span class="comment">#将变量LIST的值作为一个整体传递给了for循环</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># for var in "$LIST"</span></span><br><span class="line"><span class="keyword">&gt; do</span></span><br><span class="line"><span class="keyword">&gt; echo</span> <span class="variable">$var</span></span><br><span class="line"><span class="keyword">&gt; done</span></span><br><span class="line">ONE TWO THREE</span><br></pre></td></tr></table></figure><p><strong>只有变量的值中包含空格或要保留其中的空格时，将变量用双引号括起来才是必要的</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#$(echo '"')相当于'echo '"''</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo "$(echo '"')"</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure><p><strong>单引号的操作类似于双引号，只是它不允许引用变量，因为在单引号中字符”$”的特殊含义会失效</strong></p><h4 id="export语句的使用"><a href="#export语句的使用" class="headerlink" title="export语句的使用"></a>export语句的使用</h4><p><strong>用户登录到Linux系统后，系统将启动一个用户shell。在这个shell中，可以使用shell命令或声明变量，也可以创建并运行</strong>shell脚本程序。运行shell脚本程序时，系统将创建一个子shell。此时，系统中将有两个shell，一个是登录时系统启动的shell，另一个是系统为运行脚本程序创建的shell。当一个脚本程序运行完毕，脚本shell将终止，返回到执行该脚本之前的shell。</p><p>从这种意义上来说，用户可以有许多 shell，每个shell都是由某个shell（称为父shell）派生的。在子shell中定义的变量只在该子shell内有效。如果在一个shell脚本程序中定义了一个变量，当该脚本程序运行时，这个定义的变量只是该脚本程序内的一个局部变量，其他的shell不能引用它，要使某个变量的值可以在其他shell中被改变，可以使用<code>export</code>命令对已定义的变量进行输出。</p><p><code>export</code>命令将使系统在创建每一个新的shell时，定义这个变量的一个拷贝。这个过程称之为变量输出。</p><p><code>export</code> <strong>功能说明：</strong>设置或显示环境变量。<br><strong>语　　法：</strong>export  -fnp  变量名称=变量设置值<br><strong>补充说明：</strong>在shell中执行程序时，shell会提供一组环境变量。export可新增，修改或删除环境变量，供后续执行的程序使用。export的效力仅限于该次登陆操作。<br><strong>参　　数：</strong><br>　-f 　代表[变量名称]中为函数名称。<br>　-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。<br>　-p 　列出所有的shell赋予程序的环境变量。</p><p>　所以得出的结论是：</p><p>1、执行脚本时是在一个子shell环境运行的，脚本执行完后该子shell自动退出；</p><p>2、一个shell中的系统环境变量会被复制到子shell中（用export定义的变量）；</p><p>3、一个shell中的系统环境变量只对该shell或者它的子shell有效，该shell结束时变量消失（并不能返回到父shell中）。</p><p>4、不用export定义的变量只对该shell有效，对子shell也是无效的。</p><p>例如linux上配置java_home之后需要在/etc/profilewen文件尾部添加如下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/software/java/jdk1.8.0_231</span><br><span class="line"><span class="built_in">export</span> JRE_HOME=<span class="variable">$&#123;JAVA_HOME&#125;</span>/jre</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$&#123;JAVA_HOME&#125;</span>/lib:<span class="variable">$&#123;JRE_HOME&#125;</span>/lib</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;JAVA_HOME&#125;</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><h4 id="如何删除变量"><a href="#如何删除变量" class="headerlink" title="如何删除变量"></a>如何删除变量</h4><p><code>unset</code>命令用来删除相应的变量或者函数，该命令会把变量从当前shell和后续命令的环境中删除，语法如下：unset  -fv  变量或函数名称</p><p>-f     表示删除一个已定义的函数；-v    删除一个变量，使用 示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME= /usr/<span class="built_in">local</span>/jdk</span><br><span class="line"><span class="built_in">unset</span> JAVA_HOME</span><br><span class="line"></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># var=123</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">123</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># unset var</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line"></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>使用unset命令不能删除一个只读的变量，会报错，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># readonly var=234</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $var</span></span><br><span class="line">234</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># unset var</span></span><br><span class="line">-bash: <span class="built_in">unset</span>: var: cannot <span class="built_in">unset</span>: <span class="built_in">readonly</span> variable</span><br></pre></td></tr></table></figure><h4 id="如何检查变量是否存在"><a href="#如何检查变量是否存在" class="headerlink" title="如何检查变量是否存在"></a>如何检查变量是否存在</h4><p>使用如下的语法来检查变量是否存在：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;varName?Error:The variable is not defined&#125;</span></span><br><span class="line"><span class="variable">$&#123;varName:?Error:The variable is not defined&#125;</span></span><br></pre></td></tr></table></figure><p>上述第一句中，如果变量varName已定义且不为空，则该语句相当于$varName;<strong>如果变量置为空，则该语句也为空</strong>；如果变量未定义，则此语句返回一个错误，显示？和后面的错误信息”Error:The variable is not defined”</p><p>第二句和第一句的唯一区别是，如果varName的值是空的，此语句也将返回一个错误</p><p>这两句可以用来检查脚本的完整性，如果变量未定义，脚本将会停止执行，如下例子</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># age=123</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age?Error&#125;</span></span><br><span class="line">123</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># unset age</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age?Error&#125;</span></span><br><span class="line">-bash: age: Error</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># age=321</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age:?Error&#125;</span></span><br><span class="line">321</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># unset age</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age:?Error&#125;</span></span><br><span class="line">-bash: age: Error</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># age=456</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># age=""</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age?Error&#125;</span></span><br><span class="line"></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $&#123;age:?Error&#125;   带冒号的语法当值为空时也会报错</span></span><br><span class="line">-bash: age: Error</span><br></pre></td></tr></table></figure><h2 id="shell环境进阶"><a href="#shell环境进阶" class="headerlink" title="shell环境进阶"></a>shell环境进阶</h2><p>标准命令为什么在shell的任何路径都能执行？这是因为shell在path环境变量指定的全部路径中搜索任何可执行文件，一旦找到与输入项匹配的命令就执行，下面进行进一步了解。</p><h3 id="回调命令历史"><a href="#回调命令历史" class="headerlink" title="回调命令历史"></a>回调命令历史</h3><p>曾经执行过的命令，会被保存在缓冲区或者默认文件~/.bash_history中，保存命令的多少由环境变量<code>HISTSIZE</code>定义。</p><ul><li>可以使用<code>history</code>命令显示你之前执行过的命令</li><li>可以在命令行提示符下使用上下方向键查找之前执行的命令</li><li>可以在命令行提示符下按ctrl+r组合键后输入相应的关键字，可以搜索历史命令</li><li>可以简单的输入！！来重复执行上一条执行过的命令</li><li>！关键字 可以查找最近一次执行的以关键字开头的命令</li><li>可以使用history列出历史命令之后，使用对应的行号执行命令，如下：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># history</span></span><br><span class="line"> ...</span><br><span class="line"> 1041  <span class="built_in">echo</span> <span class="variable">$&#123;age?Error&#125;</span></span><br><span class="line"> 1042  <span class="built_in">echo</span> <span class="variable">$&#123;age:?Error&#125;</span></span><br><span class="line"> 1043  <span class="built_in">history</span></span><br><span class="line"> 1044  ls</span><br><span class="line"> 1045  uptime</span><br><span class="line"> 1046  <span class="built_in">unset</span> age</span><br><span class="line"> 1047  <span class="built_in">history</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># !1045</span></span><br><span class="line">uptime</span><br><span class="line"> 12:44:07 up 58 days, 19:18,  1 user,  load average: 0.00, 0.01, 0.05</span><br></pre></td></tr></table></figure><h3 id="shell中的扩展"><a href="#shell中的扩展" class="headerlink" title="shell中的扩展"></a>shell中的扩展</h3><p>shell中扩展方式有八种（按照扩展的先后顺序排序）：大括号扩展、波浪号扩展、参数和变量扩展、命令替换、算数扩展、进程替换、单词拆分和文件名扩展，下面介绍几种扩展：</p><h4 id="大括号扩展"><a href="#大括号扩展" class="headerlink" title="大括号扩展"></a><strong>大括号扩展</strong></h4><p>看如下例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo a&#123;b,c,d&#125;e</span></span><br><span class="line">abe ace ade</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;1..10&#125;</span></span><br><span class="line">1 2 3 4 5 6 7 8 9 10</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;a..z&#125;</span></span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;5..-3&#125;</span></span><br><span class="line">5 4 3 2 1 0<span class="params"> -1</span><span class="params"> -2</span><span class="params"> -3</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;g..z&#125;</span></span><br><span class="line">g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;1..3&#125; &#123;a..c&#125;</span></span><br><span class="line">1 2 3 a b c</span><br><span class="line"><span class="comment">#注意两个扩展之间有空格和没空格的区别</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;1..3&#125;&#123;a..c&#125;</span></span><br><span class="line">1a 1b 1c 2a 2b 2c 3a 3b 3c</span><br><span class="line"><span class="comment">#大括号还可以嵌套，嵌套结果按照顺序展示</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo a&#123;&#123;b,c,d&#125;a,&#123;e,f,g&#125;b,h&#125;i</span></span><br><span class="line">abai acai adai aebi afbi agbi ahi</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;a,b&#123;1..3&#125;,c&#125;</span></span><br><span class="line">a b1 b2 b3 c</span><br></pre></td></tr></table></figure><p>此外bash还提供了一些按照固定步长扩展的功能，格式为{start，end，incre}</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;1..9..4&#125;</span></span><br><span class="line">1 5 9</span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;1..9..3&#125;</span></span><br><span class="line">1 4 7</span><br><span class="line"><span class="comment">#如果START和end为整数且有0先导时，输出的内容会通过在前面补零达到相同位数</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo &#123;0001..10..3&#125;</span></span><br><span class="line">0001 0004 0007 0010</span><br></pre></td></tr></table></figure><p>大括号扩展在其他所有扩展之前进行，在其他扩展中的特殊字符都被保留下来。为了避免被认为是大括号拓展的一部分，”{“或者”,”可以用反斜杠转义，为了避免与参数扩展冲突，大括号扩展不会识别字符串中的”${“</p><h4 id="波浪号扩展"><a href="#波浪号扩展" class="headerlink" title="波浪号扩展"></a><strong>波浪号扩展</strong></h4><p>波浪号前缀”<del>+”,会被SHELL变量PWD的值替代;”</del>-“会被LODPWD替代</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo ~+</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure><h4 id="命令替换"><a href="#命令替换" class="headerlink" title="命令替换"></a><strong>命令替换</strong></h4><p>命令替换是指用命令的输出替换命令本身，命令替换有两种形式：<code>$(COMMAND)</code>或者`COMMAND`</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo $(pwd)</span></span><br><span class="line">/root</span><br><span class="line"><span class="comment">#注意此处是``倾斜的单括号，类似于前述的将命令的执行结果赋值给变量</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo 'pwd'</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># echo `pwd`</span></span><br><span class="line">/root</span><br></pre></td></tr></table></figure><p>命令替换可以嵌套，使用反引号形式”``”嵌套时，里面的反引号需要用反斜杠\转义</p><h4 id="文件名扩展"><a href="#文件名扩展" class="headerlink" title="文件名扩展"></a><strong>文件名扩展</strong></h4><p> 如果bash中没有设置-f选项，就会支持文件名拓展。bash支持一下三种通配符来实现文件名拓展：</p><ul><li>* 匹配任何字符串也包括空字符串</li><li>？匹配任意单个字符</li><li>[…]匹配方括号内的任意字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ls</span></span><br><span class="line">a.txt  bin  b.txt  etc  games  include  lib  lib64  libexec  <span class="built_in">local</span>  logs  sbin  share  src  tmp  works</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ls *.txt</span></span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ls [ab].txt</span></span><br><span class="line">a.txt  b.txt</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ls [a].txt</span></span><br><span class="line">a.txt</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ls ?.txt</span></span><br><span class="line">a.txt  b.txt</span><br></pre></td></tr></table></figure><h4 id="创建和使用别名"><a href="#创建和使用别名" class="headerlink" title="创建和使用别名"></a>创建和使用别名</h4><p>在文件<code>~/.bashrc</code>中可以为一些命令语句创建别名，一旦修改了这个文件必须重新登录shell才会生效</p><p>创建别名通过内置命令<code>alias</code>，语法如下：alias name=’command’</p><ul><li>name—用户定义的别名     command—任意linux命令</li></ul><p>如下例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -i'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -i'</span></span><br></pre></td></tr></table></figure><p>通过命令<code>alias</code>可以查看所有的别名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># alias</span></span><br><span class="line"><span class="built_in">alias</span> cp=<span class="string">'cp -i'</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">'egrep --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">'fgrep --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">'grep --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">'ls -d .* --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">'ls -l --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> ls=<span class="string">'ls --color=auto'</span></span><br><span class="line"><span class="built_in">alias</span> mv=<span class="string">'mv -i'</span></span><br><span class="line"><span class="built_in">alias</span> rm=<span class="string">'rm -i'</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">'alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'</span></span><br></pre></td></tr></table></figure><p>查看某个特定别名语法为：<code>alias  别名</code>,当想调用实际命令而暂停使用别名是，需要使用如下方法：<code>\aliasname</code>,删除一个别名的语法为：<code>unalias 别名</code>，删除当前环境中所有别名 <code>unalias -a</code></p><p>注意别名请谨慎使用</p><h4 id="修改bash提示符"><a href="#修改bash提示符" class="headerlink" title="修改bash提示符"></a>修改bash提示符</h4><p>登录shell后，bash前面的提示符<code>[root@iZ23kwr96m6Z ~]#</code>是可以定制修改的，通过export  变量PS1即可，非重点内容此处不详述了。</p><h2 id="常用shell（bash）命令"><a href="#常用shell（bash）命令" class="headerlink" title="常用shell（bash）命令"></a>常用shell（bash）命令</h2><h3 id="查看文件和目录"><a href="#查看文件和目录" class="headerlink" title="查看文件和目录"></a>查看文件和目录</h3><h4 id="ls-ll"><a href="#ls-ll" class="headerlink" title="ls/ll"></a>ls/ll</h4><p><code>ls</code>列出当前目录下所有文件和目录，不带详细信息（文件类型，大小，修改日期和时间，权限等）</p><p><code>ls -l</code>每行显示一条记录，包括文件类型，大小，修改日期和时间，权限等</p><p><code>ls -lh</code> 文件大小显示为更符合人类阅读习惯的格式</p><p><code>ls -a</code>列出包含隐藏文件或目录，包括”.”(当前目录)和”..”(父目录)</p><p><code>ls -A</code>列出不包括”.”(当前目录)和”..”(父目录)的所有文件和目录</p><p><code>ls -i</code>显示文件或目录的inode编号</p><p><code>ll</code>命令同<code>ls -l</code></p><h4 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span>切换目录</span><br><span class="line"><span class="built_in">cd</span> /usr<span class="comment">#切换到usr目录</span></span><br><span class="line"><span class="built_in">cd</span> ..<span class="comment">#切换到上一层目录</span></span><br><span class="line"><span class="built_in">cd</span> /<span class="comment">#切换到系统根目录</span></span><br><span class="line"><span class="built_in">cd</span> ~<span class="comment">#切换到用户主目录</span></span><br><span class="line"><span class="built_in">cd</span> -<span class="comment">#切换到上一个所在目</span></span><br></pre></td></tr></table></figure><h4 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h4><p>pwd：显示当前的目录</p><h4 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h4><p><code>cat</code>命令，cat可以查看文件，语法为<code>cat 文件名</code>，此外利用cat命令可以将两个文件合成一个文件输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ll</span></span><br><span class="line">total 184</span><br><span class="line">...</span><br><span class="line">-rw-r--r--.   1 root root     6 Jun 22 19:28 a.txt</span><br><span class="line">-rw-r--r--.   1 root root     4 Aug 14 17:02 b.txt</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># cat a.txt b.txt &gt;c.txt</span></span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># ll</span></span><br><span class="line">-rw-r--r--.   1 root root     6 Jun 22 19:28 a.txt</span><br><span class="line">-rw-r--r--.   1 root root     4 Aug 14 17:02 b.txt</span><br><span class="line">-rw-r--r--.   1 root root    10 Aug 14 17:02 c.txt</span><br><span class="line">[root@iZ23kwr96m6Z usr]<span class="comment"># cat c.txt</span></span><br><span class="line">shfub</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><h4 id="less-more"><a href="#less-more" class="headerlink" title="less/more"></a>less/more</h4><p><code>less、more</code>命令示例：分屏显示文件</p><p><code>more</code>命令一次查看一整屏内容，查看文件语法为<code>more 文件</code>，使用空格可以向下翻页<code>more -num 文件</code>可以控制一次显示num行；</p><p><code>less</code>命令向前或者向后翻页都支持，less命令不需要在查看前加载整个文件，查看文件更快速，查看文件语法为<code>less 文件名</code></p><p>当使用less命令打开文件后，可以使用搜索功能，搜索指定关键字，搜索到会高亮关键字：</p><ul><li><p><code>/关键字</code>回车后，自动跳转到关键字第一次出现的地方，并且高亮所有关键字</p><p>n，向前跳转到上一个匹配关键字的地方</p><p>N，向后跳转到下一个匹配关键字的地方</p></li><li><p><code>？关键字</code>回车后，向后搜索关键字</p><p>n，向后跳转到上一个匹配关键字的地方</p><p>N，向前跳转到下一个匹配关键字的地方</p></li></ul><p><strong>使用less命令浏览较大文件时，可以使用如下屏幕导航命令：</strong></p><p><code>Ctrl+F</code>—向前翻一个窗口的内容</p><p><code>Ctrl+B</code>—向后翻一个窗口的内容</p><p><code>Ctrl+D</code>—向前翻半个窗口的内容</p><p><code>Ctrl+U</code>—向后翻半个窗口的内容</p><p>g—跳转到文件的开头；G—跳转到文件的末尾；q或ZZ—退出less</p><p><strong>less命令还可以打开多个文件，在多个文件中切换，以及标记某个位置以便后续返回，这里不详述</strong></p><h4 id="head-tail"><a href="#head-tail" class="headerlink" title="head/tail"></a>head/tail</h4><p><code>head</code>命令用于打印前几行，默认打印前10行，可以通过-n指定打印多少行，语法为<code>head -n 5 文件</code>也可以不使用-n选项，直接<code>head -5 文件名</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印出除最后五行外所有内容</span></span><br><span class="line">head<span class="params"> -n</span><span class="params"> -5</span> 文件</span><br><span class="line"><span class="comment">#打印文件前n个字节的数据</span></span><br><span class="line">head<span class="params"> -c</span> 10 文件</span><br><span class="line"><span class="comment">#打印文件除最后n个字节的数据</span></span><br><span class="line">head<span class="params"> -c</span><span class="params"> -10</span> 文件</span><br></pre></td></tr></table></figure><p><code>tail</code>命令用于显示后几行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#打印文件的后N行</span></span><br><span class="line">tail<span class="params"> -n</span> 10 文件</span><br><span class="line"><span class="comment">#即时打印文件的后n行</span></span><br><span class="line">tail<span class="params"> -f</span> 文件</span><br><span class="line"><span class="comment">#在特定进程结束时终结tail命令</span></span><br><span class="line">tail<span class="params"> -f</span> 文件<span class="params"> --pid</span> pidnum</span><br></pre></td></tr></table></figure><p>####file</p><p><code>file</code>命令用于查看文件类型，语法<code>file 文件</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用-i，可以以MIME类型的格式显示文件类型的信息</span></span><br><span class="line">file<span class="params"> -i</span> 文件</span><br></pre></td></tr></table></figure><h4 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h4><p><code>wc</code>命令用于查看文件的行数、单词数和字符数等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wc 文件</span><br><span class="line"><span class="keyword">#X</span>表示行数 Y表示单词树 Z表示字节数</span><br><span class="line">X Y Z 文件名</span><br></pre></td></tr></table></figure><p>此外，使用-l选项，可以值统计文件的行数，-w统计单词数，-c统计字节数，-L统计文件中最长的行的长度</p><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><p><code>find</code>命令用于查找文件或者目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">find 路径<span class="params"> -name</span> 文件名</span><br><span class="line">find /root<span class="params"> -name</span> redis.conf</span><br><span class="line"><span class="comment">#在当前目录下查找</span></span><br><span class="line">find .<span class="params"> -name</span> 文件名</span><br><span class="line"><span class="comment">#在当前目录下不区分大小写查找文件</span></span><br><span class="line">find .<span class="params"> -iname</span> 文件名</span><br><span class="line"><span class="comment">#在当前目录下查找文件类型是目录的文件</span></span><br><span class="line">find .<span class="params"> -type</span> d<span class="params"> -name</span> 文件名</span><br><span class="line"><span class="comment">#在当前目录下找到所有的sh文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -name</span> *.sh</span><br><span class="line"><span class="comment">#在当前目录下找到文件权限是777的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -perm</span> 777</span><br><span class="line"><span class="comment">#在当前目录下找到文件权限不是777的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f !<span class="params"> -perm</span> 777</span><br><span class="line"><span class="comment">#在当前目录下找到所有只读文件</span></span><br><span class="line">find .<span class="params"> -type</span> f !<span class="params"> -perm</span> /a+w</span><br><span class="line"><span class="comment">#在当前目录下找到所有可执行文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -perm</span> /a+x</span><br><span class="line"><span class="comment">#找到当前目录下的.log文件并将其删除</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -name</span> <span class="string">"*.log"</span><span class="params"> -exec</span> rm<span class="params"> -f</span> &#123;&#125; \</span><br><span class="line"><span class="comment">#找到当前目录下的所有空目录</span></span><br><span class="line">find .<span class="params"> -type</span> d<span class="params"> -empty</span></span><br><span class="line"><span class="comment">#找到当前目录下所有者是root的文件和目录</span></span><br><span class="line">find .<span class="params"> -user</span> root</span><br><span class="line"><span class="comment">#找到当前目录下所有者是root的文件和目录</span></span><br><span class="line">find .<span class="params"> -group</span> root</span><br><span class="line"><span class="comment">#找出当前目录下，三天前修改过的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -mtime</span> 3</span><br><span class="line"><span class="comment">#找出当前目录下，三天内修改过的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -mtime</span><span class="params"> -3</span></span><br><span class="line"><span class="comment">#找出当前目录下，三十天以前，六十天以内修改过的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -mtime</span> +30<span class="params"> -mtime</span><span class="params"> -60</span></span><br><span class="line"><span class="comment">#找出当前目录下，一小时以内变更过的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -cmin</span><span class="params"> -60</span></span><br><span class="line"><span class="comment">#找出当前目录下，一小时以内访问过的文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -amin</span><span class="params"> -60</span></span><br><span class="line"><span class="comment">#找出当前目录下，大于50MB小于100MB的所有文件</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -size</span> +50MB<span class="params"> -size</span><span class="params"> -100MB</span></span><br><span class="line"><span class="comment">#找出当前目录下，大于100MB的文件并将其删除</span></span><br><span class="line">find .<span class="params"> -type</span> f<span class="params"> -size</span> +100MB<span class="params"> -exec</span> rm<span class="params"> -rf</span> &#123;&#125; \</span><br></pre></td></tr></table></figure><h4 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h4><p><code>touch</code>命令可用于创建文件，语法为<code>touch 文件名</code>，可以同时创建多个文件<code>touch 文件1 文件2 文件3</code>，touch命令有如下选项：</p><ul><li>-a：只改变访问时间 -c：不创建任何文件 -m：只改变修改时间 -r：使用指定文件的时间替代当前时间</li></ul><h4 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h4><p><code>mkdir</code> ：创建新的目录，语法为<code>mkdir 目录名</code>，使用-p可以递归创建目录（父目录不存在自动创建）<code>mkdir /a/b/c</code>,使用-m选项，可以设置创建的目录的权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir<span class="params"> -p</span><span class="params"> -m</span> 777 /a/b</span><br><span class="line">mkdir<span class="params"> -p</span><span class="params"> -m</span> a=rwx /a/b</span><br></pre></td></tr></table></figure><h4 id="rmdir"><a href="#rmdir" class="headerlink" title="rmdir"></a>rmdir</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rmdir <span class="comment">#删除一个空的目录</span></span><br><span class="line">rmdir d <span class="comment">#删除目录 注意只能删除空目录</span></span><br></pre></td></tr></table></figure><h4 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h4><p><code>cp</code>复制文件或目录，语法为<code>cp /路径a/文件a   /路径b/文件名</code>，使用-p选项，可以保留源文件的所有者，用户组，权限，修改和访问时间等信息，使用-R或者-r可以递归复制一个目录</p><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><p>对于通过ssh连接的服务器，复制文件命令，比如登录跳板机将jar包赋值给其他服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp ./*****.jar  root@ip:/usr/works/target_***/</span><br></pre></td></tr></table></figure><h4 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h4><p><code>mv</code>命令用于将文件和目录从一个位置移到另一个位置，还可以用于修改文件或目录的名字，语法为<code>mv source target</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前目录下的文件source.txt移动到/tmp下</span></span><br><span class="line">mv ./<span class="built_in">source</span>.txt /tmp</span><br><span class="line"><span class="comment">#将目录dir1，dir2移动到目录/target下</span></span><br><span class="line">mv dir1 dir2 /target</span><br><span class="line"><span class="comment">#将当前文件名更改</span></span><br><span class="line">mv old.txt new.txt</span><br></pre></td></tr></table></figure><p><strong>默认情况下，如果目标文件已经存在，mv命令不会提示，会直接覆盖目标文件，使用-i可以让mv命令重写或覆盖目标文件之前给出提示</strong></p><p>使用mv可以同时移动多个文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将当前目录下的所有文件移动到目录/tmp下</span></span><br><span class="line">mv * /tmp</span><br></pre></td></tr></table></figure><p>如果只想将源目录中有而目标目录中没有的文件，可以使用-u选项</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将dir1中有而dir2中没有的文件移动到dir2</span></span><br><span class="line">mv<span class="params"> -u</span> dir1/* dir2/</span><br></pre></td></tr></table></figure><h4 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h4><p><code>ln</code> 建立软连接或硬连接的命令</p><h4 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h4><p><code>rm</code> 删除文件或目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#同时删除多个文件</span></span><br><span class="line">rm file1 file2 file3</span><br><span class="line"><span class="comment">#使用-i 可以在删除前提示用户确认</span></span><br><span class="line">rm<span class="params"> -i</span> 文件名</span><br><span class="line"><span class="comment">#删除后缀为.doc的文件</span></span><br><span class="line">rm *.doc</span><br><span class="line"><span class="comment">#删除当前目录下所有文件名包含"movie"字符串的文件</span></span><br><span class="line">rm *movie*</span><br></pre></td></tr></table></figure><p><strong>?号用于匹配一个字符</strong></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除当前目录下整个文件名（包含扩展名）只有三个字符的所有文件</span></span><br><span class="line">rm ???</span><br><span class="line"><span class="comment">#删除当前目录下文件拓展名有两个字符的所有文件</span></span><br><span class="line">rm *.??</span><br></pre></td></tr></table></figure><p>[]用于匹配包含括号内任意一个字符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除当前目录下文件名中含有字母a，b，或c的文件</span></span><br><span class="line">rm * [abc]*</span><br><span class="line"><span class="comment">#删除当前目录下文件拓展名是字母c或h的所有文件</span></span><br><span class="line">rm *.[ch]y</span><br></pre></td></tr></table></figure><h3 id="管理文件或目录权限"><a href="#管理文件或目录权限" class="headerlink" title="管理文件或目录权限"></a>管理文件或目录权限</h3><p>当我们使用ls -l或ll命令时，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ23kwr96m6Z ~]<span class="comment"># ls -l</span></span><br><span class="line">total 1369044</span><br><span class="line">-rw-r--r--. 1 root root      66156 Jun 11 17:07 10596.txt</span><br><span class="line">-rw-r--r--. 1 root root      94831 Jun 27  2018 84.txt</span><br><span class="line">drwxr-xr-x. 9 root root       4096 Jan 18  2019 apache-tomcat-7.0.73</span><br><span class="line">drwxr-xr-x. 3 root root       4096 Nov 21  2016 data</span><br></pre></td></tr></table></figure><p>上面输出的第一列的第一个字符表示文件类型（d目录-文件l链接）2-10九个字符（如第一行rw-r–r–）表示三种用户类型的权限，具体如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/linux/per.png" alt="per" title="">                </div>                <div class="image-caption">per</div>            </figure><p>从左至右用1-10这些数字来表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、确定文件类型</span><br><span class="line">当为[ d ]则是目录</span><br><span class="line">当为[ - ]则是文件；</span><br><span class="line">若是[ l ]则表示为链接文档(link file)；</span><br><span class="line">若是[ b ]则表示为装置文件里面的可供储存的接口设备(可随机存取装置)；</span><br><span class="line">若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2、确定属主（该文件的所有者）拥有该文件的权限</span><br><span class="line">[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(execute),要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现减号[ - ]而已</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3、确定属组（所有者的同组用户）拥有该文件的权限</span><br><span class="line">4、确定其他用户拥有该文件的权限</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">其中，第1、4、7位表示读权限，如果用&quot;r&quot;字符表示，则有读权限，如果用&quot;-&quot;字符表示，则没有读权限；</span><br><span class="line">第2、5、8位表示写权限，如果用&quot;w&quot;字符表示，则有写权限，如果用&quot;-&quot;字符表示没有写权限；第3、6、9位表示可执行权限，如果用&quot;x&quot;字符表示，则有执行权限，如果用&quot;-&quot;字符表示，则没有执行权限。</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5、链接数</span><br><span class="line">6、文件所有者</span><br><span class="line">7、文件所属组</span><br><span class="line">8、文件字节大小</span><br><span class="line">9、文件最后修改日期</span><br><span class="line">10、文件名</span><br></pre></td></tr></table></figure><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p><code>chmod</code>命令用于修改权限，语法可以采用符号表达式，也可以用八进制位模式</p><p>使用符号表达式格式如下：</p><blockquote><p>chmod [option]…[ugoa][[+-=][rwxug]][,…] FILE…</p></blockquote><p>其中字母ugoa用于控制那些用户对文件的访问权限将被改变</p><ul><li>u：指文件或目录的所有者</li><li>g：指文件或目录的用户组的成员</li><li>o：指不在文件或目录的用户组中的其他用户</li><li>a：指所有用户，即（ugo）</li></ul><p>当使用符号表达式，不给出ugoa组合时，相当于使用a</p><p>操作符”+-=表示权限的授予或撤销”</p><ul><li>+：选定的权限将被添加</li><li>-：选定的权限将被移除</li><li>=：文件只拥有选定的权限</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#移除用户组成员的写权限</span></span><br><span class="line">chmod g-w 文件名</span><br><span class="line"><span class="comment">#赋予其他用户执行文件的权限</span></span><br><span class="line">chmod o+x 文件名</span><br><span class="line"><span class="comment">#只给文件的所有者写权限</span></span><br><span class="line">chmod u=w 文件名</span><br><span class="line"><span class="comment">#用文件的用户组权限替换文件的所有者权限</span></span><br><span class="line">chmod u=g 文件名</span><br><span class="line"><span class="comment">#赋予所有人对文件读、写和执行的权限</span></span><br><span class="line">chmod ugo+rwx 文件名</span><br></pre></td></tr></table></figure><p>chmod命令的数字模式是用数字来表示读（4），写（2）和执行（1）的权限，每个用户权限组的值就是这三者组合相加得到的八进制数（0-7），如下：</p><ul><li>4：r（读权限）</li><li>2：w（写权限）</li><li>1：x（执行权限）</li><li>表示rwx权限就是4+2+1=7，rw-权限就是4+2+0=6，r–权限就是4+0+0=4，r-x权限就是4+0+1=5</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#赋予所有人对文件读、写和执行的权限</span></span><br><span class="line">chmod 777 文件名</span><br><span class="line"><span class="comment">#赋予文件的所有者和用户组成员读写权限，其他用户只读权限</span></span><br><span class="line">chmod 664 文件名</span><br><span class="line"><span class="comment">#使用-R选项，可以递归修改文件的目录权限</span></span><br><span class="line">chmod<span class="params"> -R</span> 775 目录</span><br><span class="line"><span class="comment">#如果只想修改当前目录下所有智目录的权限，而不修改文件的权限，可以将chmod与find相结合</span></span><br><span class="line">find .<span class="params"> -type</span> d<span class="params"> -exec</span> chmod<span class="params"> -R</span> 775 &#123;&#125; \;</span><br></pre></td></tr></table></figure><h4 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi/vim"></a>vi/vim</h4><p><code>vi&amp;vim</code> ：</p><blockquote><p>vi: 创建文件或编辑文件<br>vi a.txt 创建文件a.txt并进入文档，按下a或者i或者o进入编辑模式，内容写完之后，按下esc键，然后输入命令：<br>:wq 保存并退出<br>注意必须要使用:<br>在Linux下一般使用vi编辑器来编辑文件。vi既可以查看文件也可以编辑文件。<br>三种模式：命令行、插入、底行模式。切换到命令行模式：按Esc键；<br>切换到插入模式：按 i 、o、a键;<br>  i 在当前位置生前插入<br>  I 在当前行首插入<br>  a 在当前位置后插入<br>  A 在当前行尾插入<br>  o 在当前行之后插入一行<br>  O 在当前行之前插入一行</p></blockquote><h4 id="chown-chgrp"><a href="#chown-chgrp" class="headerlink" title="chown/chgrp"></a>chown/chgrp</h4><p><code>chown/chgrp</code>修改文件所有者和用户组</p><h3 id="其他shell命令"><a href="#其他shell命令" class="headerlink" title="其他shell命令"></a>其他shell命令</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">grep:查找符合条件的字符串。用法: grep [选项]... PATTERN [FILE]..</span><br><span class="line">命令:</span><br><span class="line">grep str b.txt 在文件中查找str</span><br><span class="line">grep str b.txt –color 高亮显示</span><br></pre></td></tr></table></figure><h4 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h4><p><code>tar</code></p><blockquote><p>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩<br>一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件<br>格式：tar [参数] 文件<br>常用参数：<br>    -c：创建一个新tar文件<br>    -v：显示运行过程的信息<br>    -f：指定文件名<br>    -z：调用gzip压缩命令进行压缩<br>    -t：查看压缩文件的内容<br>    -x：解开tar文件<br>命令：<br>tar -cvf test1.tar ./*             将当前目录下的所有文件打包为test1.tar<br>tar -cvf test2.tar  b.txt         将指定文件打包到test2.tar<br>tar -zcvf test3.tar.gz  ./*  将当前目录下的所有文件打包并且压缩到test3.tar.gz<br>tar -xvf  test1.tar  解压到当前目录<br>tar -xvf  test3.tar.gz -C aaa  将文件解压到 aaa目录</p></blockquote><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><p><code>df</code> 用于显示文件系统的可用磁盘空间的数量</p><blockquote><p>df列出文件系统的整体磁盘使用量<br>df命令参数功能：检查文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。<br>格式：df [参数] [目录或文件名]<br>常用参数：<br>  -a ：列出所有的文件系统，包括系统特有的 /proc 等文件系统；<br>  -k ：以 KBytes 的容量显示各文件系统；<br>  -m ：以 MBytes 的容量显示各文件系统；<br>  -h ：以人们较易阅读的 GBytes, MBytes, KBytes 等格式自行显示；<br>  -H ：以 M=1000K 取代 M=1024K 的进位方式；<br>  -T ：显示文件系统类型, 连同该 partition 的 filesystem 名称 (例如 ext3) 也列出；<br>  -i ：不用硬盘容量，而以 inode 的数量来显示<br> 命令：<br> df -h     将容量结果以易读的容量格式显示出来<br> df -aT 将系统内的所有特殊文件格式及名称都列出来</p></blockquote><h4 id="du"><a href="#du" class="headerlink" title="du"></a>du</h4><p><code>du</code> ：评估文件空间利用率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看</span><br><span class="line">格式：du [参数] 文件或目录名称</span><br><span class="line">常用参数：</span><br><span class="line">-a ：列出所有的文件与目录容量，因为默认仅统计目录底下的文件量而已。</span><br><span class="line">-h ：以人们较易读的容量格式 (G/M) 显示；</span><br><span class="line">-s ：列出总量而已，而不列出每个各别的目录占用容量；</span><br><span class="line">-S ：不包括子目录下的总计，与<span class="params"> -s</span> 有点差别。</span><br><span class="line">-k ：以 KBytes 列出容量显示；</span><br><span class="line">-m ：以 MBytes 列出容量显示；</span><br><span class="line">命令：</span><br><span class="line">du<span class="params"> -a</span>  将文件的容量也列出来</span><br><span class="line">du<span class="params"> -sm</span> /* 检查根目录底下每个目录所占用的容量</span><br></pre></td></tr></table></figure><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fdisk 是 Linux 的磁盘分区表操作工具</span><br><span class="line">格式：fdisk [参数] 装置名称</span><br><span class="line">常用参数：</span><br><span class="line">-l ：输出后面接的装置所有的分区内容。若仅有 fdisk<span class="params"> -l</span> 时， 则系统将会把整个系统内能够搜寻到的装置的分区均列出来</span><br><span class="line">命令：</span><br><span class="line">fdisk<span class="params"> -l</span> 列出所有分区信息</span><br></pre></td></tr></table></figure><h4 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h4><p><code>ps</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ps 显示进程</span><br><span class="line">命令：</span><br><span class="line">ps -ef显示所有进程</span><br><span class="line">ps -ef | grep ssh   在所有的进程中搜索和ssh相关的</span><br></pre></td></tr></table></figure><h4 id="kill"><a href="#kill" class="headerlink" title="kill"></a>kill</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill 杀掉某个进程,后面跟着进程的id</span><br><span class="line">命令：</span><br><span class="line">kill 1234</span><br><span class="line">kill -9 1234强制干掉1234</span><br></pre></td></tr></table></figure><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将一个命令的输出结果作为另外一个命令的输入</span><br><span class="line">ps 显示进程</span><br><span class="line">ps<span class="params"> -ef</span>显示所有进程</span><br><span class="line">ps<span class="params"> -ef</span> | grep ssh  在所有的进程中搜索和ssh相关的</span><br></pre></td></tr></table></figure><h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service iptables status   查看防火墙状态</span><br><span class="line">service iptables start启动防火墙</span><br><span class="line">service iptables stop关闭防火墙</span><br><span class="line">service iptables restart重启</span><br><span class="line">chkconfig iptables off永久关闭防火墙</span><br><span class="line">chkconfig iptables on永久关闭后重启</span><br></pre></td></tr></table></figure><h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">shutdown -r now 立刻重启</span><br><span class="line">shutdown -r 10 过10分钟自动重启</span><br><span class="line">shutdown -r 20:35 在时间为20:35时候重启</span><br><span class="line">shutdown -c 取消重启</span><br><span class="line">poweroff 立刻关机</span><br><span class="line">shutdown -h now 立刻关机</span><br><span class="line">shutdown -h 10 10分钟后自动关机</span><br></pre></td></tr></table></figure><h4 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ifconfig 查看网络ip地址</span><br><span class="line">ping ip地址  查看是否可以连接某个ip</span><br></pre></td></tr></table></figure><h4 id="后台执行命令"><a href="#后台执行命令" class="headerlink" title="后台执行命令"></a>后台执行命令</h4><h5 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h5><p>cron是执行定时任务的守护进程，在系统处于多用户运行级别时，cron进程会从/etc/init.d中自动启动，进程会在目录/var/spool/cron/crontabs下搜索定时计划任务文件（文件名为创建此任务的账户名），并将找到的定时计划任务载入内存</p><p><strong>/var/spool/cron/crontabs中的定时任务文件不要直接用编译器编辑，使用<code>crontab</code>命令可以检查语法错误。cron进程还会读取/etc/crontab以及/etc/cron.d下的内容。</strong></p><p><code>crontab</code>命令用于创建、修改、删除和查看定时任务。定时任务文件由每行命令组成，每行6个字段，由空格或者制表符分隔，前五个字段表示任务运行的时间，在最后一个字段是任务的命令。</p><p>如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure><p>前五个字段含义依次如下：</p><ul><li>分钟，0-59</li><li>小时，0-23</li><li>日期，1-31</li><li>月份，1-12或Jan-Dec</li><li>星期，0-6或Sun-Sat，0表示星期日</li></ul><p>前五个字段还可以使用如下字符</p><ul><li>星号（*） 匹配所有可能的值，比如”0 6 * * *”表示每天6点</li><li>连字符（-）定义一个范围，比如”0 2 * * 1-5”表示每周一到周五的凌晨两点</li><li>斜杠（/）表示每间隔多少时间，比如”*/5 * * * *”表示每5分钟</li><li>逗号（，）表示或的含义，比如”0 0,6,12,18 * * *”表示每天的0点、6点、12点和18点</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用-l选项，可以列出当前用户的所有定时计划任务</span></span><br><span class="line">crontab<span class="params"> -l</span></span><br><span class="line"><span class="comment">#使用-e选项，可以创建或修改当前用户的定时计划任务</span></span><br><span class="line">crontab<span class="params"> -e</span></span><br><span class="line"><span class="comment">#使用-u选项，可以查看指定用户的定时计划任务</span></span><br><span class="line">crontab<span class="params"> -u</span> root<span class="params"> -l</span></span><br><span class="line"><span class="comment">#使用-r选项，将没有确认信息直接删除当前用户的定时计划任务</span></span><br><span class="line">crontab<span class="params"> -r</span></span><br><span class="line"><span class="comment">#将-i和-r结合在移除前可以提示用户确认</span></span><br><span class="line">crontab<span class="params"> -l</span></span><br><span class="line">00 00 * * * /bin/bash  /usr/<span class="built_in">local</span>/nginx/sbin/cut_nginx_log.sh</span><br><span class="line">crontab<span class="params"> -i</span><span class="params"> -r</span></span><br><span class="line">crontab: really delete root<span class="string">'s crontab?</span></span><br></pre></td></tr></table></figure><h5 id="at"><a href="#at" class="headerlink" title="at"></a>at</h5><p><code>at</code>命令用于安排一个任务在指定的时间运行。at命令可以从标准输入读入命令，也可以从指定的文件中读入，然后在指定的时间运行这些命令。语法如下：</p><blockquote><p>at -f file -q queue option time date</p></blockquote><p>at命令支持比较复杂的时间和日期，使用-f选项，可以从指定的文件中读取命令内容，然后在指定时间运行。如下示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at<span class="params"> -f</span> myjob.txt now +1 minutes</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出当前用户</span></span><br><span class="line">at<span class="params"> -l</span>所有已创建但未执行或正在运行的任务</span><br><span class="line"><span class="keyword">#atq</span>命令功能同at<span class="params"> -l</span></span><br><span class="line"><span class="keyword">#atrm</span>命令可以删除现有的任务，其中1是任务的编号，使用at<span class="params"> -l</span>之后可以展示出来</span><br><span class="line">atrm 1</span><br></pre></td></tr></table></figure><h5 id="amp"><a href="#amp" class="headerlink" title="&amp;"></a>&amp;</h5><p><code>&amp;</code>代表将任务放在后台运行</p><p>该命令是bash内置的用于并行处理进程的一个控制操作符，在命令行的末尾添加<code>&amp;</code>将会在后台运行该命令，将在当前的shell进程下启动一个子进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> haha &amp;</span><br><span class="line">[1] 9533</span><br><span class="line">haha</span><br></pre></td></tr></table></figure><p>其中[1]是这个后台任务的编号，9533为其对应的子进程号。</p><p>使用<code>jobs</code>命令可以显示后台运行的进程号，运行状态等信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">jobs</span></span><br><span class="line">[1]+  Done                    <span class="built_in">echo</span> hah</span><br></pre></td></tr></table></figure><p>如果需要将后台任务放到前台执行，使用如下命令，其中job-id为任务编号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">%job</span>-id</span><br><span class="line">或<span class="built_in">fg</span> job-id</span><br></pre></td></tr></table></figure><p>如果想将任务重新再放回后台执行，首先按Ctrl+Z，将上述放在前台的任务挂起，然后输入<code>%job-id &amp;或bg</code>，其中bg用于将挂起的任务放在后台继续运行。</p><h5 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h5><p><code>nohup</code>命令：</p><p>运行一个对挂起免疫的命令，使用该命令能让你运行的命令或脚本在你退出系统后继续在后台运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#运行一个jar包</span></span><br><span class="line">nohup java<span class="params"> -jar</span> xxx.jar &amp;</span><br><span class="line"><span class="comment">#运行一个脚本</span></span><br><span class="line">nohup sh xxx.sh &amp;</span><br><span class="line">[1] 12496</span><br><span class="line">nohup: appending output to <span class="string">'nohup.out'</span></span><br></pre></td></tr></table></figure><p>上面例子中[1]为任务编号，12496是该后台任务的进程号，后面一句表示该脚本运行的所有输出内容被写入到当前目录下的nohup.out中</p><p><code>sort</code>命令可以对文本进行排序，<code>uniq</code>命令可以文本去重，<code>tr</code>命令替换或删除字符，<code>diff</code>比较两个文件，<code>pwd</code>：显示目前的目录,<code>hostname</code> ：显示当前主机名，使用<code>hostname 新主机名</code>可以修改主机名（只在当前有效，系统重启后不再生效）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">uptime</span><br><span class="line">10:08:20 up 62 days, 16:43,  1 user,  load average: 0.01, 0.04, 0.05</span><br><span class="line"><span class="keyword">#uptime</span> 用于打印系统运行信息，10:08:20表示当前时间，后面表示已运行62天，16小时，43分，当前登录用户一位，load average分别显示过去1分钟，5分钟和15分钟的平均负载</span><br></pre></td></tr></table></figure><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</span><br><span class="line">用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</span><br><span class="line">每个用户账号都拥有一个惟一的用户名和各自的口令。</span><br><span class="line">用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</span><br><span class="line">实现用户账号的管理，要完成的工作主要有如下几个方面：</span><br><span class="line">用户账号的添加、删除与修改。</span><br><span class="line">用户口令的管理。</span><br><span class="line">用户组的管理。</span><br></pre></td></tr></table></figure><h5 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">useradd新增用户</span><br><span class="line">格式：useradd [参数] 用户名称</span><br><span class="line">常用参数：</span><br><span class="line"><span class="params">    -c</span> comment 指定一段注释性描述。</span><br><span class="line"><span class="params">    -d</span> 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line"><span class="params">    -g</span> 用户组 指定用户所属的用户组。</span><br><span class="line"><span class="params">    -G</span> 用户组，用户组 指定用户所属的附加组。</span><br><span class="line"><span class="params">    -s</span> Shell文件 指定用户的登录Shell。</span><br><span class="line"><span class="params">    -u</span> 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br><span class="line">命令</span><br><span class="line">useradd stu    新增用户stu</span><br></pre></td></tr></table></figure><h5 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">passwd给指定的用户设置密码</span><br><span class="line">用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令</span><br><span class="line">格式：passwd [参数] 用户名</span><br><span class="line">常用参数：</span><br><span class="line"><span class="params">  -l</span> 锁定口令，即禁用账号。</span><br><span class="line"><span class="params">  -u</span> 口令解锁。</span><br><span class="line"><span class="params">  -d</span> 使账号无口令。</span><br><span class="line"><span class="params">  -f</span> 强迫用户下次登录时修改口令。</span><br><span class="line">如果默认用户名，则修改当前用户的口令，比如centOS 默认的root账号没有密码，就可以直接使用passwd修改密码即可。</span><br><span class="line">命令：</span><br><span class="line">passwd stu  按下enter键 输入2次密码即可</span><br></pre></td></tr></table></figure><h5 id="userdel"><a href="#userdel" class="headerlink" title="userdel"></a>userdel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">userdel删除用户</span><br><span class="line">命令：</span><br><span class="line">userdel stu 删除指定用户但是用户在home下面的目录保存</span><br><span class="line">userdel<span class="params"> -r</span> stu删除指定用户并且删除对应的home目录</span><br></pre></td></tr></table></figure><h5 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> usermod修改用户信息</span><br><span class="line"> 格式：usermod [参数] </span><br><span class="line">  常用的参数包括-c,<span class="params"> -d</span>,<span class="params"> -m</span>,<span class="params"> -g</span>,<span class="params"> -G</span>,<span class="params"> -s</span>,<span class="params"> -u</span>以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。</span><br><span class="line">  另外，有些系统可以使用选项：-l 新用户名，这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</span><br><span class="line">命令：</span><br><span class="line">usermod stu<span class="params"> -l</span> stu2   将用户名stu重命名为stu2</span><br></pre></td></tr></table></figure><h4 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</span><br><span class="line">用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对&#x2F;etc&#x2F;group文件的更新</span><br></pre></td></tr></table></figure><h5 id="groupadd"><a href="#groupadd" class="headerlink" title="groupadd"></a>groupadd</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">groupadd增加一个新的用户组</span><br><span class="line">格式：groupadd [参数] 用户组名称</span><br><span class="line">常用参数：</span><br><span class="line"><span class="params">  -g</span> GID 指定新用户组的组标识号（GID）。</span><br><span class="line"><span class="params">  -o</span> 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同</span><br><span class="line">命令：</span><br><span class="line">groupadd gp1新增用户组gp1</span><br><span class="line">groupadd<span class="params"> -g</span> 1111 gp2新增用户组gp2,并且组标记号为1111</span><br></pre></td></tr></table></figure><h5 id="groupdel"><a href="#groupdel" class="headerlink" title="groupdel"></a>groupdel</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">groupdel删除一个用户组</span><br><span class="line">格式：groupdel  用户组名称</span><br><span class="line">命令：</span><br><span class="line">groupdel gp1删除用户组gp1</span><br></pre></td></tr></table></figure><h5 id="groupmod"><a href="#groupmod" class="headerlink" title="groupmod"></a>groupmod</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">groupmod修改用户组信息</span><br><span class="line">格式：groupmod [参数] 用户组名称</span><br><span class="line">常用参数：</span><br><span class="line"><span class="params">  -g</span> GID 为用户组指定新的组标识号。</span><br><span class="line"><span class="params">  -o</span> 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line"><span class="params">  -n</span> 新用户组 将用户组的名字改为新名字</span><br><span class="line">  </span><br><span class="line">命令：</span><br><span class="line">groupmod gp2<span class="params"> -n</span> gp5让gp2更名为gp5</span><br></pre></td></tr></table></figure><h5 id="newgrp"><a href="#newgrp" class="headerlink" title="newgrp"></a>newgrp</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">newgrp切换到其他用户组</span><br><span class="line">格式：newgrp 用户组名称</span><br><span class="line">命令：</span><br><span class="line">new grp gp5  切换到gp5</span><br></pre></td></tr></table></figure><h3 id="附图"><a href="#附图" class="headerlink" title="附图"></a>附图</h3><p>最后附一张我关注的一个博主<code>java3y</code>之前总结的脑图，我转成图片放在此处，比较简洁清晰，如有侵权，联系删除：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/linux/command.png" alt="常用命令脑图" title="">                </div>                <div class="image-caption">常用命令脑图</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇博文总结常用的shell命令，比较基础，作为备忘待使用时查阅吧，有问题可及时在本博客或&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/108077742&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;下留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="shell" scheme="https://www.enjoyican.com/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美学习笔记二</title>
    <link href="https://www.enjoyican.com/posts/the-beauty-of-design-pattern-two/"/>
    <id>https://www.enjoyican.com/posts/the-beauty-of-design-pattern-two/</id>
    <published>2020-07-28T11:34:30.000Z</published>
    <updated>2020-07-28T11:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这部分总结了23种设计模式的定义，适用场景，部分设计模式写了小demo来演示。总体来说设计模式一定要注意他的适用场景和实现方式这两点，只关注实现方式，就会觉得好几种设计模式类图差不多，但实际上这几种的应用场景完全不同，如果只关注适用场景，具体写代码还是不会套用，那也是纸上谈兵，总之设计模式常看常新，每次都有不同的体会。有问题可以在本博客下留言或者<a href="https://blog.csdn.net/u010408502/article/details/107677272" target="_blank" rel="noopener">CSDN</a>上留言。</p><a id="more"></a><h1 id="构建型设计模式"><a href="#构建型设计模式" class="headerlink" title="构建型设计模式"></a>构建型设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>如何实现一个单例：</p><ul><li>构造函数需要是private访问权限，避免外部直接new对象</li><li>考虑对象创建时的线程安全问题</li><li>考虑是否支持懒加载</li><li>考虑getInstance()性能是否高（是否加锁） </li></ul><h3 id="饿汉式："><a href="#饿汉式：" class="headerlink" title="饿汉式："></a>饿汉式：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123; </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton(); </span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125; </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">          <span class="keyword">return</span> instance;  </span><br><span class="line">      &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程 安全，调用效率高</p><p>缺点：一上来就实例化了单例，如果该单例从头到尾都没有用到，或者初始化的耗时较长，是一种资源的浪费，不支持懒加载</p><p>不过专栏作者的意见是如果确实初始化耗时较长，反而不如通过饿汉式在项目启动初期就加载好，以免在后面实际使用的时候才加载（懒加载）造成性能损耗，或者用户体验下降</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//类初始化时，不初始化这个对象(延时加载，真正用的时候再创建)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//构造器私有化</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">     </span><br><span class="line">    <span class="comment">//方法同步，调用效率低</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程安全，支持懒加载（即真正使用的时候再去加载）</p><p>缺点：获取单例的方法加锁，性能不高</p><h3 id="双重检测（double-check）模式"><a href="#双重检测（double-check）模式" class="headerlink" title="双重检测（double check）模式"></a>双重检测（double check）模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>优点：即支持懒加载模式，又避免了懒汉式每次调用均加锁造成的性能损耗（只要第一次创建成功后，后续再次调用就不会进入同步方法）。</p><p>缺点：注意singleton成员变量前一定要加volatile关键字，防止指令重排。这么做的目的是避免因为指令重排导致实例被new出来之后（实例化）赋值给singleton变量后还没来得及初始化，就被另外一个线程使用了。<strong>目前高版本的java已经在JDK内部解决了这个问题（通过将new对象和初始化操作设计为原子性操作，即可避免指令重排带来的问题）</strong></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：线程安全，效率高，支持懒加载。由于SingletonHolder是一个静态内部类，当外部类Singleton被加载的时候，并不会创建SingletonHolder实例对象，只有当调用getInstance()方法时，SingletonHolder才会被加载，这个时候才创建instance实例，实例的唯一性，创建过程的线程安全性，都由JVM保证</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举元素本身就是单例</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加自己需要的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">singletonOperation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：通过枚举本身的特点（枚举实例本身就是单例的）保证了创建实例的线程安全性和实例的唯一性。线程安全，调用效率高，不能延时加载，可以天然的防止反射和反序列化调用</p><h3 id="单例模式存在的问题"><a href="#单例模式存在的问题" class="headerlink" title="单例模式存在的问题"></a>单例模式存在的问题</h3><p>大部分情况下，我们使用单例来表示一些全局唯一类，比如配置信息类，连接池类，ID生成器类。</p><p><strong>单例对OOP特性的支持不友好</strong></p><p>由于单例的使用方式基于实现类而非基于接口，将来想要更换一种生成单例的方式，需要变更代码的各个地方，此外单例对继承，多态的支持也不好（不是不能继承，只是这样做比较怪异）</p><p><strong>单例会隐藏类之间的依赖关系</strong></p><p>由于单例的调用是直接调用其对外提供的公共方法，内部去生成实例对象，单例类不需要显式创建，不需要依赖参数传递，在函数中直接调用就可以了，如果代码比较复杂，这种调用关系就会非常隐蔽</p><p><strong>单例对代码的拓展性不友好</strong></p><p>由于单例类只能有一个对象实例，如果将来由于需求变更需要支持多实例，就需要改动较多代码。</p><p><strong>单例对代码的可测试性不友好</strong></p><p><strong>单例不支持有参数的构造函数</strong></p><p>参数的传递需要放在getInstance（）中</p><h3 id="如何替代单例模式"><a href="#如何替代单例模式" class="headerlink" title="如何替代单例模式"></a>如何替代单例模式</h3><p>为了保证全局唯一，除了使用单例，还可以使用静态方法来实现。但是他比单例更加不灵活，比如无法支持懒加载。实际上类对象的全局唯一性可以通过多种方式保证，除了单例模式，还有工厂模式，IOC容器保证 ，或者程序员代码中保证。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>一般情况下工厂模式被分为简单工厂（静态工厂方法模式）、工厂方法和抽象工厂三类。简单工厂和工厂方法原理简单，项目中常用，抽象工厂原理稍微复杂，在项目中不经常用。</p><p>工厂方法相比简单工厂方法，需要更多的类去实现工厂方法接口类，当对象的创建逻辑比较复杂，不只是简单new一下的时候推荐使用工厂模式，将复杂的创建逻辑拆分到各个工厂类中，让每个工厂类不至于过于复杂。</p><p>总结下就是简单工厂将对象创建的不同分支用if、else写在一个工厂类中，工厂方法是将这些分支拆分成不同的工厂类。</p><p>当创建逻辑比较复杂，是一个大工程的时候，就需要考虑使用工厂模式，封装对象的创建，将对象的创建与使用分离开来。</p><p>工厂模式的作用无外乎下面四个，也是我们判断要不要使用工厂模式的标准：</p><ul><li>封装变化：创建逻辑有可能发生变化，封装成工厂类之后，创建逻辑的变更对调用者透明</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁</li></ul><p>以DI容器讲解工厂模式：</p><p>DI容器的核心功能一般有三点：配置解析，对象创建和对象生命周期管理，详情可以看spring源码解析</p><p>下面是简单工厂模式和工厂模式的示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//手机类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobile</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Huawei</span> <span class="keyword">implements</span> <span class="title">IMobile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是华为手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Xiaomi</span> <span class="keyword">implements</span> <span class="title">IMobile</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是小米手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Oppo</span> <span class="keyword">implements</span> <span class="title">IMobile</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是oppo手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//简单工厂类</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单工厂模式</span></span><br><span class="line"><span class="comment"> * 特点，各种类型的类创建并不复杂，把类的创建写在一个工厂类中，</span></span><br><span class="line"><span class="comment"> * 可以通过if，else，或者map获取具体的类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMobile <span class="title">createMobile</span><span class="params">(String brand)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (brand == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (brand.equalsIgnoreCase(<span class="string">"huawei"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Huawei();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (brand.equalsIgnoreCase(<span class="string">"xiaomi"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Xiaomi();</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (brand.equalsIgnoreCase(<span class="string">"oppo"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Oppo();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IMobile mobile = SimpleFactory.createMobile(<span class="string">"huawei"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mobile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mobile.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂方法模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMobileFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IMobile <span class="title">getMobile</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiFcatory</span> <span class="keyword">implements</span> <span class="title">IMobileFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMobile <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//经过一系列复杂的判断，前置条件校验，准备</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Huawei();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiFactory</span> <span class="keyword">implements</span> <span class="title">IMobileFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMobile <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//经过一系列复杂的判断，前置条件校验，准备</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Xiaomi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OppoFactory</span> <span class="keyword">implements</span> <span class="title">IMobileFactory</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMobile <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//经过一系列复杂的判断，前置条件校验，准备</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Oppo();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//实际中可以根据传入的参数获取具体的工厂类</span></span><br><span class="line">        IMobileFactory factory = <span class="keyword">new</span> HuaweiFcatory();</span><br><span class="line">        <span class="comment">//创建手机的逻辑比较复杂，拆分为各种工厂类（示例中比较简单，忽略）</span></span><br><span class="line">        IMobile mobile = factory.getMobile();</span><br><span class="line">        mobile.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式与工厂模式的不同</p><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种对象。建造者模式是用来创建一种类型的复杂对象，通过设置不同的参数，”定制化”地创建不同的对象。</p><p>建造者模式的使用场景：</p><ul><li>当类的构造函数必填属性很多，通过set设置，没有办法校验必填属性</li><li>如果类的属性之间具有一定的依赖关系，构造函数配合set方式，无法进行依赖关系和约束条件校验</li><li>需要创建不可变对象，不能暴露set方法</li></ul><p>实现方式：把构造函数定义为private，定义public static class Builder内部类，通过Builer类的set方法设置属性，调用build方法创建对象。下面是一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*假设数据库连接池参数配置有很多，现在我们通过建造者模式来完成创建DataBaseConnectPoolConfig</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataBaseConnectPoolConfig</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * # 数据库的连接地址。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化时建立的物理连接数。初始化发生在显式调用init方法，或者第一次getConnection时.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer initialSize;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接池最大物理连接数量。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer maxActive;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DataBaseConnectPoolConfig</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = builder.url;</span><br><span class="line">        <span class="keyword">this</span>.userName = builder.userName;</span><br><span class="line">        <span class="keyword">this</span>.password = builder.password;</span><br><span class="line">        <span class="keyword">this</span>.initialSize = builder.initialSize;</span><br><span class="line">        <span class="keyword">this</span>.maxActive = builder.maxActive;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里的builder设置为一个静态内部类，也可以单独拿出去作为一个类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String URLSTRING = <span class="string">"myUrl"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME = <span class="string">"username"</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD = <span class="string">"password"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String url = URLSTRING;</span><br><span class="line">        <span class="keyword">private</span> String userName = USERNAME;</span><br><span class="line">        <span class="keyword">private</span> String password = PASSWORD;</span><br><span class="line">        <span class="keyword">private</span> Integer initialSize;</span><br><span class="line">        <span class="keyword">private</span> Integer maxActive;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> DataBaseConnectPoolConfig <span class="title">build</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (initialSize == <span class="number">5</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"初始化的连接数为5"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//经过一系列的判断等等操作（对set方法之后的数据校验），返回创建好的连接池配置对象</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DataBaseConnectPoolConfig(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.url = url;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setInitialSize</span><span class="params">(Integer initialSize)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.initialSize = initialSize;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxActive</span><span class="params">(Integer maxActive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.maxActive = maxActive;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//模拟客户端通过建造者模式创建连接池配置对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DataBaseConnectPoolConfig config = <span class="keyword">new</span> Builder().setUrl(<span class="string">"http://abc"</span>)</span><br><span class="line">                .setUserName(<span class="string">"zhangsan"</span>).setPassword(<span class="string">"abc"</span>).setInitialSize(<span class="number">5</span>)</span><br><span class="line">                .setMaxActive(<span class="number">5</span>).build();</span><br><span class="line">        System.out.println(config.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p><strong>什么是原型模式</strong></p><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（拷贝）的方式来创建新的对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式叫做原型模式</p><p><strong>原型模式的两种实现方式</strong></p><p>深拷贝和浅拷贝。浅拷贝只复制对象基本数据类型数据和引用对象的内存地址，不会递归的复制引用对象，以及引用对象的引用对象，而深拷贝得到的是一份完全独立的对象，所以深拷贝比浅拷贝更耗时间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没有问题的，但是对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能会出现数据被修改的风险。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，定制化的创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以节省创建时间。</p><h1 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h1><p>结构型模式包括：代理模式，桥接模式，装饰器模式，适配器模式，门面模式，组合模式，享元模式</p><h2 id="代理模式（Proxy-Design-Pattern）"><a href="#代理模式（Proxy-Design-Pattern）" class="headerlink" title="代理模式（Proxy Design Pattern）"></a>代理模式（Proxy Design Pattern）</h2><h3 id="代理模式的应用场景："><a href="#代理模式的应用场景：" class="headerlink" title="代理模式的应用场景："></a>代理模式的应用场景：</h3><p><strong>业务系统的非功能性需求开发</strong></p><p>比如：监控，统计，鉴权，限流，事务，幂等，日志等（AOP就是基于动态代理）</p><p><strong>在RPC/缓存中的使用</strong></p><p>RPC框架也可以看做一种代理模式</p><h2 id="桥接模式（Bridge-Design-Pattern）"><a href="#桥接模式（Bridge-Design-Pattern）" class="headerlink" title="桥接模式（Bridge Design Pattern）"></a>桥接模式（Bridge Design Pattern）</h2><p>对于桥接模式的两种不同的理解：在GOF的《设计模式》中，定义为：”将抽象和实现解耦，让它们可以独立变化”，在其他资料书中，定义为：一个类存在两个（或多个）独立变化的维度，我们通过组合的方式，让这两个（或多个）维度可以独立进行拓展</p><p>对于第一种GOF的定义，理解其中的”抽象”和”实现”两个概念，是理解它们的关键。这里的抽象指的并不是抽象类或者接口，而是被抽象出来的一套”类库”，只包含骨架代码，真正的业务逻辑需要委派给定义中的”实现”来完成。而这里的实现，也并非”接口的实现类”，而是一套独立的类库，抽象和实现独立开发，通过对象之间的组合关系，组装在一起</p><p>对于第二种理解方式，类似于”组合优于继承”的设计原则，通过组合关系来替代继承关系，避免继承层次过多。</p><p>桥接模式的应用，在JDBC中，针对不同的数据库有不同的Driver类，可以按需切换，JDBC只定义接口，具体的实现委托给具体的数据库Driver</p><p>下面以不同线上系统不同紧急程度下消息发送的小例子来展示桥接模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息发送接口类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MsgSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelephoneMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TelephoneMsgSender</span><span class="params">(List&lt;String&gt; telephones)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telephones = telephones;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//具体的发送短信的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//类似于TelephoneMsgSender</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//类似于TelephoneMsgSender</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Notification相当于抽象，MsgSender相当于实现，</span></span><br><span class="line"><span class="comment"> * 两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓的任意组合</span></span><br><span class="line"><span class="comment"> * 的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死，</span></span><br><span class="line"><span class="comment"> * 我们可以动态地去指定（比如通过读取配置来获取对应关系）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> MsgSender msgSender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MsgSender msgSender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSender = msgSender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *严重情况下消息发送类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SevereNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SevereNotification</span><span class="params">(MsgSender msgSender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msgSender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        msgSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">紧急情况下消息发送类（逻辑类似SevereNotification）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrgencyNotification</span><span class="params">(MsgSender msgSender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msgSender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">普通情况下消息发送类（逻辑类似SevereNotification）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalNotification</span><span class="params">(MsgSender msgSender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msgSender);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h2><p>装饰器模式并非简单的利用组合替代继承，它有两个比较特殊的地方：</p><ul><li><strong>装饰类和原始类继承同样的父类</strong>，这样我们可以对原始类”嵌套”多个装饰器类</li><li>装饰类是对功能的增强，这也是装饰器模式应用场景的一个重要特点</li></ul><p>装饰器模式与代理模式的不同点：</p><p>代理类增加的是与原始类没有关系的功能，而装饰类增加的是原始类功能的增强</p><p>下面是一个简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseInterface</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseClass</span> <span class="keyword">implements</span> <span class="title">BaseInterface</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是被装饰者，我要开演唱会"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">BaseInterface</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BaseInterface baseInterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(BaseInterface baseInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.baseInterface = baseInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"演唱会前我先好好锻炼身体，记歌词"</span>);</span><br><span class="line">        <span class="keyword">this</span>.baseInterface.say();</span><br><span class="line">        System.out.println(<span class="string">"演唱会后我要好好复盘"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BaseClass base = <span class="keyword">new</span> BaseClass();</span><br><span class="line">        Decorator decorator = <span class="keyword">new</span> Decorator(base);</span><br><span class="line">        decorator.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="适配器模式（Adapter-Design-Pattern）"><a href="#适配器模式（Adapter-Design-Pattern）" class="headerlink" title="适配器模式（Adapter Design Pattern）"></a>适配器模式（Adapter Design Pattern）</h2><p>适配器模式是用来做适配的，它将不兼容的接口转换为可兼容的接口，让原本由于接口不兼容而不能一起工作的类可以一起工作。举个形象的例子，USB转接头就是生活中的一种适配器</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系实现，对象适配器使用组合关系来实现。</p><p>适配器模式适用场景：</p><p>一般来说，适配器模式可以看做一种”补偿模式”，用来补救设计上的缺陷。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。适配器模式适用于以下场景：</p><ul><li><p>封装有缺陷的接口设计</p><p>假设我们依赖的外部系统在接口设计方面有缺陷，引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望对外部系统提供的接口进行二次封装，抽象出更好的接口设计，这个时候就可以使用适配器模式了。</p></li><li><p>统一多个类的接口设计</p><p>某个功能的实现依赖多个外部系统（或者说类），通过适配器模式，将它们的接口适配为统一的接口定义，然后我们就可以使用多态的特性来复用代码逻辑</p></li><li><p>替换依赖的外部系统</p><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，依靠适配器模式，可以减少对代码的改动</p></li><li><p>兼容老版本接口</p><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为deprecated，并将内部实现逻辑委托为新的接口实现。这样做的好处是，使用它的项目有个过渡期，而不是强制进行代码修改</p></li><li><p>适配不同格式的数据</p></li></ul><p>下面是适配器模式的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要将其他类适配成该目标类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 源类，需要将该类适配成ITarget接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fb</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类适配器，基于继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassAdaptor</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">ITarget</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.fa();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重新实现f2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里的fc不需要实现，直接继承自Adaptee，这是和对象适配器最大的不同</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *对象适配器基于组合</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceAdaptor</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InstanceAdaptor</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.fa();<span class="comment">//委托给Adaptee</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//重新实现f2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        adaptee.fc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代理、桥接、装饰器、适配器四种设计模式的区别"><a href="#代理、桥接、装饰器、适配器四种设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器四种设计模式的区别"></a>代理、桥接、装饰器、适配器四种设计模式的区别</h3><p>代理，桥接，装饰器，适配器，这四种模式是比较常用的结构型设计模式。它们的代码结构非常相似，笼统来说，都可以成为Wrapper模式，也就是通过Wrapper类二次封装原始类。他们之间的区别如下：</p><p><strong>代理模式：</strong>代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</p><p><strong>桥接模式：</strong>桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、相对独立的加以改变</p><p><strong>装饰器模式：</strong>装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰类的嵌套使用</p><p><strong>适配器模式：</strong>适配器模式是一种时候的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口</p><h2 id="门面模式（Facade-Design-Pattern）"><a href="#门面模式（Facade-Design-Pattern）" class="headerlink" title="门面模式（Facade Design Pattern）"></a>门面模式（Facade Design Pattern）</h2><p>门面模式主要用于接口设计方面，GOF的《设计模式》中定义如下：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用，这里的子系统可以有多种理解方式，既可以是一个完整的系统，也可以是更细粒度的类或者模块，门面模式的应用场景如下：</p><ul><li><p>解决易用性问题</p></li><li><p>解决性能问题</p></li><li><p>解决分布式事务问题</p></li></ul><h2 id="组合模式（Composite-Design-Pattern）"><a href="#组合模式（Composite-Design-Pattern）" class="headerlink" title="组合模式（Composite Design Pattern）"></a>组合模式（Composite Design Pattern）</h2><p>组合模式在GOF的《设计模式》中定义如下：将一组对象组织（Compose）成树形结构，以表示一种”部分-整体”的层次结构，组合让客户端（代指代码的使用者）可以统一单个对象和组合对象的处理逻辑</p><h2 id="享元模式（Flyweight-Design-Pattern）"><a href="#享元模式（Flyweight-Design-Pattern）" class="headerlink" title="享元模式（Flyweight Design Pattern）"></a>享元模式（Flyweight Design Pattern）</h2><p>享元，顾名思义就是被共享的单元，享元模式的意图是复用对象，节省内存，前提是享元对象是不可变对象。不可变对象指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以不可变对象不能暴露任何set()等修改内部状态的方法。</p><p>Integer类型的缓冲池中保存的-127-128就是一种享元模式的应用，String中常量池也是一种享元模式</p><h1 id="行为型设计模式"><a href="#行为型设计模式" class="headerlink" title="行为型设计模式"></a>行为型设计模式</h1><p>创建型设计模式主要解决”对象的创建”问题，结构型设计模式主要解决”类或对象的组合或组装”问题，行为型设计模式主要解决的就是”类或对象之间的交互”问题。行为型设计模式有11种，包括：观察者模式，模板模式，策略模式，责任链模式，状态模式，迭代器模式，访问者模式，备忘录模式，命令模式，解释器模式，中介模式。实际上设计模式要干的事情就是解耦，创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦。</p><h2 id="观察者模式（Observer-Design-Pattern）"><a href="#观察者模式（Observer-Design-Pattern）" class="headerlink" title="观察者模式（Observer Design Pattern）"></a>观察者模式（Observer Design Pattern）</h2><p>观察者模式也被称为发布订阅模式，在GOF《设计模式》中定义为：在对象之间定义一个一对多的依赖，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。</p><p>一个典型的观察者模式应用是spring中的事件监听和谷歌提供的event bus，这里就不举例子了</p><h2 id="模板模式（Template-Method-Design-Pattern）"><a href="#模板模式（Template-Method-Design-Pattern）" class="headerlink" title="模板模式（Template Method Design Pattern）"></a>模板模式（Template Method Design Pattern）</h2><p>模板模式，全称是模板方法设计模式，在GOF《设计模式》一书中定义如下：模板方法模式在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。下面是模板方法模式的一个示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义模板方法的父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBaseClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//定义模板方法流程（业务逻辑顺序），具体方法由子类实现</span></span><br><span class="line">        method1();</span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractBaseClass baseClassA = <span class="keyword">new</span> SubClassA();</span><br><span class="line">        baseClassA.testMethod();</span><br><span class="line">        AbstractBaseClass baseClassB = <span class="keyword">new</span> SubClassB();</span><br><span class="line">        baseClassB.testMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassA</span> <span class="keyword">extends</span> <span class="title">AbstractBaseClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类A的方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类A的方法一"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClassB</span> <span class="keyword">extends</span> <span class="title">AbstractBaseClass</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类B的方法二"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是子类B的方法一"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板方法模式的作用"><a href="#模板方法模式的作用" class="headerlink" title="模板方法模式的作用"></a>模板方法模式的作用</h3><ul><li><p>复用</p><p>模板方法模式把业务逻辑中不变的流程抽象到父类的模板方法中，将可变的部分留给子类实现，所有的子类都可以复用父类中的模板方法定义的流程代码。</p></li><li><p>扩展</p><p>这里说的扩展，并非代码的扩展性，而是指框架的扩展性。模板模式常用在框架的开发中，让框架用户可以在不修改框架源码的情况下，定制化框架的功能。</p></li></ul><p>模板模式和回调的区别：模板模式基于继承来实现，回调基于组合来实现</p><h2 id="策略模式（Strategy-Design-Pattern）"><a href="#策略模式（Strategy-Design-Pattern）" class="headerlink" title="策略模式（Strategy Design Pattern）"></a>策略模式（Strategy Design Pattern）</h2><p>在GOF的《设计模式》一书中，策略模式是这样定义的：定义一族算法类，将每个算法分别封装起来，让它们可以相互替换。策略你是可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）</p><p>下面是策略模式的一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyA</span> <span class="keyword">implements</span> <span class="title">BaseStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"现在执行策略A的代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyB</span> <span class="keyword">implements</span> <span class="title">BaseStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"现在执行策略B的代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyC</span> <span class="keyword">implements</span> <span class="title">BaseStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"现在执行策略C的代码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StrategyTypeEnums &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 策略枚举类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    STRATEGYA(<span class="string">"A"</span>,<span class="keyword">new</span> StrategyA()),</span><br><span class="line">    STRATEGYB(<span class="string">"B"</span>,<span class="keyword">new</span> StrategyB()),</span><br><span class="line">    STRATEGYC(<span class="string">"C"</span>,<span class="keyword">new</span> StrategyC()),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line">    <span class="keyword">private</span> BaseStrategy baseStrategy;</span><br><span class="line"></span><br><span class="line">    StrategyTypeEnums(String type, BaseStrategy baseStrategy) &#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">        <span class="keyword">this</span>.baseStrategy = baseStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BaseStrategy <span class="title">getStrategyByType</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (StrategyTypeEnums value : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value.type.equals(type))&#123;</span><br><span class="line">                <span class="keyword">return</span> value.baseStrategy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String type = <span class="string">"A"</span>;</span><br><span class="line">        BaseStrategy strategyByType = StrategyTypeEnums.getStrategyByType(type);</span><br><span class="line">        <span class="keyword">if</span> (strategyByType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            strategyByType.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="责任链模式（Chain-of-Responsibility-Design-Pattern）"><a href="#责任链模式（Chain-of-Responsibility-Design-Pattern）" class="headerlink" title="责任链模式（Chain of Responsibility Design Pattern）"></a>责任链模式（Chain of Responsibility Design Pattern）</h2><p>责任链模式在GOF的《设计模式》中定义为：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。将这些接受对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接受对象能够处理它为止。</p><p>下面是责任链模式的一个小例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstHandler</span> <span class="keyword">implements</span> <span class="title">BaseHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经过第一个处理器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecondHandler</span> <span class="keyword">implements</span> <span class="title">BaseHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经过第二个处理器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThirdHandler</span> <span class="keyword">implements</span> <span class="title">BaseHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"经过第三个处理器"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseConfig</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> List&lt;BaseHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> FirstHandler firstHandler;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> SecondHandler secondHandler;</span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> ThirdHandler thirdHandler;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始加入配置"</span>);</span><br><span class="line">        handlers.add(firstHandler);</span><br><span class="line">        handlers.add(secondHandler);</span><br><span class="line">        handlers.add(thirdHandler);</span><br><span class="line">        System.out.println(<span class="string">"配置加入完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/design"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DesignPatternClient</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两种方式都可以拿到责任链中的处理器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="comment">//private List&lt;BaseHandler&gt; baseHandlers = BaseConfig.handlers;</span></span><br><span class="line">    Map&lt;String,BaseHandler&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testHandler"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHandler</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">/*baseHandlers.forEach(h-&gt;&#123;</span></span><br><span class="line"><span class="comment">            h.handle();</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">        <span class="keyword">for</span>(Map.Entry&lt;String, BaseHandler&gt; entry :map.entrySet())&#123;</span><br><span class="line">            entry.getValue().handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><p>状态模式一般用来实现有限状态机（Finite State Machine），缩写为FSM。状态机有三个组成部分：状态（state）、事件（event）、动作（Action），其中事件也称为转移条件，事件触发状态的转移及动作的执行。例如订单的状态可以会有各种不同的流转，通过状态模式可以将不同状态可以进行的动作拆分开来。</p><p>状态模式比较简单，此处不再举例。</p><h2 id="备忘录模式（Memento-Design-Pattern）"><a href="#备忘录模式（Memento-Design-Pattern）" class="headerlink" title="备忘录模式（Memento Design Pattern）"></a>备忘录模式（Memento Design Pattern）</h2><p>在GOF的《设计模式》一书中，备忘录模式的定义为：在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p><h2 id="迭代器模式（Iterator-Design-Pattern）"><a href="#迭代器模式（Iterator-Design-Pattern）" class="headerlink" title="迭代器模式（Iterator Design Pattern）"></a>迭代器模式（Iterator Design Pattern）</h2><p>迭代器模式也叫游标模式，是用来遍历集合对象的。相比于for循环，迭代器模式有如下优点：</p><ul><li>迭代器模式封装集合内容部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。此外，迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易。</li></ul><h2 id="访问者模式（Visitor-Design-Pattern）"><a href="#访问者模式（Visitor-Design-Pattern）" class="headerlink" title="访问者模式（Visitor Design Pattern）"></a>访问者模式（Visitor Design Pattern）</h2><p>在GOF的《设计模式》一书中，访问者模式的定义为：允许一个或多个操作应用到一组对象上，解耦操作和对象本身。</p><h2 id="命令模式（Command-Design-Pattern）"><a href="#命令模式（Command-Design-Pattern）" class="headerlink" title="命令模式（Command Design Pattern）"></a>命令模式（Command Design Pattern）</h2><p>在GOF的《设计模式》一书中，命令模式的定义为：将请求（命令）封装为一个对象，这样可以使用不同的请求参数化对象（将不同请求依赖注入到其他对象），并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。</p><h2 id="解释器模式（Interpreter-Design-Pattern）"><a href="#解释器模式（Interpreter-Design-Pattern）" class="headerlink" title="解释器模式（Interpreter Design Pattern）"></a>解释器模式（Interpreter Design Pattern）</h2><p>在GOF的《设计模式》一书中，解释器模式的定义为：解释器模式为某个语言定义它的语法（或叫文法）表示，并定义一个解释器用来处理这个语法。</p><p>spel表达式类似解释器模式，规则引擎类似解释器模式。</p><h2 id="中介模式（Mediator-Design-Pattern）"><a href="#中介模式（Mediator-Design-Pattern）" class="headerlink" title="中介模式（Mediator Design Pattern）"></a>中介模式（Mediator Design Pattern）</h2><p>在GOF的《设计模式》一书中，中介模式的定义为：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象，来避免对象之间的直接交互。</p><p>中介模式的设计思想与中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者依赖关系）从多对多(网状关系)转换为一对多（星状关系）。原来一个对象要跟n个对象交互，从而最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性。</p><p>观察者模式和中介模式都是为了实现参与者之间的解耦，简化交互关系。两者的不同在于应用场景上。在观察者模式的应用场景中，参与者之间的交互比较有条理，一般都是单向的，一个参与者只有一个身份，要么是观察者，要么是被观察者。而在中介模式的引用场景中，参与者之间的关系错综复杂，既可以是消息的发送者，也可以同时是消息的接收者。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这部分总结了23种设计模式的定义，适用场景，部分设计模式写了小demo来演示。总体来说设计模式一定要注意他的适用场景和实现方式这两点，只关注实现方式，就会觉得好几种设计模式类图差不多，但实际上这几种的应用场景完全不同，如果只关注适用场景，具体写代码还是不会套用，那也是纸上谈兵，总之设计模式常看常新，每次都有不同的体会。有问题可以在本博客下留言或者&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/107677272&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;上留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://www.enjoyican.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之美学习笔记一</title>
    <link href="https://www.enjoyican.com/posts/the-beauty-of-design-pattern-one/"/>
    <id>https://www.enjoyican.com/posts/the-beauty-of-design-pattern-one/</id>
    <published>2020-06-18T11:34:30.000Z</published>
    <updated>2020-06-18T11:34:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>下面是学习极客时间专栏《设计模式之美》的部分笔记，这部分主要是正式开始讲解设计模式之前的一些基础原则，基本设计思想的贯彻，本篇择取了部分内容，如有问题可在博客下留言或者直接在<a href="https://blog.csdn.net/u010408502/article/details/106854002" target="_blank" rel="noopener">CSDN</a>留言。</p><a id="more"></a><h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><p>如何理解“里式替换原则”？ </p><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP 。 子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。 </p><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而里式替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。 </p><p>里式替换原则是用来指导，继承关系中子类该如何设计的一个原则。理解里式替换原则，最核心的就是理解“design by contract，按照协议来设计”这几个字。父类定义了函数的“约定”（或者叫协议），那子类可以改变函数的内部实现逻辑，但不能改变函数原有的“约定”。这里的约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。</p><h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><p> 接口隔离原则。它对应 SOLID 中的英文字母“I”。对于这个原则，最关键就是理解其中“接口”的含义。 </p><p> 不过，你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。单一职责原则针对的是模块、类、接口的设计。而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。 </p><p> 理解“接口隔离原则”的重点是理解其中的“接口”二字。这里有三种不同的理解。</p><ul><li>如果把“接口”理解为一组接口集合，可以是某个微服务的接口，也可以是某个类库的接口等。如果部分接口只被部分调用者使用，我们就需要将这部分接口隔离出来，单独给这部分调用者使用，而不强迫其他调用者也依赖这部分不会被用到的接口。</li><li>如果把“接口”理解为单个 API 接口或函数，部分调用者只需要函数中的部分功能，那我们就需要把函数拆分成粒度更细的多个函数，让调用者只依赖它需要的那个细粒度函数。</li><li>如果把“接口”理解为 OOP 中的接口，也可以理解为面向对象编程语言中的接口语法。那接口的设计要尽量单一，不要让接口的实现类和调用者，依赖不需要的接口函数。 </li></ul><h2 id="控制反转、依赖反转、依赖注入，这三者有何区别和联系"><a href="#控制反转、依赖反转、依赖注入，这三者有何区别和联系" class="headerlink" title="控制反转、依赖反转、依赖注入，这三者有何区别和联系"></a>控制反转、依赖反转、依赖注入，这三者有何区别和联系</h2><p> 依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP </p><p> 高层模块（high-level modules）不要依赖低层模块（low-level）。高层模块和低层模块应该通过抽象（abstractions）来互相依赖。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。 </p><p> 所谓高层模块和低层模块的划分，简单来说就是，在调用链上，调用者属于高层，被调用者属于低层。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，这条原则主要还是用来指导框架层面的设计，跟前面讲到的控制反转类似。 </p><h2 id="为何说KISS、YAGNI原则看似简单，却经常被用错"><a href="#为何说KISS、YAGNI原则看似简单，却经常被用错" class="headerlink" title="为何说KISS、YAGNI原则看似简单，却经常被用错"></a>为何说KISS、YAGNI原则看似简单，却经常被用错</h2><p> KISS 原则的英文描述有好几个版本，比如下面这几个。</p><ul><li>Keep It Simple and Stupid.</li><li>Keep It Short and Simple.</li><li>Keep It Simple and Straightforward.</li></ul><p>不过，仔细看你就会发现，它们要表达的意思其实差不多，翻译成中文就是：尽量保持简单。 </p><h3 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h3><ul><li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li><li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li><li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。 </li></ul><p>我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，越是能用简单的方法解决复杂的问题，越能体现一个人的能力。 </p><h3 id="YAGNI-跟-KISS-说的是一回事吗？"><a href="#YAGNI-跟-KISS-说的是一回事吗？" class="headerlink" title="YAGNI 跟 KISS 说的是一回事吗？"></a>YAGNI 跟 KISS 说的是一回事吗？</h3><p>YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。</p><p> YAGNI 原则跟 KISS 原则并非一回事儿。KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。 </p><h2 id="重复的代码就一定违背DRY吗？如何提高代码的复用性？"><a href="#重复的代码就一定违背DRY吗？如何提高代码的复用性？" class="headerlink" title="重复的代码就一定违背DRY吗？如何提高代码的复用性？"></a>重复的代码就一定违背DRY吗？如何提高代码的复用性？</h2><p> DRY 原则。它的英文描述为：Don’t Repeat Yourself。中文直译为：不要重复自己。将它应用在编程中，可以理解为：不要写重复的代码。  </p><p>主要讲三种典型的代码重复情况，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p><h3 id="实现逻辑重复"><a href="#实现逻辑重复" class="headerlink" title="实现逻辑重复"></a>实现逻辑重复</h3><p>我们先来看下面这样一段代码是否违反了 DRY 原则。如果违反了，你觉得应该如何重构，才能让它满足 DRY 原则？如果没有违反，那又是为什么呢？  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsername(username)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isValidPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = username.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = username.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check not null, not empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// check length: 4~64</span></span><br><span class="line">    <span class="keyword">int</span> length = password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only lowcase characters</span></span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// contains only a~z,0~9,dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">      <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">      <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticatorV2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String userName, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidUsernameException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) &#123;</span><br><span class="line">      <span class="comment">// ...throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略实现逻辑</span></span><br><span class="line">    <span class="comment">//跟原来的isValidUsername()或isValidPassword()的实现逻辑一样...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过重构之后，代码行数减少了，也没有重复的代码了，是不是更好了呢？答案是否定的</p><p>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了“单一职责原则”和“接口隔离原则”。实际上，即便将两个函数合并成 isValidUserNameOrPassword()，代码仍然存在问题。 </p><p>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然从代码实现逻辑上看起来是重复的，但是从语义上并不重复。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，将两个函数的合并，那就会存在潜在的问题。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。 </p><p>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。对于包含重复代码的问题，我们可以通过抽象成更细粒度函数的方式来解决。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String charlist); 函数。 </p><h3 id="功能语义重复"><a href="#功能语义重复" class="headerlink" title="功能语义重复"></a>功能语义重复</h3><p>两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。 </p><h3 id="代码执行重复"><a href="#代码执行重复" class="headerlink" title="代码执行重复"></a>代码执行重复</h3><p>再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> existed = userRepo.checkIfUserExisted(email, password);</span><br><span class="line">    <span class="keyword">if</span> (!existed) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为代码中存在“执行重复” , 重复执行最明显的一个地方，就是在 login() 函数中，email 的校验逻辑被执行了两次。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。 </p><p>除此之外，代码中还有一处比较隐蔽的执行重复，不知道你发现了没有？实际上，login() 函数并不需要调用 checkIfUserExisted() 函数，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</p><p>实际上，这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。我们在写代码的时候，应当尽量减少这类 I/O 操作。 </p><p>按照刚刚的修改思路，我们把代码重构一下，移除“重复执行”的代码，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> UserRepo userRepo;<span class="comment">//通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!EmailValidation.validate(email)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidEmailException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!PasswordValidation.validate(password)) &#123;</span><br><span class="line">      <span class="comment">// ... throw InvalidPasswordException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    User user = userRepo.getUserByEmail(email);</span><br><span class="line">    <span class="keyword">if</span> (user == <span class="keyword">null</span> || !password.equals(user.getPassword()) &#123;</span><br><span class="line">      <span class="comment">// ... throw AuthenticationFailureException...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...query db to check if email&amp;password exists</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...query db to get user by email...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="代码复用性（Code-Reusability）"><a href="#代码复用性（Code-Reusability）" class="headerlink" title="代码复用性（Code Reusability）"></a>代码复用性（Code Reusability）</h3><p>我们首先来区分三个概念：<code>代码复用性（Code Reusability）</code>、<code>代码复用（Code Resue）</code>和 <code>DRY 原则</code>。</p><ul><li><p>代码的可复用性表示一段代码可被复用的特性或能力：我们在编写代码的时候，让代码尽量可复用。</p></li><li><p>代码复用表示一种行为：我们在开发新功能的时候，尽量复用已经存在的代码。</p></li><li><p>DRY 原则是一条原则：不要写重复的代码。从定义描述上，它们好像有点类似，但深究起来，三者的区别还是蛮大的。 </p></li></ul><p>首先，“不重复”并不代表“可复用”。在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，不重复和可复用完全是两个概念。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p><p>其次，“复用”和“可复用性”关注角度不同。代码“可复用性”是从代码开发者的角度来讲的，“复用”是从代码使用者的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。</p><p>尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，都是为了减少代码量，提高代码的可读性、可维护性。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些框架、类库、组件等的产生也都是为了达到复用的目的。比如，Spring 框架、Google Guava 类库、UI 组件等等。 </p><h3 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h3><ul><li><p>减少代码耦合</p><p>对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，高度耦合的代码会影响到代码的复用性，我们要尽量减少代码耦合。</p></li><li><p>满足单一职责原则</p><p>我们前面讲过，如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，越细粒度的代码，代码的通用性会越好，越容易被复用。</p></li><li><p>模块化</p><p>这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。独立的模块就像一块一块的积木，更加容易复用，可以直接拿来搭建更加复杂的系统。</p></li><li><p>业务与非业务逻辑分离</p><p>越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离，抽取成一些通用的框架、类库、组件等。</p></li><li><p>通用代码下沉</p><p>从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码。所以，通用的代码我们尽量下沉到更下层。</p></li><li><p>继承、多态、抽象、封装</p><p>在讲面向对象特性的时候，我们讲到，利用继承，可以将公共的代码抽取到父类，子类复用父类的属性和方法。利用多态，我们可以动态地替换一段代码的部分逻辑，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，越抽象、越不依赖具体的实现，越容易复用。代码封装成模块，隐藏可变的细节、暴露不变的接口，就越容易复用。</p></li><li><p>应用模板等设计模式</p><p>一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用。关于应用设计模式提高代码复用性这一部分，我们留在后面慢慢来讲解。除了刚刚我们讲到的几点，还有一些跟编程语言相关的特性，也能提高代码的复用性，比如泛型编程等。实际上，除了上面讲到的这些方法之外，复用意识也非常重要。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候，要 像设计一个外部 API 那样，去思考它的复用性。 </p></li></ul><h3 id="辩证思考和灵活应用"><a href="#辩证思考和灵活应用" class="headerlink" title="辩证思考和灵活应用"></a>辩证思考和灵活应用</h3><p>实际上，编写可复用的代码并不简单。如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了。</p><p>实际上，除非有非常明确的复用需求，否则，为了暂时用不到的复用需求，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 YAGNI 原则。</p><p>除此之外，有一个著名的原则，叫作“Rule of Three”。这条原则可以用在很多行业和场景中，你可以自己去研究一下。如果把这个原则用在这里，那就是说，我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。</p><p>也就是说，第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。需要注意的是，“Rule of Three”中的“Three”并不是真的就指确切的“三”，这里就是指“二”。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>DRY 原则</li></ul><p>我们今天讲了三种代码重复的情况：实现逻辑重复、功能语义重复、代码执行重复。实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。除此之外，代码执行重复也算是违反 DRY 原则。</p><ul><li><p>代码复用性</p><p>提高代码可复用性的一些方法，有以下 7 点。</p><ul><li>减少代码耦合</li><li>满足单一职责原则</li><li>模块化</li><li>业务与非业务逻辑分离</li><li>通用代码下沉</li><li>继承、多态、抽象、封装</li><li>应用模板等设计模式  </li></ul></li></ul><h2 id="如何用迪米特法则（LOD）实现“高内聚、松耦合”？"><a href="#如何用迪米特法则（LOD）实现“高内聚、松耦合”？" class="headerlink" title="如何用迪米特法则（LOD）实现“高内聚、松耦合”？"></a>如何用迪米特法则（LOD）实现“高内聚、松耦合”？</h2><h3 id="到底什么是“高内聚”呢？"><a href="#到底什么是“高内聚”呢？" class="headerlink" title="到底什么是“高内聚”呢？"></a>到底什么是“高内聚”呢？</h3><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。实际上，单一职责原则是实现代码高内聚非常有效的设计原则</p><h3 id="什么是“松耦合”？"><a href="#什么是“松耦合”？" class="headerlink" title="什么是“松耦合”？"></a>什么是“松耦合”？</h3><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。实际上，我们前面讲的依赖注入、接口隔离、基于接口而非实现编程，以及今天讲的迪米特法则，都是为了实现代码的松耦合。</p><h3 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h3><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LOD。单从这个名字上来看，我们完全猜不出这个原则讲的是什么。不过，它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：The Least Knowledge Principle。</p><p>每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。</p><h2 id="针对业务系统的开发，如何做需求分析和设计？"><a href="#针对业务系统的开发，如何做需求分析和设计？" class="headerlink" title="针对业务系统的开发，如何做需求分析和设计？"></a>针对业务系统的开发，如何做需求分析和设计？</h2><p>假设平台需要开发一个积分系统，大致涉及到功能点：</p><p>笼统地来讲，积分系统无外乎就两个大的功能点，一个是赚取积分，另一个是消费积分。赚取积分功能包括积分赚取渠道，比如下订单、每日签到、评论等；还包括积分兑换规则，比如订单金额与积分的兑换比例，每日签到赠送多少积分等。消费积分功能包括积分消费渠道，比如抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等；还包括积分兑换规则，比如多少积分可以换算成抵扣订单的多少金额，一张优惠券需要多少积分来兑换等等。</p><h3 id="合理地将功能划分到不同模块"><a href="#合理地将功能划分到不同模块" class="headerlink" title="合理地将功能划分到不同模块"></a>合理地将功能划分到不同模块</h3><p>对于前面罗列的所有功能点，我们有下面三种模块划分方法。</p><p>第一种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就会变得非常简单，只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。</p><p>举个例子解释一下。比如，用户通过下订单赚取积分。订单系统通过异步发送消息或者同步调用接口的方式，告知营销系统订单交易成功。营销系统根据拿到的订单信息，查询订单对应的积分兑换规则（兑换比例、有效期等），计算得到订单可兑换的积分数量，然后调用积分系统的接口给用户增加积分。</p><p>第二种划分方式是：积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。还是刚刚那个下订单赚取积分的例子，在这种情况下，用户下订单成功之后，订单系统根据商品对应的积分兑换比例，计算所能兑换的积分数量，然后直接调用积分系统给用户增加积分。</p><p>第三种划分方式是：所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。还是同样的例子，用户下订单成功之后，订单系统直接告知积分系统订单交易成功，积分系统根据订单信息查询积分兑换规则，给用户增加积分。</p><p>怎么判断哪种模块划分合理呢？实际上，我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。</p><p>除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，反过来，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。</p><p>所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但是，不管选择这两种中的哪一种，积分系统所负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。</p><h2 id="为什么要分层开发"><a href="#为什么要分层开发" class="headerlink" title="为什么要分层开发"></a>为什么要分层开发</h2><p>1.分层开发代码可以复用，比如同一个dao层代码可以被多个service层代码调用，同一个service方法可以被多个controller层代码调用</p><p>2.分层能起到隔离变化的作用</p><h2 id="什么情况下要重构？到底重构什么？又该如何重构？"><a href="#什么情况下要重构？到底重构什么？又该如何重构？" class="headerlink" title="什么情况下要重构？到底重构什么？又该如何重构？"></a>什么情况下要重构？到底重构什么？又该如何重构？</h2><p>软件设计大师 Martin Fowler 是这样定义重构的：“重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。”</p><h3 id="为什么要进行代码重构？"><a href="#为什么要进行代码重构？" class="headerlink" title="为什么要进行代码重构？"></a>为什么要进行代码重构？</h3><p>重构是时刻保证代码质量的一个极其有效的手段；</p><p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，随着系统的演进，重构代码也是不可避免的</p><p>最后，重构是避免过度设计的有效手段。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p><h3 id="重构的时机：什么时候重构（when）？"><a href="#重构的时机：什么时候重构（when）？" class="headerlink" title="重构的时机：什么时候重构（when）？"></a>重构的时机：什么时候重构（when）？</h3><p>平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><p><strong>那些看到别人代码有点瑕疵就一顿乱骂，或者花尽心思去构思一个完美设计的人，往往都是因为没有树立正确的代码质量观，没有持续重构意识。</strong></p><h2 id="编码规范"><a href="#编码规范" class="headerlink" title="编码规范"></a>编码规范</h2><p><strong>命名长度适中</strong></p><p>对于作用域小的局部变量，简短为先；对于类名，接口名介意见名知意，除通用缩写外尽量少用缩写；总体来说表达含义的前提下，越短越好</p><p><strong>利用上下文简化命名</strong></p><p><strong>命名要可读，可搜索</strong></p><p><strong>除非是本类内部使用的，否则不要用布尔类型或者参数是否为null控制代码逻辑</strong></p><p><strong>代码不要有过深的嵌套层次</strong>：去掉多余的if或者else；使用break，continue，return等语句提前退出嵌套；调整执行顺序减少嵌套；将部分嵌套逻辑封装成函数调用</p><h2 id="如何发现代码质量问题"><a href="#如何发现代码质量问题" class="headerlink" title="如何发现代码质量问题"></a>如何发现代码质量问题</h2><blockquote><p>常规checklist</p><ul><li>目录设置是否合理，模块划分是否清晰、代码结构是否满足高内聚，低耦合</li><li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD等）?</li><li>设计模式是否应用得当？是否过度设计？</li><li>代码是否容易扩展？如果要添加新的功能，是否容易实现？</li><li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li><li>代码是否容易测试？单元测试是否全面覆盖各种正常和异常的情况？</li><li>代码是否容易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）</li></ul></blockquote><blockquote><p>业务需求checklist</p><ul><li>代码是否实现了预期的业务需求</li><li>逻辑是否正确？是否处理了各种异常情况</li><li>日志打印是否得当？是否方便debug排查问题？</li><li>接口是否易用，是否支持幂等、事务等？</li><li>代码是否存在并发问题？是否线程安全？</li><li>性能是否有优化空间，比如，SQL，算法是否可以优化</li><li>是否有安全漏洞？比如输入输出校验是否全面</li></ul></blockquote><hr><h2 id="阶段性总结："><a href="#阶段性总结：" class="headerlink" title="阶段性总结："></a>阶段性总结：</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/the-beauty-of-design-pattern/code-quality-standard.jpg" alt="代码质量评判标准" title="">                </div>                <div class="image-caption">代码质量评判标准</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/the-beauty-of-design-pattern/oop.jpg" alt="面向对象" title="">                </div>                <div class="image-caption">面向对象</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/the-beauty-of-design-pattern/design-principle.jpg" alt="设计原则" title="">                </div>                <div class="image-caption">设计原则</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/the-beauty-of-design-pattern/standard-rebuild.jpg" alt="规范与重构" title="">                </div>                <div class="image-caption">规范与重构</div>            </figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;下面是学习极客时间专栏《设计模式之美》的部分笔记，这部分主要是正式开始讲解设计模式之前的一些基础原则，基本设计思想的贯彻，本篇择取了部分内容，如有问题可在博客下留言或者直接在&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/106854002&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="design-pattern" scheme="https://www.enjoyican.com/tags/design-pattern/"/>
    
      <category term="note" scheme="https://www.enjoyican.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>java性能调优实战学习笔记</title>
    <link href="https://www.enjoyican.com/posts/java-performance-tuning/"/>
    <id>https://www.enjoyican.com/posts/java-performance-tuning/</id>
    <published>2020-05-27T15:51:30.000Z</published>
    <updated>2020-05-27T15:51:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看了，后续有时间再看吧</p><p>有任何问题可在我的<a href="https://blog.csdn.net/u010408502/article/details/106394408" target="_blank" rel="noopener">CSDN</a>或者该博客下面留言即可</p><a id="more"></a><h2 id="如何制定性能调优标准"><a href="#如何制定性能调优标准" class="headerlink" title="如何制定性能调优标准"></a>如何制定性能调优标准</h2><p> 有哪些参考因素可以体现系统的性能？ </p><p> 在我们了解性能指标之前，我们先来了解下哪些计算机资源会成为系统的性能瓶颈。 </p><p> CPU 、内存、磁盘IO、网络、异常、数据库、锁竞争</p><ul><li>CPU：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。</li><li>内存：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。</li><li>磁盘 I/O：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。</li><li>网络：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。</li><li>异常：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。</li><li>数据库：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。</li><li>锁竞争：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。 </li></ul><p>可以用下面几个指标，来衡量一般系统的性能 ：</p><p> <strong>响应时间</strong> </p><ul><li><p>数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；</p></li><li><p>服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；</p></li><li><p>网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；</p></li><li><p>客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。 </p><p><strong>吞吐量</strong> </p></li></ul><p>在测试中，我们往往会比较注重系统接口的 TPS（每秒事务处理量），因为 TPS 体现了接口的性能，TPS 越大，性能越好。在系统中，我们也可以把吞吐量自下而上地分为两种：磁盘吞吐量和网络吞吐量。</p><p>我们先来看<strong>磁盘吞吐量</strong>，磁盘性能有两个关键衡量指标。</p><p>一种是<code>IOPS（Input/Output Per Second）</code>，即每秒的输入输出量（或读写次数），这种是指单位时间内系统能处理的 I/O 请求数量，I/O 请求通常为读或写数据操作请求，关注的是随机读写性能。适应于随机读写频繁的应用，如小文件存储（图片）、OLTP 数据库、邮件服务器。</p><p>另一种是数据吞吐量，这种是指单位时间内可以成功传输的数据量。对于大量顺序读写频繁的应用，传输大量连续数据，例如，电视台的视频编辑、视频点播 VOD（Video On Demand），数据吞吐量则是关键衡量指标。 </p><p> <strong>网络吞吐量</strong>这个是指网络传输时没有帧丢失的情况下，设备能够接受的最大数据速率。网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。而吞吐量的大小主要由网卡的处理能力、内部程序算法以及带宽大小决定。 </p><p> <strong>计算机资源分配使用率</strong></p><p>通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。这几个参数好比一个木桶，如果其中任何一块木板出现短板，任何一项分配不合理，对整个系统性能的影响都是毁灭性的。</p><p><strong>负载承受能力</strong></p><p>当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。例如，当你对系统进行压测时，系统的响应时间会随着系统并发数的增加而延长，直到系统无法处理这么多请求，抛出大量错误时，就到了极限。 </p><h2 id="如何制定性能调优策略"><a href="#如何制定性能调优策略" class="headerlink" title="如何制定性能调优策略"></a>如何制定性能调优策略</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/java-performance-tuning/strategy.jpg" alt="性能调优策略" title="">                </div>                <div class="image-caption">性能调优策略</div>            </figure><h2 id="慎重使用正则表达式"><a href="#慎重使用正则表达式" class="headerlink" title="慎重使用正则表达式"></a>慎重使用正则表达式</h2><p><strong>正则表达式引擎</strong> </p><p> 正则表达式是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。</p><p>而这里的正则表达式引擎就是一套核心算法，用于建立状态机。</p><p>目前实现正则表达式引擎的方式有两种：DFA 自动机（Deterministic Final Automaton 确定有限状态自动机）和 NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。</p><p>对比来看，构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机。</p><p>假设一个字符串的长度是 n，如果用 DFA 自动机作为正则表达式引擎，则匹配的时间复杂度为 O(n)；如果用 NFA 自动机作为正则表达式引擎，由于 NFA 自动机在匹配过程中存在大量的分支和回溯，假设 NFA 的状态数为 s，则该匹配算法的时间复杂度为 O（ns）。</p><p>NFA 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 NFA 实现的。 </p><p><strong>用 NFA 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。</strong> </p><p>举例说明 :</p><blockquote><p> text=“abbc”</p><p>regex=“ab{1,3}c” </p></blockquote><p> 这个例子，匹配目的比较简单。匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 自动机对其解析的过程是这样的：首先，读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/1.jpg" alt=""></p><p> 然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。但因为 b{1,3} 表示 1-3 个 b 字符串，NFA 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 进行比较，结果还是匹配。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/2.jpg" alt=""></p><p> 接着继续使用 b{1,3} 和字符串的第四个字符 c 进行比较，发现不匹配了，<strong>此时就会发生回溯</strong>，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/3.jpg" alt=""></p><p> 那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/4.jpg" alt=""></p><h3 id="如何减少回溯问题？"><a href="#如何减少回溯问题？" class="headerlink" title="如何减少回溯问题？"></a>如何减少回溯问题？</h3><p>既然回溯会给系统带来性能开销，那我们如何应对呢？如果你有仔细看上面那个案例的话，你会发现 NFA 自动机的贪婪特性就是导火索，这和正则表达式的匹配模式息息相关。 </p><p><strong>贪婪模式（Greedy）</strong>顾名思义，就是在数量匹配中，如果单独使用<code>+、 ? 、* 或{min,max}</code> 等量词，正则表达式会匹配尽可能多的内容。例如，上边那个例子： </p><p><strong>懒惰模式（Reluctant）</strong>在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。 </p><p> 例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。 </p><blockquote><p> text=“abc”</p><p>regex=“ab{1,3}?c” </p></blockquote><p> 匹配结果是“abc”，该模式下 NFA 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。</p><p>懒惰模式是无法完全避免回溯的，我们再通过一个例子来了解下懒惰模式在什么情况下会发生回溯问题。 </p><blockquote><p> text=“abbc”</p><p>regex=“ab{1,3}?c” </p></blockquote><p>以上匹配结果依然是成功的，这又是为什么呢？我们可以通过懒惰模式的匹配过程来了解下原因。</p><p>首先，读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。</p><p>其次，由于懒惰模式下，正则表达式会尽可能少地重复匹配字符，匹配字符串中的下一个匹配字符 b 不会继续与 b{1,3}进行匹配，转而匹配正则表达式中的下一个字符 c。  </p><p>此时你会发现匹配字符 b 与正则表达式中的字符 c 是不匹配的，这个时候会发生一次回溯，这次的回溯与贪婪模式中的回溯刚好相反，<strong>懒惰模式的回溯是回溯正则表达式中一个匹配字符，与上一个字符再进行匹配</strong>。如果匹配，则将匹配字符串的下一个字符和正则表达式的下一个字符。 </p><p><strong>独占模式（Possessive）</strong> </p><p><strong>同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。</strong> </p><p> 还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。</p><blockquote><p>text=“abbc”</p><p>regex=“ab{1,3}+bc” </p></blockquote><p>结果是不匹配，结束匹配，不会发生回溯问题。</p><p>同样，独占模式也不能避免回溯的发生，我们再拿最开始的这个例子来分析下：</p><blockquote><p>text=“abbc”</p><p>regex=“ab{1,3}+c” </p></blockquote><p>结果是匹配的，这是因为<strong>与贪婪模式一样，独占模式一样会最大限度地匹配更多内容</strong>，即匹配完所有的 b 之后，再去匹配 c，则匹配成功了。 </p><p><strong>在很多情况下使用懒惰模式和独占模式可以减少回溯的发生。</strong> </p><h3 id="正则表达式的优化"><a href="#正则表达式的优化" class="headerlink" title="正则表达式的优化"></a>正则表达式的优化</h3><ol><li><p><strong>少用贪婪模式，多用独占模式</strong></p><p>贪婪模式会引起回溯问题，我们可以使用独占模式来避免回溯。前面详解过了，这里我就不再解释了。</p></li><li><p><strong>减少分支选择</strong></p><p>分支选择类型“(X|Y|Z)”的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：</p><p>首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；</p><p>其次，我们可以尝试提取共用模式，例如，将“(abcd|abef)”替换为“ab(cd|ef)”，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；</p><p>最后，如果是简单的分支选择类型，我们可以用三次 index 代替“(X|Y|Z)”，如果测试的话，你就会发现三次 index 的效率要比“(X|Y|Z)”高出一些。 </p></li><li><p><strong>减少捕获嵌套</strong> </p><p> 捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。</p><p>非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成。</p><p>在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String text = <span class="string">"&lt;input high=\"20\" weight=\"70\"&gt;test&lt;/input&gt;"</span>;</span><br><span class="line">  String reg=<span class="string">"(&lt;input.*?&gt;)(.*?)(&lt;/input&gt;)"</span>;</span><br><span class="line">  Pattern p = Pattern.compile(reg);</span><br><span class="line">  Matcher m = p.matcher(text);</span><br><span class="line">  <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group(<span class="number">0</span>));<span class="comment">//整个匹配到的内容</span></span><br><span class="line">    System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(&lt;input.*?&gt;)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">2</span>));<span class="comment">//(.*?)</span></span><br><span class="line">    System.out.println(m.group(<span class="number">3</span>));<span class="comment">//(&lt;/input&gt;)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high=<span class="tag">\<span class="name">"</span></span>20<span class="tag">\<span class="name">"</span></span> weight=<span class="tag">\<span class="name">"</span></span>70<span class="tag">\<span class="name">"</span></span>&gt;test&lt;/input&gt;</span><br><span class="line">&lt;input high=<span class="tag">\<span class="name">"</span></span>20<span class="tag">\<span class="name">"</span></span> weight=<span class="tag">\<span class="name">"</span></span>70<span class="tag">\<span class="name">"</span></span>&gt;</span><br><span class="line">test</span><br><span class="line">&lt;/input&gt;</span><br></pre></td></tr></table></figure><p> 如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，我们再看下面的例子： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">( String[] args )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  String text = <span class="string">"&lt;input high=\"20\" weight=\"70\"&gt;test&lt;/input&gt;"</span>;</span><br><span class="line">  String reg=<span class="string">"(?:&lt;input.*?&gt;)(.*?)(?:&lt;/input&gt;)"</span>;</span><br><span class="line">  Pattern p = Pattern.compile(reg);</span><br><span class="line">  Matcher m = p.matcher(text);</span><br><span class="line">  <span class="keyword">while</span>(m.find()) &#123;</span><br><span class="line">    System.out.println(m.group(<span class="number">0</span>));<span class="comment">//整个匹配到的内容</span></span><br><span class="line">    System.out.println(m.group(<span class="number">1</span>));<span class="comment">//(.*?)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行结果： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input high&#x3D;\&quot;20\&quot; weight&#x3D;\&quot;70\&quot;&gt;test&lt;&#x2F;input&gt;</span><br><span class="line">test</span><br></pre></td></tr></table></figure><p> 综上可知：减少不需要获取的分组，可以提高正则表达式的性能。 </p></li></ol><p>正则表达式虽然小，却有着强大的匹配功能。我们经常用到它，比如，注册页面手机号或邮箱的校验。</p><p>但很多时候，我们又会因为它小而忽略它的使用规则，测试用例中又没有覆盖到一些特殊用例，不乏上线就中招的情况发生。</p><p>如果使用正则表达式能使你的代码简洁方便，那么在做好性能排查的前提下，可以去使用；如果不能，那么正则表达式能不用就不用，以此避免造成更多的性能问题。 </p><h2 id="ArrayList和LinkedList"><a href="#ArrayList和LinkedList" class="headerlink" title="ArrayList和LinkedList"></a>ArrayList和LinkedList</h2><p>我们在查看 ArrayList 的实现类源码时，你会发现对象数组 elementData 使用了 transient 修饰，我们知道 transient 关键字修饰该属性，则表示该属性不会被序列化，然而我们并没有看到文档中说明 ArrayList 不能被序列化，这是为什么？ </p><blockquote><p> ArrayList 属性主要由数组长度 size、对象数组 elementData、初始化容量 default_capacity 等组成， 其中初始化容量默认大小为 10。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认初始化容量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">   <span class="comment">//对象数组</span></span><br><span class="line">   <span class="keyword">transient</span> Object[] elementData; </span><br><span class="line">   <span class="comment">//数组长度</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><p>从 ArrayList 属性来看，它没有被任何的多线程关键字修饰，但 elementData 被关键字 transient 修饰了。</p><p>由于 ArrayList 的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。如果采用外部序列化法实现数组的序列化，会序列化整个数组。ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法 writeObject 以及 readObject 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p><p><strong>因此使用 transient 修饰数组，是防止对象数组被其他外部方法序列化</strong>。 </p></blockquote><h2 id="Stream如何提高遍历集合效率"><a href="#Stream如何提高遍历集合效率" class="headerlink" title="Stream如何提高遍历集合效率"></a>Stream如何提高遍历集合效率</h2><p>官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。 </p><p>中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。 </p><p>终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。操作分类详情如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/java-performance-tuning/stream.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure> <p> 我们通常还会将中间操作称为懒操作，也正是由这种懒操作结合终结操作、数据源构成的处理管道（Pipeline），实现了 Stream 的高效。 </p><p>在循环迭代次数较少的情况下，常规的迭代方式性能反而更好；在单核 CPU 服务器配置环境中，也是常规迭代方式更有优势；而在大数据循环迭代中，如果服务器是多核 CPU 的情况下，Stream 的并行迭代优势明显。所以我们在平时处理大数据的集合时，应该尽量考虑将应用部署在多核 CPU 环境下，并且使用 Stream 的并行迭代方式进行处理。 </p><h2 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h2><p> HashMap 扩容优化 :</p><p> 在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。</p><p>而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。</p><p>之所以能通过这种“与运算“来重新分配索引，是因为 hash 值本来就是随机的，而 hash 按位与上 newTable 得到的 0（扩容前的索引位置）和 1（扩容前索引位置加上扩容前数组长度的数值索引处）就是随机的，所以扩容的过程就能把之前哈希冲突的元素再随机分布到不同的索引中去。</p><p>实际应用中，我们设置初始容量，一般得是 2 的整数次幂。你知道原因吗？ </p><blockquote><p> 1）通过将 Key 的 hash 值与 length-1 进行 &amp; 运算，实现了当前 Key 的定位，2 的幂次方可以减少冲突（碰撞）的次数，提高 HashMap 查询效率；<br>2）如果 length 为 2 的次幂，则 length-1 转化为二进制必定是 11111…… 的形式，在于 h 的二进制与操作效率会非常的快，而且空间不浪费；如果 length 不是 2 的次幂，比如 length 为 15，则 length-1 为 14，对应的二进制为 1110，在于 h 与操作，最后一位都为 0，而 0001，0011，0101，1001，1011，0111，1101 这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这样就会造成空间的浪费。 </p></blockquote><h2 id="MySQL调优之SQL语句：如何写出高性能SQL语句？"><a href="#MySQL调优之SQL语句：如何写出高性能SQL语句？" class="headerlink" title="MySQL调优之SQL语句：如何写出高性能SQL语句？"></a>MySQL调优之SQL语句：如何写出高性能SQL语句？</h2><h3 id="慢-SQL-语句的几种常见诱因"><a href="#慢-SQL-语句的几种常见诱因" class="headerlink" title="慢 SQL 语句的几种常见诱因"></a>慢 SQL 语句的几种常见诱因</h3><ul><li><p><strong>无索引、索引失效导致慢查询</strong> </p></li><li><p><strong>锁等待</strong> </p><p>我们常用的存储引擎有 InnoDB 和 MyISAM，前者支持行锁和表锁，后者只支持表锁。</p><p>如果数据库操作是基于表锁实现的，试想下，如果一张订单表在更新时，需要锁住整张表，那么其它大量数据库操作（包括查询）都将处于等待状态，这将严重影响到系统的并发性能。</p><p>这时，InnoDB 存储引擎支持的行锁更适合高并发场景。但在使用 InnoDB 存储引擎时，我们要特别注意行锁升级为表锁的可能。在批量更新操作时，行锁就很可能会升级为表锁。</p><p>MySQL 认为如果对一张表使用大量行锁，会导致事务执行效率下降，从而可能造成其它事务长时间锁等待和更多的锁冲突问题发生，致使性能严重下降，所以 MySQL 会将行锁升级为表锁。还有，行锁是基于索引加的锁，如果我们在更新操作时，条件索引失效，那么行锁也会升级为表锁。</p><p>因此，基于表锁的数据库操作，会导致 SQL 阻塞等待，从而影响执行速度。在一些更新操作（insert\update\delete）大于或等于读操作的情况下，MySQL 不建议使用 MyISAM 存储引擎。</p><p>除了锁升级之外，行锁相对表锁来说，虽然粒度更细，并发能力提升了，但也带来了新的问题，那就是死锁。因此，在使用行锁时，我们要注意避免死锁。关于死锁，我还会在第 35 讲中详解。 </p></li><li><p><strong>不恰当的 SQL 语句</strong> </p></li></ul><h3 id="优化-SQL-语句的步骤"><a href="#优化-SQL-语句的步骤" class="headerlink" title="优化 SQL 语句的步骤"></a>优化 SQL 语句的步骤</h3><p>通常，我们在执行一条 SQL 语句时，要想知道这个 SQL 先后查询了哪些表，是否使用了索引，这些数据从哪里获取到，获取到数据遍历了多少行数据等等，我们可以通过 EXPLAIN 命令来查看这些执行信息。这些执行信息被统称为<strong>执行计划</strong>。 </p><h4 id="通过-EXPLAIN-分析-SQL-执行计划"><a href="#通过-EXPLAIN-分析-SQL-执行计划" class="headerlink" title="通过 EXPLAIN 分析 SQL 执行计划"></a>通过 EXPLAIN 分析 SQL 执行计划</h4><p> 假设现在我们使用 EXPLAIN 命令查看当前 SQL 是否使用了索引，先通过 SQL EXPLAIN 导出相应的执行计划如下： </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/explain-sql.jpg" alt=""></p><ul><li>id：每个执行计划都有一个 id，如果是一个联合查询，这里还将有多个 id。 </li><li>select_type：表示 SELECT 查询类型，常见的有 SIMPLE（普通查询，即没有联合查询、子查询）、PRIMARY（主查询）、UNION（UNION 中后面的查询）、SUBQUERY（子查询）等。 </li><li>table：当前执行计划查询的表，如果给表起别名了，则显示别名信息。 </li><li>partitions：访问的分区表信息。 </li><li>type：表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，结果值从好到差依次是：<code>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</code>。 </li></ul><p><strong>system/const</strong>：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/system-const.jpg" alt=""></p><p><strong>eq_ref</strong>：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/eq-ref.jpg" alt=""></p><p> <strong>ref：</strong>非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/ref.jpg" alt=""></p><p> <strong>range</strong>：索引范围扫描，比如，<code>&lt;，&gt;，between</code>等操作。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/range.jpg" alt=""></p><p> <strong>index</strong>：索引全表扫描，此时遍历整个索引树。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/index.jpg" alt=""></p><p> <strong>ALL：</strong>表示全表扫描，需要遍历全表来找到对应的行。</p><p><strong>possible_keys：</strong>可能使用到的索引。</p><p><strong>key：</strong>实际使用到的索引。</p><p><strong>key_len：</strong>当前使用的索引的长度。</p><p><strong>ref</strong>：关联 id 等信息。</p><p><strong>rows</strong>：查找到记录所扫描的行数。</p><p><strong>filtered</strong>：查找到所需记录占总扫描记录数的比例。</p><p><strong>Extra</strong>：额外的信息。 </p><h4 id="通过-Show-Profile-分析-SQL-执行性能"><a href="#通过-Show-Profile-分析-SQL-执行性能" class="headerlink" title="通过 Show Profile 分析 SQL 执行性能"></a>通过 Show Profile 分析 SQL 执行性能</h4><p> 上述通过 EXPLAIN 分析执行计划，仅仅是停留在分析 SQL 的外部的执行情况，如果我们想要深入到 MySQL 内核中，从执行线程的状态和时间来分析的话，这个时候我们就可以选择 Profile。 </p><p> Profile 除了可以分析执行线程的状态和时间，还支持进一步选择 <code>ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES</code>等类型来查询 SQL 语句在不同系统资源上所消耗的时间。以下是相关命令的注释： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILE [<span class="keyword">type</span> [, <span class="keyword">type</span>] ... ]</span><br><span class="line">[<span class="keyword">FOR</span> <span class="keyword">QUERY</span> n]</span><br><span class="line">[<span class="keyword">LIMIT</span> <span class="keyword">row_count</span> [<span class="keyword">OFFSET</span> <span class="keyword">offset</span>]]</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span>参数：</span><br><span class="line">| <span class="keyword">ALL</span>：显示所有开销信息</span><br><span class="line">| <span class="keyword">BLOCK</span> IO：阻塞的输入输出次数</span><br><span class="line">| <span class="keyword">CONTEXT</span> SWITCHES：上下文切换相关开销信息</span><br><span class="line">| CPU：显示CPU的相关开销信息 </span><br><span class="line">| IPC：接收和发送消息的相关开销信息</span><br><span class="line">| <span class="keyword">MEMORY</span> ：显示内存相关的开销，目前无用</span><br><span class="line">| PAGE FAULTS ：显示页面错误相关开销信息</span><br><span class="line">| <span class="keyword">SOURCE</span> ：列出相应操作对应的函数名及其在源码中的调用位置(行数) </span><br><span class="line">| SWAPS：显示swap交换次数的相关开销信息</span><br></pre></td></tr></table></figure><p> 可以通过 <code>select @@have_profiling</code> 查询是否支持profile功能 </p><p> Show Profiles 只显示最近发给服务器的 SQL 语句，默认情况下是记录最近已执行的 15 条记录，我们可以重新设置<code>profiling_history_size</code>增大该存储记录，最大值为 100。 </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/profile.jpg" alt=""></p><p>获取到 Query_ID 之后，我们再通过 <code>Show Profile for Query ID</code>语句，就能够查看到对应 Query_ID 的 SQL 语句在执行过程中线程的每个状态所消耗的时间了： </p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/show-profile.jpg" alt=""></p><p>通过以上分析可知：<code>SELECT COUNT(*) FROM order</code>; SQL 语句在 Sending data 状态所消耗的时间最长，这是因为在该状态下，MySQL 线程开始读取数据并返回到客户端，此时有大量磁盘 I/O 操作。 </p><h3 id="常用的-SQL-优化"><a href="#常用的-SQL-优化" class="headerlink" title="常用的 SQL 优化"></a>常用的 SQL 优化</h3><h4 id="优化分页查询"><a href="#优化分页查询" class="headerlink" title="优化分页查询"></a>优化分页查询</h4><p>通常我们是使用 + 合适的 order by 来实现分页查询，这种实现方式在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能将会非常得糟糕。如果有对应的索引，通常刚开始的分页查询效率会比较理想，但越往后，分页查询的性能就越差。</p><p>这是因为我们在使用 LIMIT 的时候，偏移量 M 在分页越靠后的时候，值就越大，数据库检索的数据也就越多。例如 LIMIT 10000,10 这样的查询，数据库需要查询 10010 条记录，最后返回 10 条记录。也就是说将会有 10000 条记录被查询出来没有被使用到。 </p><ul><li><p>利用子查询优化分页查询 </p><p> 以上分页查询的问题在于，我们查询获取的 10020 行数据结果都返回给我们了，我们能否先查询出所需要的 20 行数据中的最小 ID 值，然后通过偏移量返回所需要的 20 行数据给我们呢？我们可以通过索引覆盖扫描，使用子查询的方式来实现分页查询： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="string">`demo`</span>.<span class="string">`order`</span> <span class="keyword">where</span> <span class="keyword">id</span>&gt; (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="string">`demo`</span>.<span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> order_no <span class="keyword">limit</span> <span class="number">10000</span>, <span class="number">1</span>)  <span class="keyword">limit</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p><img src="https://www.enjoyican.com/img/java-performance-tuning/subquery1.jpg" alt=""></p><p><img src="https://www.enjoyican.com/img/java-performance-tuning/subquery2.jpg" alt=""></p></li></ul><h4 id="优化-SELECT-COUNT"><a href="#优化-SELECT-COUNT" class="headerlink" title="优化 SELECT COUNT(*)"></a>优化 SELECT COUNT(*)</h4><p>通常在没有任何查询条件下的 COUNT(*)，MyISAM 的查询速度要明显快于 InnoDB。这是因为 MyISAM 存储引擎记录的是整个表的行数，在 COUNT(*) 查询操作时无需遍历表计算，直接获取该值即可。而在 InnoDB 存储引擎中就需要扫描表来统计具体的行数。而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行行数的统计。 </p><p>如果对一张大表经常做 SELECT COUNT(*) 操作，这肯定是不明智的。那么我们该如何对大表的 COUNT() 进行优化呢？ </p><ul><li><p>使用近似值</p><p>有时候某些业务场景并不需要返回一个精确的 COUNT 值，此时我们可以使用近似值来代替。我们可以使用 EXPLAIN 对表进行估算，要知道，执行 EXPLAIN 并不会真正去执行查询，而是返回一个估算的近似值。</p></li><li><p>增加汇总统计</p><p>如果需要一个精确的 COUNT 值，我们可以额外新增一个汇总统计表或者缓存字段来统计需要的 COUNT 值，这种方式在新增和删除时有一定的成本，但却可以大大提升 COUNT() 的性能。 </p></li></ul><p>我们可以打开慢 SQL 配置项，记录下都有哪些 SQL 超过了预期的最大执行时间。首先，我们可以通过以下命令行查询是否开启了记录慢 SQL 的功能，以及最大的执行时间是多少： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'slow_query%'</span>;</span><br><span class="line"><span class="keyword">Show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'long_query_time'</span>;</span><br></pre></td></tr></table></figure><p> 如果没有开启，我们可以通过以下设置来开启： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="string">'ON'</span>; //开启慢SQL日志</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=<span class="string">'/var/lib/mysql/test-slow.log'</span>;//记录日志地址</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>;//最大执行时间</span><br></pre></td></tr></table></figure><p>思考题：</p><p>假设有一张订单表 order，主要包含了主键订单编码 order_no、订单状态 status、提交时间 create_time 等列，并且创建了 status 列索引和 create_time 列索引。此时通过创建时间降序获取状态为 1 的订单编码，以下是具体实现代码： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> order_no <span class="keyword">from</span> <span class="keyword">order</span> <span class="keyword">where</span> <span class="keyword">status</span> =<span class="number">1</span> <span class="keyword">order</span> <span class="keyword">by</span> create_time <span class="keyword">desc</span></span><br></pre></td></tr></table></figure><p>你知道其中的问题所在吗？我们又该如何优化？ </p><blockquote><p>status和create_time单独建索引，在查询时只会遍历status索引对数据进行过滤，不会用到create_time列索引，将符合条件的数据返回到server层，在server对数据通过快排算法进行排序，Extra列会出现file sort；应该利用索引的有序性，在status和create_time列建立联合索引，这样根据status过滤后的数据就是按照create_time排好序的，避免在server层排序 </p></blockquote><h2 id="MySQL调优之事务：高并发场景下的数据库事务调优"><a href="#MySQL调优之事务：高并发场景下的数据库事务调优" class="headerlink" title="MySQL调优之事务：高并发场景下的数据库事务调优"></a>MySQL调优之事务：高并发场景下的数据库事务调优</h2><p>InnoDB 中的 RC 和 RR 隔离事务是基于多版本并发控制（MVCC）实现高性能事务。一旦数据被加上排他锁，其他事务将无法加入共享锁，且处于阻塞等待状态，如果一张表有大量的请求，这样的性能将是无法支持的。</p><p>MVCC 对普通的 Select 不加锁，如果读取的数据正在执行 Delete 或 Update 操作，这时读取操作不会等待排它锁的释放，而是直接利用 MVCC 读取该行的数据快照（数据快照是指在该行的之前版本的数据，而数据快照的版本是基于 undo 实现的，undo 是用来做事务回滚的，记录了回滚的不同版本的行记录）。MVCC 避免了对数据重复加锁的过程，大大提高了读操作的性能。 </p><p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。 </p><p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select 、Update 和 Delete 时，除了基于唯一索引的查询之外，其他索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。 </p><h3 id="优化高并发事务"><a href="#优化高并发事务" class="headerlink" title="优化高并发事务"></a>优化高并发事务</h3><ul><li>结合业务场景，使用低级别事务隔离 </li><li>避免行锁升级表锁 </li><li>控制事务的大小，减少锁定的资源量和锁定时间长度 </li></ul><h2 id="MySQL调优之索引：索引的失效与优化"><a href="#MySQL调优之索引：索引的失效与优化" class="headerlink" title="MySQL调优之索引：索引的失效与优化"></a>MySQL调优之索引：索引的失效与优化</h2><h3 id="覆盖索引优化查询"><a href="#覆盖索引优化查询" class="headerlink" title="覆盖索引优化查询"></a>覆盖索引优化查询</h3><p>假设我们只需要查询商品的名称、价格信息，我们有什么方式来避免回表呢？我们可以建立一个组合索引，即商品编码、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。</p><p> 从辅助索引中查询得到记录，而不需要通过聚簇索引查询获得，MySQL 中将其称为覆盖索引。使用覆盖索引的好处很明显，我们不需要查询出包含整行记录的所有信息，因此可以减少大量的 I/O 操作。 </p><h3 id="自增字段作主键优化查询"><a href="#自增字段作主键优化查询" class="headerlink" title="自增字段作主键优化查询"></a>自增字段作主键优化查询</h3><p>InnoDB 创建主键索引默认为聚簇索引，数据被存放在了 B+ 树的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。</p><p>如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为不需要重新移动数据，因此这种插入数据的方法效率非常高。</p><p>如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。</p><p>因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。  </p><h3 id="前缀索引优化"><a href="#前缀索引优化" class="headerlink" title="前缀索引优化"></a>前缀索引优化</h3><p> 前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？我们知道，索引文件是存储在磁盘中的，而磁盘中最小分配单元是页，通常一个页的默认大小为 16KB，假设我们建立的索引的每个索引值大小为 2KB，则在一个页中，我们能记录 8 个索引值，假设我们有 8000 行记录，则需要 1000 个页来存储索引。如果我们使用该索引查询数据，可能需要遍历大量页，这显然会降低查询效率。减小索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。不过，前缀索引是有一定的局限性的，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。 </p><h3 id="防止索引失效"><a href="#防止索引失效" class="headerlink" title="防止索引失效"></a>防止索引失效</h3><p> 在大多数情况下，我们习惯使用默认的 InnoDB 作为表存储引擎。在使用 InnoDB 作为存储引擎时，创建的索引默认为 B+ 树数据结构，如果是主键索引，则属于聚簇索引，非主键索引则属于辅助索引。基于主键查询可以直接获取到行信息，而基于辅助索引作为查询条件，则需要进行回表，然后再通过主键索引获取到数据。如果只是查询一列或少部分列的信息，我们可以基于覆盖索引来避免回表。覆盖索引只需要读取索引，且由于索引是顺序存储，对于范围或排序查询来说，可以极大地极少磁盘 I/O 操作。 </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是极客时间专栏《java性能调优实战》的部分学习笔记，个人感觉这个专栏内容不深，适合初学者，我只看了编程性能调优和数据库性能调优两块，其他的暂时不打算看了，后续有时间再看吧&lt;/p&gt;
&lt;p&gt;有任何问题可在我的&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/106394408&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;或者该博客下面留言即可&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://www.enjoyican.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>JAVA业务开发常见错误100例学习笔记</title>
    <link href="https://www.enjoyican.com/posts/java-errorcase/"/>
    <id>https://www.enjoyican.com/posts/java-errorcase/</id>
    <published>2020-05-24T03:02:30.000Z</published>
    <updated>2020-05-24T03:02:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近抽零碎时间过了一个极客时间的专栏，感觉讲的还不错，本篇内容基本是原文复制粘贴了一些点过来，至于为啥没归纳总结，我说是因为时间原因，你也可以说是因为懒😂😂😂，总之这里做个记录，以备以后再看。有任何问题可以在我的<a href="https://www.enjoyican.com/posts/java-errorcase">博客</a>留言,或者直接在<a href="https://blog.csdn.net/u010408502/article/details/106312674" target="_blank" rel="noopener">CSDN</a>留言。</p><a id="more"></a><ol><li><p><strong>ThreadLocal 使用要注意及时remove</strong>，既要防止内存溢出，也防止线程重用导致数据混乱</p></li><li><p>java8中lambda表达式的一些例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//帮助方法，用来获得一个指定元素数量模拟数据的ConcurrentHashMap</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ConcurrentHashMap&lt;String, Long&gt; <span class="title">getData</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//longStream.rangeClosed获取一个[1-count]的LongStream</span></span><br><span class="line">    <span class="keyword">return</span> LongStream.rangeClosed(<span class="number">1</span>, count)</span><br><span class="line">        <span class="comment">//将LongStream转化为Stream</span></span><br><span class="line">            .boxed()</span><br><span class="line">            .collect(Collectors.toConcurrentMap(i -&gt; UUID.randomUUID().toString(), </span><br><span class="line">                                                <span class="comment">//输入什么输出就是什么</span></span><br><span class="line">                                                Function.identity(),</span><br><span class="line">                                                (<span class="comment">//键冲突时候保留现有的值，O1)</span></span><br><span class="line">                    (o1, o2) -&gt; o1, ConcurrentHashMap::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用concurrentHashMap并不代表一定线程安全，只能保证原子性操作是线程安全的.</p></li><li><p>在 Java 中，CopyOnWriteArrayList 虽然是一个线程安全的 ArrayList，但因为其实现方式是，每次修改数据时都会复制一份数据出来，所以有明显的适用场景，即读多写少或者说希望无锁读的场景。 </p></li><li><p><strong>computeIfAbsent和putIfAbsent区别是三点</strong>：<br>1、当Key存在的时候，如果Value获取比较昂贵的话，putIfAbsent就白白浪费时间在获取这个昂贵的Value上（这个点特别注意）<br>2、Key不存在的时候，putIfAbsent返回null，小心空指针，而computeIfAbsent返回计算后的值<br>3、当Key不存在的时候，putIfAbsent允许put null进去，而computeIfAbsent不能，之后进行containsKey查询是有区别的（当然了，此条针对HashMap，ConcurrentHashMap不允许put null value进去） </p></li><li><p>思考与讨论</p><p>今天我们多次用到了 ThreadLocalRandom，你觉得是否可以把它的实例设置到静态变量中，在多线程情况下重用呢？ConcurrentHashMap 还提供了 putIfAbsent 方法，你能否通过查阅JDK 文档，说说 computeIfAbsent 和 putIfAbsent 方法的区别？ </p><p>答案：</p><blockquote><p>问题一：不可以。ThreadLocalRandom文档里写了Usages of this class should typically be of the form:ThreadLocalRandom.current().nextX(…)} (where X is Int, Long, etc)。<br>ThreadLocalRandom类中只封装了一些公用的方法，种子存放在各个线程中。<br>ThreadLocalRandom中存放一个单例的instance，调用current()方法返回这个instance，每个线程首次调用current()方法时，会在各个线程中初始化seed和probe。<br>nextX(）方法会调用nextSeed()，在其中使用各个线程中的种子，计算下一个种子并保存（UNSAFE.getLong(t, SEED) + GAMMA）。<br>所以，如果使用静态变量，直接调用nextX()方法就跳过了各个线程初始化的步骤，只会在每次调用nextSeed()时来更新种子。</p></blockquote><blockquote><p>问题二<br>1.参数不一样，putIfAbsent是值，computeIfAbsent是mappingFunction<br>2.返回值不一样，putIfAbsent是之前的值，computeIfAbsent是现在的值<br>3.putIfAbsent可以存入null，computeIfAbsent计算结果是null只会返回null，不会写入。 </p></blockquote></li></ol><h2 id="代码加锁：不要让“锁”事成为烦心事"><a href="#代码加锁：不要让“锁”事成为烦心事" class="headerlink" title="代码加锁：不要让“锁”事成为烦心事"></a>代码加锁：不要让“锁”事成为烦心事</h2><h3 id="加锁要考虑锁的粒度和场景问题"><a href="#加锁要考虑锁的粒度和场景问题" class="headerlink" title="加锁要考虑锁的粒度和场景问题"></a>加锁要考虑锁的粒度和场景问题</h3><p>在方法上加 synchronized 关键字实现加锁确实简单，也因此我曾看到一些业务代码中几乎所有方法都加了 synchronized，但这种滥用 synchronized 的做法：</p><p>一是，没必要。通常情况下 60% 的业务代码是三层架构，数据经过无状态的 Controller、Service、Repository 流转到数据库，没必要使用 synchronized 来保护什么数据。</p><p>二是，可能会极大地降低性能。使用 Spring 框架时，默认情况下 Controller、Service、Repository 是单例的，加上 synchronized 会导致整个程序几乎就只能支持单线程，造成极大的性能问题。</p><h2 id="线程池：业务代码最常用也最容易犯错的组件"><a href="#线程池：业务代码最常用也最容易犯错的组件" class="headerlink" title="线程池：业务代码最常用也最容易犯错的组件"></a>线程池：业务代码最常用也最容易犯错的组件</h2><h3 id="不建议使用-Executors-提供的两种快捷的线程池"><a href="#不建议使用-Executors-提供的两种快捷的线程池" class="headerlink" title="不建议使用 Executors 提供的两种快捷的线程池"></a><strong>不建议使用 Executors 提供的两种快捷的线程池</strong></h3><p>原因如下：我们需要根据自己的场景、并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型，以及拒绝策略，确保线程池的工作行为符合需求，一般都需要设置有界的工作队列和可控的线程数。<strong>任何时候，都应该为自定义线程池指定有意义的名称，以方便排查问题。当出现线程数量暴增、线程死锁、线程占用大量 CPU、线程执行出现异常等问题时，我们往往会抓取线程栈</strong>。此时，有意义的线程名称，就可以方便我们定位问题。 </p><p>除了建议手动声明线程池以外，我还建议用一些监控手段来观察线程池的状态。线程池这个组件往往会表现得任劳任怨、默默无闻，除非是出现了拒绝策略，否则压力再大都不会抛出一个异常。如果我们能提前观察到线程池队列的积压，或者线程数量的快速膨胀，往往可以提早发现并解决问题</p><h3 id="需要仔细斟酌线程池的混用策略，线程池的意义在于复用"><a href="#需要仔细斟酌线程池的混用策略，线程池的意义在于复用" class="headerlink" title="需要仔细斟酌线程池的混用策略，线程池的意义在于复用"></a>需要仔细斟酌线程池的混用策略，线程池的意义在于复用</h3><p>那这是不是意味着程序应该始终使用一个线程池呢？当然不是。通过第一小节的学习我们知道，要根据任务的“轻重缓急”来指定线程池的核心参数，包括线程数、回收策略和任务队列：<strong>对于执行比较慢、数量不大的 IO 任务，或许要考虑更多的线程数，而不需要太大的队列。而对于吞吐量较大的计算型任务，线程数量不宜过多，可以是 CPU 核数或核数 *2（理由是，线程一定调度到某个 CPU 进行执行，如果任务本身是 CPU 绑定的任务，那么过多的线程只会增加线程切换的开销，并不能提升吞吐量），但可能需要较长的队列来做缓冲</strong>。 </p><p> 就线程池混用问题，我想再和你补充一个坑：Java 8 的 parallel stream 功能，可以让我们很方便地并行处理集合中的元素，其背后是共享同一个 ForkJoinPool，默认并行度是 CPU 核数 -1。对于 CPU 绑定的任务来说，使用这样的配置比较合适，但如果集合操作涉及同步 IO 操作的话（比如数据库操作、外部服务调用等），建议自定义一个 ForkJoinPool（或普通线程池）。你可以参考第一讲的相关 Demo </p><h2 id="连接池：别让连接池帮了倒忙"><a href="#连接池：别让连接池帮了倒忙" class="headerlink" title="连接池：别让连接池帮了倒忙"></a>连接池：别让连接池帮了倒忙</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/java-errorcase/connectionpool.png" alt="连接池原理" title="">                </div>                <div class="image-caption">连接池原理</div>            </figure><p> 面对各种三方客户端的时候，只有先识别出其属于哪一种，才能理清楚使用方式。</p><ul><li><p><strong>连接池和连接分离的 API</strong>：有一个 XXXPool 类负责连接池实现，先从其获得连接 XXXConnection，然后用获得的连接进行服务端请求，完成后使用者需要归还连接。通常，XXXPool 是线程安全的，可以并发获取和归还连接，而 XXXConnection 是非线程安全的。对应到连接池的结构示意图中，XXXPool 就是右边连接池那个框，左边的客户端是我们自己的代码。</p></li><li><p><strong>内部带有连接池的 API</strong>：对外提供一个 XXXClient 类，通过这个类可以直接进行服务端请求；这个类内部维护了连接池，SDK 使用者无需考虑连接的获取和归还问题。一般而言，XXXClient 是线程安全的。对应到连接池的结构示意图中，整个 API 就是蓝色框包裹的部分。</p></li><li><p><strong>非连接池的 API</strong>：一般命名为 XXXConnection，以区分其是基于连接池还是单连接的，而不建议命名为 XXXClient 或直接是 XXX。直接连接方式的 API 基于单一连接，每次使用都需要创建和断开连接，性能一般，且通常不是线程安全的。对应到连接池的结构示意图中，这种形式相当于没有右边连接池那个框，客户端直接连接服务端创建连接。</p><p><strong>明确了 SDK 连接池的实现方式后，我们就大概知道了使用 SDK 的最佳实践：</strong></p></li><li><p>如果是分离方式，那么连接池本身一般是线程安全的，可以复用。每次使用需要从连接池获取连接，使用后归还，归还的工作由使用者负责。</p></li><li><p>如果是内置连接池，SDK 会负责连接的获取和归还，使用的时候直接复用客户端。</p></li><li><p>如果 SDK 没有实现连接池（大多数中间件、数据库的客户端 SDK 都会支持连接池），那通常不是线程安全的，而且短连接的方式性能不会很高，使用的时候需要考虑是否自己封装一个连接池。 </p></li></ul><h3 id="Jedis本身线程不安全，想要线程安全使用JedisPool获取Jedis实例"><a href="#Jedis本身线程不安全，想要线程安全使用JedisPool获取Jedis实例" class="headerlink" title="Jedis本身线程不安全，想要线程安全使用JedisPool获取Jedis实例"></a>Jedis本身线程不安全，想要线程安全使用JedisPool获取Jedis实例</h3><p>优雅的关闭线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        jedisPool.close();</span><br><span class="line">    &#125;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> Jedis 的 API 实现是我们说的三种类型中的第一种，也就是连接池和连接分离的 API，JedisPool 是线程安全的连接池，Jedis 是非线程安全的单一连接。</p><h3 id="连接池的配置不是一成不变的"><a href="#连接池的配置不是一成不变的" class="headerlink" title="连接池的配置不是一成不变的"></a>连接池的配置不是一成不变的</h3><p>为方便根据容量规划设置连接处的属性，连接池提供了许多参数，包括最小（闲置）连接、最大连接、闲置连接生存时间、连接生存时间等。其中，<strong>最重要的参数是最大连接数</strong>，它决定了连接池能使用的连接数量上限，达到上限后，新来的请求需要等待其他请求释放连接。</p><p>但，最大连接数不是设置得越大越好。如果设置得太大，不仅仅是客户端需要耗费过多的资源维护连接，更重要的是由于服务端对应的是多个客户端，每一个客户端都保持大量的连接，会给服务端带来更大的压力。这个压力又不仅仅是内存压力，可以想一下如果服务端的网络模型是一个 TCP 连接一个线程，那么几千个连接意味着几千个线程，如此多的线程会造成大量的线程切换开销。</p><p>当然，连接池最大连接数设置得太小，很可能会因为获取连接的等待时间太长，导致吞吐量低下，甚至超时无法获取连接。 </p><h2 id="HTTP调用：你考虑到超时、重试、并发了吗？"><a href="#HTTP调用：你考虑到超时、重试、并发了吗？" class="headerlink" title="HTTP调用：你考虑到超时、重试、并发了吗？"></a>HTTP调用：你考虑到超时、重试、并发了吗？</h2><p> 几乎所有的网络框架都会提供这么两个超时参数：</p><p>连接超时参数 ConnectTimeout，让用户配置建连阶段的最长等待时间；</p><p>读取超时参数 ReadTimeout，用来控制从 Socket 上读取数据的最长等待时间。</p><p>这两个参数看似是网络层偏底层的配置参数，不足以引起开发同学的重视。但，正确理解和配置这两个参数，对业务应用特别重要，毕竟超时不是单方面的事情，需要客户端和服务端对超时有一致的估计，协同配合方能平衡吞吐量和错误率。 </p><p> 因为 TCP 是先建立连接后传输数据，对于网络情况不是特别糟糕的服务调用，通常可以认为出现连接超时是网络问题或服务不在线，而出现读取超时是服务处理超时。确切地说，读取超时指的是，向 Socket 写入数据后，我们等到 Socket 返回数据的超时时间，其中包含的时间或者说绝大部分的时间，是服务端处理业务逻辑的时间。 </p><p>默认情况下 Feign 的读取超时是 1 秒，如此短的读取超时算是坑点一。 </p><p>如果要配置 Feign 的读取超时，就必须同时配置连接超时，才能生效。</p><p> 除了可以配置 Feign，也可以配置 Ribbon 组件的参数来修改两个超时时间。这里的坑点三是，参数首字母要大写，和 Feign 的配置不同。<code>ribbon.ReadTimeout=4000  ribbon.ConnectTimeout=4000</code>  </p><p><strong>同时配置 Feign 和 Ribbon 的参数，最终谁会生效？答案是feign</strong></p><p> 翻看 Ribbon 的源码可以发现，MaxAutoRetriesNextServer 参数默认为 1，也就是 Get 请求在某个服务端节点出现问题（比如读取超时）时，Ribbon 会自动重试一次： </p><h2 id="Spring事务生效"><a href="#Spring事务生效" class="headerlink" title="Spring事务生效"></a>Spring事务生效</h2><p>如果你捕获了异常，还想让事务生效，如下处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createUserRight1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        userRepository.save(<span class="keyword">new</span> UserEntity(name));</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"error"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        log.error(<span class="string">"create user failed"</span>, ex);</span><br><span class="line">        TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h2><h3 id="创建辅助索引的代价"><a href="#创建辅助索引的代价" class="headerlink" title="创建辅助索引的代价"></a>创建辅助索引的代价</h3><p> <strong>创建二级索引的代价，主要表现在维护代价、空间代价和回表代价三个方面</strong> </p><p> <strong>首先是维护代价。</strong>创建 N 个二级索引，就需要再创建 N 棵 B+ 树，新增数据时不仅要修改聚簇索引，还需要修改这 N 个二级索引。 </p><p> <strong>其次是空间代价。</strong>虽然二级索引不保存原始数据，但要保存索引列的数据，所以会占用更多的空间。比如，person 表创建了两个索引后，使用下面的 SQL 查看数据和索引占用的磁盘： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> DATA_LENGTH, INDEX_LENGTH <span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> TABLE_NAME=<span class="string">'person'</span></span><br></pre></td></tr></table></figure><p> <strong>最后是回表的代价。</strong>二级索引不保存原始数据，通过索引找到主键后需要再查询聚簇索引，才能得到我们要的数据 </p><p> 有时会因为统计信息的不准确或成本估算的问题，实际开销会和 MySQL 统计出来的差距较大，导致 MySQL 选择错误的索引或是直接选择走全表扫描，这个时候就需要<strong>人工干预，使用强制索引</strong>了。比如，像这样强制走 name_score 索引 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">FORCE</span> <span class="keyword">INDEX</span>(name_score) <span class="keyword">WHERE</span> <span class="keyword">NAME</span> &gt;<span class="string">'name84059'</span> <span class="keyword">AND</span> create_time&gt;<span class="string">'2020-01-24 05:00:00'</span></span><br></pre></td></tr></table></figure><p> <strong>在 MySQL 5.6 及之后的版本中，我们可以使用 optimizer trace 功能查看优化器生成执行计划的整个过程</strong>。有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询 </p><p> 如下代码所示，打开 optimizer_trace 后，再执行 SQL 就可以查询 information_schema.OPTIMIZER_TRACE 表查看执行计划了，最后可以关闭 optimizer_trace 功能： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=on"</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person <span class="keyword">WHERE</span> <span class="keyword">NAME</span> &gt;<span class="string">'name84059'</span> <span class="keyword">AND</span> create_time&gt;<span class="string">'2020-01-24 05:00:00'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.OPTIMIZER_TRACE;</span><br><span class="line"><span class="keyword">SET</span> optimizer_trace=<span class="string">"enabled=off"</span>;</span><br></pre></td></tr></table></figure><p>思考与讨论</p><p> 索引除了可以用于加速搜索外，还可以在排序时发挥作用，你能通过 EXPLAIN 来证明吗？你知道，在什么情况下针对排序索引会失效吗？ </p><blockquote><p> 第二个问题：<br>SQL中带order by且执行计划中Extra 这个字段中有”Using index”或者”Using index condition”表示用到索引，并且不用专门排序，因为索引本身就是有序的；<br>如果Extra有“Using filesort”表示的就是需要排序；</p><p>排序时：MySQL 会给每个线程分配一块内存用于排序，称为 sort_buffer。sort_buffer_size（sort_buffer）的大小。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。<br>上述排序中，只对原表的数据读了一遍，剩下的操作都是在 sort_buffer 和临时文件中执行的。但这个算法有一个问题，就是如果查询要返回的字段很多的话，那么 sort_buffer 里面要放的字段数太多，这样内存里能够同时放下的行数很少，要分成很多个临时文件，排序的性能会很差。所以如果单行很大，这个方法效率不够好。max_length_for_sort_data，是 MySQL 中专门控制用于排序的行数据的长度的一个参数。它的意思是，如果单行的长度超过这个值，MySQL 就认为单行太大，要换一个算法。称为 rowid 排序；<br>rowid排序简单的描述就是先取出ID和排序字段进行排序，排序结束后，用ID回表去查询select中出现的其他字段，多了一次回表操作，<br>对于 InnoDB 表来说，rowid 排序会要求回表多造成磁盘读，因此不会被优先选择。 </p></blockquote><h2 id="判等问题：程序里如何确定你就是你"><a href="#判等问题：程序里如何确定你就是你" class="headerlink" title="判等问题：程序里如何确定你就是你"></a>判等问题：程序里如何确定你就是你</h2><p> <strong>比较值的内容，除了基本类型只能使用 == 外，其他类型都需要使用 equals。</strong> </p><p> 对于自定义的类型，如果要实现 Comparable，请记得 equals、hashCode、compareTo 三者逻辑一致。 </p><h3 id="小心-Lombok-生成代码的“坑”"><a href="#小心-Lombok-生成代码的“坑”" class="headerlink" title="小心 Lombok 生成代码的“坑”"></a>小心 Lombok 生成代码的“坑”</h3><p> Lombok 的 @Data 注解会帮我们实现 equals 和 hashcode 方法，但是有继承关系时，Lombok 自动生成的方法可能就不是我们期望的了。我们先来研究一下其实现：定义一个 Person 类型，包含姓名和身份证两个字段： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String identity;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, String identity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.identity = identity;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对于身份证相同、姓名不同的两个 Person 对象： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person person1 = <span class="keyword">new</span> Person(<span class="string">"zhuye"</span>,<span class="string">"001"</span>);</span><br><span class="line">Person person2 = <span class="keyword">new</span> Person(<span class="string">"Joseph"</span>,<span class="string">"001"</span>);</span><br><span class="line">log.info(<span class="string">"person1.equals(person2) ? &#123;&#125;"</span>, person1.equals(person2));</span><br></pre></td></tr></table></figure><p> 使用 equals 判等会得到 false。如果你希望只要身份证一致就认为是同一个人的话，可以使用 <code>@EqualsAndHashCode.Exclude</code> 注解来修饰 name 字段，从 equals 和 hashCode 的实现中排除 name 字段： </p><p> 如果类型之间有继承，Lombok 会怎么处理子类的 equals 和 hashCode 呢？ </p><p> @EqualsAndHashCode 默认实现没有使用父类属性。 </p><p> 为解决这个问题，我们可以手动设置 callSuper 开关为 true，来覆盖这种默认行为： </p><p><code>@EqualsAndHashCode(callSuper = true)</code></p><h2 id="数值计算：注意精度、舍入和溢出问题"><a href="#数值计算：注意精度、舍入和溢出问题" class="headerlink" title="数值计算：注意精度、舍入和溢出问题"></a>数值计算：注意精度、舍入和溢出问题</h2><p> 这里给出浮点数运算避坑第一原则：使用 BigDecimal 表示和计算浮点数，且</p><h3 id="务必使用字符串的构造方法来初始化-BigDecimal："><a href="#务必使用字符串的构造方法来初始化-BigDecimal：" class="headerlink" title="务必使用字符串的构造方法来初始化 BigDecimal："></a><strong>务必使用字符串的构造方法来初始化 BigDecimal</strong>：</h3><p> <strong>BigDecimal 有 scale 和 precision 的概念，scale 表示小数点右边的位数，而 precision 表示精度，也就是有效数字的长度。</strong> </p><p> 对于 BigDecimal 乘法操作，返回值的 scale 是两个数的 scale 相加 </p><p> 浮点数避坑第二原则：浮点数的字符串格式化也要通过 BigDecimal 进行。 </p><p> 比如下面这段代码，使用 BigDecimal 来格式化数字 3.35，分别使用向下舍入和四舍五入方式取 1 位小数进行格式化： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal num1 = <span class="keyword">new</span> BigDecimal(<span class="string">"3.35"</span>);</span><br><span class="line">BigDecimal num2 = num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_DOWN);</span><br><span class="line">System.out.println(num2);</span><br><span class="line">BigDecimal num3 = num1.setScale(<span class="number">1</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">System.out.println(num3);</span><br></pre></td></tr></table></figure><p> 这次得到的结果是 3.3 和 3.4，符合预期 </p><p> 如果我们希望只比较 BigDecimal 的 value，可以使用 compareTo 方法 , equals 比较的是 BigDecimal 的 value 和 scale </p><p>比如如下返回false：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>).equals(<span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>)))</span><br></pre></td></tr></table></figure><p> BigDecimal 的 equals 和 hashCode 方法会同时考虑 value 和 scale，如果结合 HashSet 或 HashMap 使用的话就可能会出现麻烦。比如，我们把值为 1.0 的 BigDecimal 加入 HashSet，然后判断其是否存在值为 1 的 BigDecimal，得到的结果是 false： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet1 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hashSet1.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>));</span><br><span class="line">System.out.println(hashSet1.contains(<span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>)));<span class="comment">//返回false</span></span><br></pre></td></tr></table></figure><p> 解决这个问题的办法有两个：第一个方法是，使用 TreeSet 替换 HashSet。TreeSet 不使用 hashCode 方法，也不使用 equals 比较元素，而是使用 compareTo 方法，所以不会有问题。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>));</span><br><span class="line">System.out.println(treeSet.contains(<span class="keyword">new</span> BigDecimal(<span class="string">"1"</span>)));<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><p> 第二个方法是，把 BigDecimal 存入 HashSet 或 HashMap 前，先使用 stripTrailingZeros 方法去掉尾部的零，比较的时候也去掉尾部的 0，确保 value 相同的 BigDecimal，scale 也是一致的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;BigDecimal&gt; hashSet2 = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">hashSet2.add(<span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>).stripTrailingZeros());</span><br><span class="line">System.out.println(hashSet2.contains(<span class="keyword">new</span> BigDecimal(<span class="string">"1.000"</span>).stripTrailingZeros()));<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure><h3 id="小心数值溢出问题"><a href="#小心数值溢出问题" class="headerlink" title="小心数值溢出问题"></a>小心数值溢出问题</h3><p> 数值计算还有一个要小心的点是溢出，不管是 int 还是 long，所有的基本数值类型都有超出表达范围的可能性。比如，对 Long 的最大值进行 +1 操作： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">System.out.println(l + <span class="number">1</span>);</span><br><span class="line">System.out.println(l + <span class="number">1</span> == Long.MIN_VALUE);</span><br></pre></td></tr></table></figure><p> 输出结果是一个负数，因为 Long 的最大值 +1 变为了 Long 的最小值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-9223372036854775808</span><br><span class="line">true</span><br></pre></td></tr></table></figure><p> 显然这是发生了溢出，而且是默默的溢出，并没有任何异常。这类问题非常容易被忽略，改进方式有下面 2 种。<strong>方法一是，考虑使用 Math 类的 addExact、subtractExact 等 xxExact 方法进行数值运算，这些方法可以在数值溢出时主动抛出异常。</strong>我们来测试一下，使用 Math.addExact 对 Long 最大值做 +1 操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> l = Long.MAX_VALUE;</span><br><span class="line">    System.out.println(Math.addExact(l, <span class="number">1</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 执行后，可以得到 ArithmeticException，这是一个 RuntimeException： </p><p> <strong>方法二是，使用大数类 BigInteger。BigDecimal 是处理浮点数的专家，而 BigInteger 则是对大数进行科学计算的专家。</strong> </p><p> 如下代码，使用 BigInteger 对 Long 最大值进行 +1 操作；如果希望把计算结果转换一个 Long 变量的话，可以使用 BigInteger 的 longValueExact 方法，在转换出现溢出时，同样会抛出 ArithmeticException： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(String.valueOf(Long.MAX_VALUE));</span><br><span class="line">System.out.println(i.add(BigInteger.ONE).toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">long</span> l = i.add(BigInteger.ONE).longValueExact();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 输出结果如下： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">9223372036854775808</span><br><span class="line">java.lang.ArithmeticException: BigInteger out of long range</span><br><span class="line">  at java.math.BigInteger.longValueExact(BigInteger.java:4632)</span><br><span class="line">  at org.geekbang.time.commonmistakes.numeralcalculations.demo3.CommonMistakesApplication.right1(CommonMistakesApplication.java:37)</span><br><span class="line">  at org.geekbang.time.commonmistakes.numeralcalculations.demo3.CommonMistakesApplication.main(CommonMistakesApplication.java:11)</span><br></pre></td></tr></table></figure><p> 可以看到，通过 BigInteger 对 Long 的最大值加 1 一点问题都没有，当尝试把结果转换为 Long 类型时，则会提示 BigInteger out of long range。 </p><p> BigDecimal提供了 8 种舍入模式，你能通过一些例子说说它们的区别吗？ </p><blockquote><p> 1、 ROUND_UP<br>舍入远离零的舍入模式。<br>在丢弃非零部分之前始终增加数字（始终对非零舍弃部分前面的数字加1）。<br>注意，此舍入模式始终不会减少计算值的大小。<br>2、ROUND_DOWN<br>接近零的舍入模式。<br>在丢弃某部分之前始终不增加数字（从不对舍弃部分前面的数字加1，即截短）。<br>注意，此舍入模式始终不会增加计算值的大小。<br>3、ROUND_CEILING<br>接近正无穷大的舍入模式。<br>如果 BigDecimal 为正，则舍入行为与 ROUND_UP 相同；<br>如果为负，则舍入行为与 ROUND_DOWN 相同。<br>注意，此舍入模式始终不会减少计算值。<br>4、ROUND_FLOOR<br>接近负无穷大的舍入模式。<br>如果 BigDecimal 为正，则舍入行为与 ROUND_DOWN 相同；<br>如果为负，则舍入行为与 ROUND_UP 相同。<br>注意，此舍入模式始终不会增加计算值。<br>5、ROUND_HALF_UP<br>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。<br>如果舍弃部分 &gt;= 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同。<br>注意，这是我们大多数人在小学时就学过的舍入模式（四舍五入）。<br>6、ROUND_HALF_DOWN<br>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则为上舍入的舍入模式。<br>如果舍弃部分 &gt; 0.5，则舍入行为与 ROUND_UP 相同；否则舍入行为与 ROUND_DOWN 相同（五舍六入）。<br>7、ROUND_HALF_EVEN<br>向“最接近的”数字舍入，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。<br>如果舍弃部分左边的数字为奇数，则舍入行为与 ROUND_HALF_UP 相同；<br>如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。<br>注意，在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。<br>此舍入模式也称为<strong>“银行家舍入法”</strong>，主要在美国使用。四舍六入，五分两种情况。<br>如果前一位为奇数，则入位，否则舍去。<br>以下例子为保留小数点1位，那么这种舍入方式下的结果。<br>1.15&gt;1.2 1.25&gt;1.2<br>8、ROUND_UNNECESSARY<br>断言请求的操作具有精确的结果，因此不需要舍入。<br>如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。</p></blockquote><h2 id="集合类：坑满地的List列表操作"><a href="#集合类：坑满地的List列表操作" class="headerlink" title="集合类：坑满地的List列表操作"></a>集合类：坑满地的List列表操作</h2><h3 id="使用-Arrays-asList-把数据转换为-List-的三个坑"><a href="#使用-Arrays-asList-把数据转换为-List-的三个坑" class="headerlink" title="使用 Arrays.asList 把数据转换为 List 的三个坑"></a>使用 Arrays.asList 把数据转换为 List 的三个坑</h3><p> 在如下代码中，我们初始化三个数字的 int[]数组，然后使用 Arrays.asList 把数组转换为 List： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list = Arrays.asList(arr);</span><br><span class="line">log.info(<span class="string">"list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;"</span>, list, list.size(), list.get(<span class="number">0</span>).getClass());</span><br></pre></td></tr></table></figure><p> 但，这样初始化的 List 并不是我们期望的包含 3 个数字的 List。通过日志可以发现，这个 List 包含的其实是一个 int 数组，整个 List 的元素个数是 1，元素类型是整数数组。 </p><p> 其原因是，只能是把 int 装箱为 Integer，不可能把 int 数组装箱为 Integer 数组。我们知道，Arrays.asList 方法传入的是一个泛型 T 类型可变参数，最终 int 数组整体作为了一个对象成为了泛型类型 T： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">asList</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 直接遍历这样的 List 必然会出现 Bug，修复方式有两种，如果使用 Java8 以上版本可以使用 Arrays.stream 方法来转换，否则可以把 int 数组声明为包装类型 Integer 数组： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list1 = Arrays.stream(arr1).boxed().collect(Collectors.toList());</span><br><span class="line">log.info(<span class="string">"list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;"</span>, list1, list1.size(), list1.get(<span class="number">0</span>).getClass());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Integer[] arr2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">List list2 = Arrays.asList(arr2);</span><br><span class="line">log.info(<span class="string">"list:&#123;&#125; size:&#123;&#125; class:&#123;&#125;"</span>, list2, list2.size(), list2.get(<span class="number">0</span>).getClass());</span><br></pre></td></tr></table></figure><p> <strong>第二个坑，Arrays.asList 返回的 List 不支持增删操作</strong>。Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList </p><p> <strong>第三个坑，对原始数组的修改会影响到我们获得的那个 List。</strong> </p><p> 看一下 ArrayList 的实现，可以发现 ArrayList 其实是直接使用了原始的数组。所以，我们要特别小心，把通过 Arrays.asList 获得的 List 交给其他方法处理，很容易因为共享了数组，相互修改产生 Bug。 </p><p> 修复方式比较简单，重新 new 一个 ArrayList 初始化 Arrays.asList 返回的 List 即可： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>&#125;;</span><br><span class="line">List list = <span class="keyword">new</span> ArrayList(Arrays.asList(arr));</span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">"4"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    list.add(<span class="string">"5"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">    ex.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"arr:&#123;&#125; list:&#123;&#125;"</span>, Arrays.toString(arr), list);</span><br></pre></td></tr></table></figure><h3 id="使用-List-subList-进行切片操作居然会导致-OOM？"><a href="#使用-List-subList-进行切片操作居然会导致-OOM？" class="headerlink" title="使用 List.subList 进行切片操作居然会导致 OOM？"></a>使用 List.subList 进行切片操作居然会导致 OOM？</h3><p>业务开发时常常要对 List 做切片处理，即取出其中部分元素构成一个新的 List，我们通常会想到使用 List.subList 方法。但，和 Arrays.asList 的问题类似，List.subList 返回的子 List 不是一个普通的 ArrayList。这个子 List 可以认为是原始 List 的视图，会和原始 List 相互影响。如果不注意，很可能会因此产生 OOM 问题 </p><p> SubList 相当于原始 List 的视图，那么避免相互影响的修复方式有两种：一种是，不直接使用 subList 方法返回的 SubList，而是重新使用 new ArrayList，在构造方法传入 SubList，来构建一个独立的 ArrayList；另一种是，对于 Java 8 使用 Stream 的 skip 和 limit API 来跳过流中的元素，以及限制流中元素的个数，同样可以达到 SubList 切片的目的。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：</span></span><br><span class="line">List&lt;Integer&gt; subList = <span class="keyword">new</span> ArrayList&lt;&gt;(list.subList(<span class="number">1</span>, <span class="number">4</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二：</span></span><br><span class="line">List&lt;Integer&gt; subList = list.stream().skip(<span class="number">1</span>).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p> 如果要对大 ArrayList 进行去重操作，也不建议使用 contains 方法，而是可以考虑使用 HashSet 进行去重 </p><h2 id="空值处理：分不清楚的null和恼人的空指针"><a href="#空值处理：分不清楚的null和恼人的空指针" class="headerlink" title="空值处理：分不清楚的null和恼人的空指针"></a>空值处理：分不清楚的null和恼人的空指针</h2><p> <strong>NullPointerException 是 Java 代码中最常见的异常，最可能出现的场景归为以下 5 种</strong>：</p><ul><li>参数值是 Integer 等包装类型，使用时因为自动拆箱出现了空指针异常；</li><li>字符串比较出现空指针异常；</li><li>诸如 ConcurrentHashMap 这样的容器不支持 Key 和 Value 为 null，强行 put null 的 Key 或 Value 会出现空指针异常；</li><li>A 对象包含了 B，在通过 A 对象的字段获得 B 之后，没有对字段判空就级联调用 B 的方法出现空指针异常；</li><li>方法或远程服务返回的 List 不是空而是 null，没有进行判空就直接调用 List 的方法出现空指针异常。 </li></ul><p> 纯粹的空指针判空这种修复方式。如果要先判空后处理，大多数人会想到使用 if-else 代码块。但，这种方式既增加代码量又会降低易读性，我们可以尝试利用 Java 8 的 Optional 类来消除这样的 if-else 逻辑，使用一行代码进行判空和处理。修复思路如下： </p><ul><li><p>对于 Integer 的判空，可以使用 Optional.ofNullable 来构造一个 Optional，然后使用 orElse(0) 把 null 替换为默认值再进行 +1 操作。</p></li><li><p>对于 String 和字面量的比较，可以把字面量放在前面，比如”OK”.equals(s)，这样即使 s 是 null 也不会出现空指针异常；而对于两个可能为 null 的字符串变量的 equals 比较，可以使用 Objects.equals，它会做判空处理。</p></li><li><p>对于 ConcurrentHashMap，既然其 Key 和 Value 都不支持 null，修复方式就是不要把 null 存进去。HashMap 的 Key 和 Value 可以存入 null，而 ConcurrentHashMap 看似是 HashMap 的线程安全版本，却不支持 null 值的 Key 和 Value，这是容易产生误区的一个地方。</p></li><li><p>对于类似 fooService.getBarService().bar().equals(“OK”) 的级联调用，需要判空的地方有很多，包括 fooService、getBarService() 方法的返回值，以及 bar 方法返回的字符串。如果使用 if-else 来判空的话可能需要好几行代码，但使用 Optional 的话一行代码就够了。</p></li><li><p>对于 rightMethod 返回的 List，由于不能确认其是否为 null，所以在调用 size 方法获得列表大小之前，同样可以使用 Optional.ofNullable 包装一下返回值，然后通过.orElse(Collections.emptyList()) 实现在 List 为 null 的时候获得一个空的 List，最后再调用 size 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;String&gt; <span class="title">rightMethod</span><span class="params">(FooService fooService, Integer i, String s, String t)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"result &#123;&#125; &#123;&#125; &#123;&#125; &#123;&#125;"</span>, Optional.ofNullable(i).orElse(<span class="number">0</span>) + <span class="number">1</span>, <span class="string">"OK"</span>.equals(s), Objects.equals(s, t), <span class="keyword">new</span> HashMap&lt;String, String&gt;().put(<span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">    Optional.ofNullable(fooService)</span><br><span class="line">            .map(FooService::getBarService)</span><br><span class="line">            .filter(barService -&gt; <span class="string">"OK"</span>.equals(barService.bar()))</span><br><span class="line">            .ifPresent(result -&gt; log.info(<span class="string">"OK"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">right</span><span class="params">(@RequestParam(value = <span class="string">"test"</span>, defaultValue = <span class="string">"1111"</span>)</span> String test) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Optional.ofNullable(rightMethod(test.charAt(<span class="number">0</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="keyword">new</span> FooService(),</span><br><span class="line">            test.charAt(<span class="number">1</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="number">1</span>,</span><br><span class="line">            test.charAt(<span class="number">2</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>,</span><br><span class="line">            test.charAt(<span class="number">3</span>) == <span class="string">'1'</span> ? <span class="keyword">null</span> : <span class="string">"OK"</span>))</span><br><span class="line">            .orElse(Collections.emptyList()).size();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>使用判空方式或 Optional 方式来避免出现空指针异常，不一定是解决问题的最好方式，空指针没出现可能隐藏了更深的 Bug</strong>  因此，解决空指针异常，还是要真正 case by case 地定位分析案例，然后再去做判空处理，而处理时也并不只是判断非空然后进行正常业务流程这么简单，同样需要考虑为空的时候是应该出异常、设默认值还是记录日志等。 </p><h3 id="小心-MySQL-中有关-NULL-的三个坑"><a href="#小心-MySQL-中有关-NULL-的三个坑" class="headerlink" title="小心 MySQL 中有关 NULL 的三个坑"></a>小心 MySQL 中有关 NULL 的三个坑</h3></li><li><p>MySQL 中 sum 函数没统计到任何记录时，会返回 null 而不是 0，可以使用 IFNULL 函数把 null 转换为 0；</p></li><li><p>MySQL 中 count 字段不统计 null 值，COUNT(*) 才是统计所有记录数量的正确方式。</p></li><li><p>MySQL 中使用诸如 =、&lt;、&gt; 这样的算数比较操作符比较 NULL 的结果总是 NULL，这种比较就显得没有任何意义，需要使用 IS NULL、IS NOT NULL 或 ISNULL() 函数来比较。 </p></li></ul><h2 id="捕获和处理异常容易犯的错"><a href="#捕获和处理异常容易犯的错" class="headerlink" title="捕获和处理异常容易犯的错"></a>捕获和处理异常容易犯的错</h2><p> <strong>“统一异常处理”方式正是我要说的第一个错：不在业务代码层面考虑异常处理，仅在框架层面粗犷捕获和处理异常。</strong>  </p><p><strong>不建议在框架层面进行异常的自动、统一处理，尤其不要随意捕获异常。但，框架可以做兜底工作</strong>。如果异常上升到最上层逻辑还是无法处理的话，可以以统一的方式进行异常转换，比如通过 @RestControllerAdvice + @ExceptionHandler，来捕获这些“未处理”异常： </p><ul><li>对于自定义的业务异常，以 Warn 级别的日志记录异常以及当前 URL、执行方法等信息后，提取异常中的错误码和消息等信息，转换为合适的 API 包装体返回给 API 调用方；</li><li>对于无法处理的系统异常，以 Error 级别的日志记录异常和上下文信息（比如 URL、参数、用户 ID）后，转换为普适的“服务器忙，请稍后再试”异常信息，同样以 API 包装体返回给调用方。 </li></ul><p>比如下面的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestControllerExceptionHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> GENERIC_SERVER_ERROR_CODE = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String GENERIC_SERVER_ERROR_MESSAGE = <span class="string">"服务器忙，请稍后再试"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> APIResponse <span class="title">handle</span><span class="params">(HttpServletRequest req, HandlerMethod method, Exception ex)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BusinessException) &#123;</span><br><span class="line">            BusinessException exception = (BusinessException) ex;</span><br><span class="line">            log.warn(String.format(<span class="string">"访问 %s -&gt; %s 出现业务异常！"</span>, req.getRequestURI(), method.toString()), ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> APIResponse(<span class="keyword">false</span>, <span class="keyword">null</span>, exception.getCode(), exception.getMessage());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.error(String.format(<span class="string">"访问 %s -&gt; %s 出现系统异常！"</span>, req.getRequestURI(), method.toString()), ex);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> APIResponse(<span class="keyword">false</span>, <span class="keyword">null</span>, GENERIC_SERVER_ERROR_CODE, GENERIC_SERVER_ERROR_MESSAGE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>第二个错，捕获了异常后直接生吞。在任何时候，我们捕获了异常都不应该生吞，也就是直接丢弃异常不记录、不抛出。</strong></p><p>这样的处理方式还不如不捕获异常，因为被生吞掉的异常一旦导致 Bug，就很难在程序中找到蛛丝马迹，使得 Bug 排查工作难上加难。 </p><p> <strong>第三个错，丢弃异常的原始信息。</strong>我们来看两个不太合适的异常处理方式，虽然没有完全生吞异常，但也丢失了宝贵的异常信息。 </p><p> 像这样调用 readFile 方法，捕获异常后，完全不记录原始异常，直接抛出一个转换后异常，导致出了问题不知道 IOException 具体是哪里引起的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong1"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        readFile();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">//原始异常信息丢失  </span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"系统忙请稍后再试"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 或者是这样，只记录了异常消息，却丢失了异常的类型、栈等重要信息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">//只保留了异常消息，栈没有记录</span></span><br><span class="line">    log.error(<span class="string">"文件读取错误, &#123;&#125;"</span>, e.getMessage());</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"系统忙请稍后再试"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 留下的日志是这样的，看完一脸茫然，只知道文件读取错误的文件名，至于为什么读取错误、是不存在还是没权限，完全不知道。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[12:57:19.746] [http-nio-45678-exec-1] [ERROR] [.g.t.c.e.d.HandleExceptionController:35  ] - 文件读取错误, a_file</span><br></pre></td></tr></table></figure><p> 这两种处理方式都不太合理，可以改为如下方式： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">"文件读取错误"</span>, e);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"系统忙请稍后再试"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 或者，把原始异常作为转换后新异常的 cause，原始异常信息同样不会丢： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"系统忙请稍后再试"</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>第四个错，抛出异常时不指定任何消息</strong>。我见过一些代码中的偷懒做法，直接抛出没有 message 的异常： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br></pre></td></tr></table></figure><p> 如果你捕获了异常打算处理的话，除了通过日志正确记录异常原始信息外，通常还有三种处理模式 </p><ul><li>转换，即转换新的异常抛出。对于新抛出的异常，最好具有特定的分类和明确的异常消息，而不是随便抛一个无关或没有任何信息的异常，并最好通过 cause 关联老异常。</li><li>重试，即重试之前的操作。比如远程调用服务端过载超时的情况，盲目重试会让问题更严重，需要考虑当前情况是否适合重试。</li><li>恢复，即尝试进行降级处理，或使用默认值来替代原始数据 </li></ul><h3 id="小心-finally-中的异常"><a href="#小心-finally-中的异常" class="headerlink" title="小心 finally 中的异常"></a>小心 finally 中的异常</h3><p> 有些时候，我们希望不管是否遇到异常，逻辑完成后都要释放资源，这时可以使用 finally 代码块而跳过使用 catch 代码块。但要千万小心 finally 代码块中的异常，因为资源释放处理等收尾操作同样也可能出现异常。比如下面这段代码，我们在 finally 中抛出一个异常： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"wrong"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wrong</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="comment">//异常丢失</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 最后在日志中只能看到 finally 中的异常，虽然 try 中的逻辑出现了异常，但却被 finally 中的异常覆盖了。这是非常危险的，特别是 finally 中出现的异常是偶发的，就会在部分时候覆盖 try 中的异常，让问题更不明显： </p><p> 至于异常为什么被覆盖，原因也很简单，因为一个方法无法出现两个异常。修复方式是，finally 代码块自己负责异常捕获和处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            log.error(<span class="string">"finally"</span>, ex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 或者可以把 try 中的异常作为主异常抛出，使用 addSuppressed 方法把 finally 中的异常附加到主异常上 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"right2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">right2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Exception e = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.info(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"try"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        e = ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        log.info(<span class="string">"finally"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"finally"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e!= <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.addSuppressed(ex);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                e = ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 运行方法可以得到如下异常信息，其中同时包含了主异常和被屏蔽的异常： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: <span class="keyword">try</span></span><br><span class="line">  at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:<span class="number">69</span>)</span><br><span class="line">  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">  ...</span><br><span class="line">  Suppressed: java.lang.RuntimeException: <span class="keyword">finally</span></span><br><span class="line">    at org.geekbang.time.commonmistakes.exception.finallyissue.FinallyIssueController.right2(FinallyIssueController.java:<span class="number">75</span>)</span><br><span class="line">    ... <span class="number">54</span> common frames omitted</span><br></pre></td></tr></table></figure><p> 其实这正是 try-with-resources 语句的做法，对于实现了 AutoCloseable 接口的资源，建议使用 try-with-resources 来释放资源，否则也可能会产生刚才提到的，释放资源时出现的异常覆盖主异常的问题。 </p><p><strong>千万别把异常定义为静态变量</strong></p><h3 id="提交线程池的任务出了异常会怎么样？-提交线程池的任务出了异常会怎么样？"><a href="#提交线程池的任务出了异常会怎么样？-提交线程池的任务出了异常会怎么样？" class="headerlink" title="提交线程池的任务出了异常会怎么样？  提交线程池的任务出了异常会怎么样？"></a>提交线程池的任务出了异常会怎么样？  提交线程池的任务出了异常会怎么样？</h3><p> 修复方式有 2 步：</p><p>以 execute 方法提交到线程池的异步任务，最好在任务内部做好异常处理；</p><p>设置自定义的异常处理程序作为保底，比如在声明线程池时自定义线程池的未捕获异常处理程序： </p><p> 通过线程池 ExecutorService 的 execute 方法提交任务到线程池处理，如果出现异常会导致线程退出，控制台输出中可以看到异常信息。那么，把 execute 方法改为 submit，线程还会退出吗，异常还能被处理程序捕获到吗？ </p><p> 线程没退出 ,异常也没记录被生吞了 </p><p> 查看 FutureTask 源码可以发现，在执行任务出现异常之后，异常存到了一个 outcome 字段中，只有在调用 get 方法获取 FutureTask 结果的时候，才会以 ExecutionException 的形式重新抛出异常： </p><p>思考与讨论：</p><p> 关于在 finally 代码块中抛出异常的坑，如果在 finally 代码块中返回值，你觉得程序会以 try 或 catch 中返回值为准，还是以 finally 中的返回值为准呢？</p><p>对于手动抛出的异常，不建议直接使用 Exception 或 RuntimeException，通常建议复用 JDK 中的一些标准异常，比如IllegalArgumentException、IllegalStateException、UnsupportedOperationException，你能说说它们的适用场景，并列出更多常用异常吗？ </p><blockquote><p>第一个问题：<br>肯定是以finally语句块为准。<br>原因：首先需要明白的是在编译生成的字节码中，每个方法都附带一个异常表。异常表中的每一个条目代表一个异常处理器，并且由 from 指针、to 指针、target 指针以及所捕获的异常类型构成。这些指针的值是字节码索引（bytecode index，bci），用以定位字节码。其中，from 指针和 to 指针标示了该异常处理器所监控的范围，例如 try 代码块所覆盖的范围。target 指针则指向异常处理器的起始位置，例如 catch 代码块的起始位置；<br>当程序触发异常时，Java 虚拟机会从上至下遍历异常表中的所有条目。当触发异常的字节码的索引值在某个异常表条目的监控范围内，Java 虚拟机会判断所抛出的异常和该条目想要捕获的异常是否匹配。如果匹配，Java 虚拟机会将控制流转移至该条目 target 指针指向的字节码。如果遍历完所有异常表条目，Java 虚拟机仍未匹配到异常处理器，那么它会弹出当前方法对应的 Java 栈帧，并且在调用者（caller）中重复上述操作。在最坏情况下，Java 虚拟机需要遍历当前线程 Java 栈上所有方法的异常表。所以异常操作是一个非常耗费性能的操作；<br>finally 代码块的原理是复制 finally 代码块的内容，分别放在 try-catch 代码块所有正常执行路径以及异常执行路径的出口中。所以不管是是正常还是异常执行，finally都是最后执行的，所以肯定是finally语句块中为准。</p><p>第二个问题：<br>IllegalArgumentException：不合法的参数异常，比如说限制不能为空或者有指定的发小范围，调用方没有按照规定传递参数，就可以抛出这个异常；<br>IllegalStateException：如果有状态流转的概念在里面（比如状态机），状态只能从A-&gt;B-&gt;C,若状态直接从A-&gt;C,就可以抛出该异常；<br>UnsupportedOperationException：不支持该操作异常，比如非抽象父类中有个方法，子类必须实现，父类中的方法就可以抛出次异常。老师在集合坑中提到的Arrays.asList 返回的 List 并不是我们期望的 java.util.ArrayList，而是 Arrays 的内部类 ArrayList。ArrayList 内部类继承自 AbstractList 类，并没有覆写父类的 add 方法，而父类中 add 方法的实现，就是抛出 UnsupportedOperationException。 </p></blockquote><h2 id="日志：日志记录真没你想象的那么简单"><a href="#日志：日志记录真没你想象的那么简单" class="headerlink" title="日志：日志记录真没你想象的那么简单"></a>日志：日志记录真没你想象的那么简单</h2><p> Logback、Log4j、Log4j2、commons-logging、JDK 自带的 java.util.logging 等，都是 Java 体系的日志框架，确实非常多。而不同的类库，还可能选择使用不同的日志框架。这样一来，日志的统一管理就变得非常困难。为了解决这个问题，就有了 SLF4J（Simple Logging Facade For Java），如下图所示： </p><p><img src="https://www.enjoyican.com/img/java-errorcase/log-facade.png" alt="日志实现"></p><p> <strong>SLF4J 实现了三种功能：</strong></p><ul><li><p>一是提供了统一的日志门面 API，即图中紫色部分，实现了中立的日志记录 API。</p></li><li><p>二是桥接功能，即图中蓝色部分，用来把各种日志框架的 API（图中绿色部分）桥接到 SLF4J API。这样一来，即便你的程序中使用了各种日志 API 记录日志，最终都可以桥接到 SLF4J 门面 API。</p></li><li><p>三是适配功能，即图中红色部分，可以实现 SLF4J API 和实际日志框架（图中灰色部分）的绑定。SLF4J 只是日志标准，我们还是需要一个实际的日志框架。日志框架本身没有实现 SLF4J API，所以需要有一个前置转换。Logback 就是按照 SLF4J API 标准实现的，因此不需要绑定模块做转换。 </p><p><strong>需要理清楚的是，虽然我们可以使用 log4j-over-slf4j 来实现 Log4j 桥接到 SLF4J，也可以使用 slf4j-log4j12 实现 SLF4J 适配到 Log4j，也把它们画到了一列，但是它不能同时使用它们，否则就会产生死循环。jcl 和 jul 也是同样的道理。</strong> </p><p>虽然图中有 4 个灰色的日志实现框架，但我看到的业务系统使用最广泛的是 Logback 和 Log4j，它们是同一人开发的。Logback 可以认为是 Log4j 的改进版本，我更推荐使用 , Spring Boot 是目前最流行的 Java 框架，它的日志框架也用的是 Logback 。</p></li></ul><p>查看 Spring Boot 的 Maven 依赖树，可以发现 spring-boot-starter 模块依赖了 spring-boot-starter-logging 模块，而 spring-boot-starter-logging 模块又帮我们自动引入了 logback-classic（包含了 SLF4J 和 Logback 日志框架）和 SLF4J 的一些适配器。其中，log4j-to-slf4j 用于实现 Log4j2 API 到 SLF4J 的桥接，jul-to-slf4j 则是实现 java.util.logging API 到 SLF4J 的桥接 ：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/java-errorcase/springboot-log-dependency.png" alt="springboot日志依赖" title="">                </div>                <div class="image-caption">springboot日志依赖</div>            </figure><h3 id="为什么我的日志会重复记录"><a href="#为什么我的日志会重复记录" class="headerlink" title="为什么我的日志会重复记录"></a>为什么我的日志会重复记录</h3><p> 日志重复记录在业务上非常常见，不但给查看日志和统计工作带来不必要的麻烦，还会增加磁盘和日志收集系统的负担 </p><p> <strong>第一个案例是，logger 配置继承关系导致日志重复记录。</strong> </p><p> 首先，定义一个方法实现 debug、info、warn 和 error 四种日志的记录： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Log</span>4j2</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"logging"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoggingController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"log"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.debug(<span class="string">"debug"</span>);</span><br><span class="line">        log.info(<span class="string">"info"</span>);</span><br><span class="line">        log.warn(<span class="string">"warn"</span>);</span><br><span class="line">        log.error(<span class="string">"error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 使用下面的 Logback 配置：</p><ul><li>第 11 和 12 行设置了全局的日志级别为 INFO，日志输出使用 CONSOLE Appender。</li><li>第 3 到 7 行，首先将 CONSOLE Appender 定义为 ConsoleAppender，也就是把日志输出到控制台（System.out/System.err）；然后通过 PatternLayout 定义了日志的输出格式。关于格式化字符串的各种使用方式，你可以进一步查阅官方文档。</li><li>第 8 到 10 行实现了一个 Logger 配置，将应用包的日志级别设置为 DEBUG、日志输出同样使用 CONSOLE Appender。 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 这段配置看起来没啥问题，但执行方法后出现了日志重复记录的问题： </p><p><img src="https://www.enjoyican.com/img/java-errorcase/log-repeat.png" alt="日志重复"></p><p> 从配置文件的第 9 和 12 行可以看到，CONSOLE 这个 Appender 同时挂载到了两个 Logger 上，一个是我们定义的 ，一个是 ，由于我们定义的 继承自 ，所以同一条日志既会通过 logger 记录，也会发送到 root 记录，因此应用 package 下的日志出现了重复记录。 </p><p> 这个同学如此配置的初衷是实现自定义的 logger 配置，让应用内的日志暂时开启 DEBUG 级别的日志记录。其实，他完全不需要重复挂载 Appender，去掉 下挂载的 Appender 即可： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p> 如果自定义的 需要把日志输出到不同的 Appender，比如将应用的日志输出到文件 app.log、把其他框架的日志输出到控制台，可以设置 的 additivity 属性为 false，这样就不会继承 的 Appender 了： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"org.geekbang.time.commonmistakes.logging"</span> <span class="attr">level</span>=<span class="string">"DEBUG"</span> <span class="attr">additivity</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>第二个案例是，错误配置 LevelFilter 造成日志重复记录</strong> </p><p> 一般互联网公司都会使用 ELK 三件套来统一收集日志，有一次我们发现 Kibana 上展示的日志有部分重复，一直怀疑是 Logstash 配置错误，但最后发现还是 Logback 的配置错误引起的。这个项目的日志是这样配置的：在记录日志到控制台的同时，把日志记录按照不同的级别记录到两个文件中： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"logDir"</span> <span class="attr">value</span>=<span class="string">"./logs"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"app.name"</span> <span class="attr">value</span>=<span class="string">"common-mistakes"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_info.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ERROR_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender</span></span></span><br><span class="line"><span class="tag"><span class="string">"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_error.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.ThresholdFilter"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">level</span>&gt;</span>WARN<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"INFO_FILE"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ERROR_FILE"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>第 31 到 35 行定义的 root 引用了三个 Appender。</p></li><li><p>第 5 到 9 行是第一个 ConsoleAppender，用于把所有日志输出到控制台。</p></li><li><p>第 10 到 19 行定义了一个 FileAppender，用于记录文件日志，并定义了文件名、记录日志的格式和编码等信息。最关键的是，第 12 到 14 行定义的 LevelFilter 过滤日志，将过滤级别设置为 INFO，目的是希望 _info.log 文件中可以记录 INFO 级别的日志。</p></li><li><p>第 20 到 30 行定义了一个类似的 FileAppender，并使用 ThresholdFilter 来过滤日志，过滤级别设置为 WARN，目的是把 WARN 以上级别的日志记录到另一个 _error.log 文件中。 </p><p>运行一下测试程序： </p></li></ul><p><img src="https://www.enjoyican.com/img/java-errorcase/log-repeat-2.png" alt="日志重复2.png"></p><p> 可以看到，_info.log 中包含了 INFO、WARN 和 ERROR 三个级别的日志，不符合我们的预期；error.log 包含了 WARN 和 ERROR 两个级别的日志。因此，造成了日志的重复收集。 </p><p> 为了分析日志重复的原因，我们来复习一下 ThresholdFilter 和 LevelFilter 的配置方式。 </p><p> 分析 ThresholdFilter 的源码发现，当日志级别大于等于配置的级别时返回 NEUTRAL，继续调用过滤器链上的下一个过滤器；否则，返回 DENY 直接拒绝记录日志： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThresholdFilter</span> <span class="keyword">extends</span> <span class="title">Filter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">if</span> (event.getLevel().isGreaterOrEqual(level)) &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> FilterReply.DENY;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在这个案例中，把 ThresholdFilter 设置为 WARN，可以记录 WARN 和 ERROR 级别的日志。</p><p>LevelFilter 用来比较日志级别，然后进行相应处理：如果匹配就调用 onMatch 定义的处理方式，默认是交给下一个过滤器处理（AbstractMatcherFilter 基类中定义的默认值）；否则，调用 onMismatch 定义的处理方式，默认也是交给下一个过滤器处理。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LevelFilter</span> <span class="keyword">extends</span> <span class="title">AbstractMatcherFilter</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> FilterReply <span class="title">decide</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!isStarted()) &#123;</span><br><span class="line">          <span class="keyword">return</span> FilterReply.NEUTRAL;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (event.getLevel().equals(level)) &#123;</span><br><span class="line">          <span class="keyword">return</span> onMatch;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> onMismatch;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractMatcherFilter</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Filter</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> FilterReply onMatch = FilterReply.NEUTRAL;</span><br><span class="line">    <span class="keyword">protected</span> FilterReply onMismatch = FilterReply.NEUTRAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 和 ThresholdFilter 不同的是，<strong>LevelFilter 仅仅配置 level 是无法真正起作用的</strong>。<strong>由于没有配置 onMatch 和 onMismatch 属性，所以相当于这个过滤器是无用的</strong>，导致 INFO 以上级别的日志都记录了。定位到问题后，修改方式就很明显了：配置 LevelFilter 的 onMatch 属性为 ACCEPT，表示接收 INFO 级别的日志；配置 onMismatch 属性为 DENY，表示除了 INFO 级别都不记录： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"INFO_FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">File</span>&gt;</span>$&#123;logDir&#125;/$&#123;app.name&#125;_info.log<span class="tag">&lt;/<span class="name">File</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.filter.LevelFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">level</span>&gt;</span>INFO<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用异步日志改善性能的坑"><a href="#使用异步日志改善性能的坑" class="headerlink" title="使用异步日志改善性能的坑"></a>使用异步日志改善性能的坑</h3><p> 掌握了把日志输出到文件中的方法后，我们接下来面临的问题是，如何避免日志记录成为应用的性能瓶颈。这可以帮助我们解决，磁盘（比如机械磁盘）IO 性能较差、日志量又很大的情况下，如何记录日志的问题。</p><p> 定义如下的日志配置，一共有两个 Appender：</p><ul><li>FILE 是一个 FileAppender，用于记录所有的日志；</li><li>CONSOLE 是一个 ConsoleAppender，用于记录带有 time 标记的日志。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"FILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>app.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.encoder.PatternLayoutEncoder"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.PatternLayout"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] [%thread] [%-5level] [%logger&#123;40&#125;:%line] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.filter.EvaluatorFilter"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">evaluator</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.boolex.OnMarkerEvaluator"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">marker</span>&gt;</span>time<span class="tag">&lt;/<span class="name">marker</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">evaluator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p> 这段代码中有个 EvaluatorFilter（求值过滤器），用于判断日志是否符合某个条件。在后续的代码中，我们会把大量日志输出到文件中，日志文件会非常大，如果性能测试结果也混在其中的话，就很难找到那条日志。所以，这里我们使用 EvaluatorFilter 对日志按照标记进行过滤，并将过滤出的日志单独输出到控制台上。在这个案例中，我们给输出测试结果的那条日志上做了 time 标记。配合使用标记和 EvaluatorFilter，实现日志的按标签过滤，是一个不错的小技巧。 </p><p> 使用 Logback 提供的 AsyncAppender 即可实现异步的日志记录。AsyncAppende 类似装饰模式，也就是在不改变类原有基本功能的情况下为其增添新功能。这样，我们就可以把 AsyncAppender 附加在其他的 Appender 上，将其变为异步的。定义一个异步 Appender ASYNCFILE，包装之前的同步文件日志记录的 FileAppender，就可以实现异步记录日志到文件： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"ASYNCFILE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.AsyncAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"FILE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ASYNCFILE"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <strong>关于 AsyncAppender 异步日志的坑，这些坑可以归结为三类：</strong></p><p><strong>记录异步日志撑爆内存；记录异步日志出现日志丢失；记录异步日志出现阻塞。</strong> </p><p> AsyncAppender 提供了一些配置参数，没用对的情况下可能导致日志丢失。我们结合相关源码分析一下：<code>includeCallerData</code> 用于控制是否收集调用方数据，默认是 false，此时方法行号、方法名等信息将不能显示（源码第 2 行以及 7 到 11 行）。</p><p><code>queueSize</code> 用于控制阻塞队列大小，使用的 ArrayBlockingQueue 阻塞队列（源码第 15 到 17 行），默认大小是 256，即内存中最多保存 256 条日志。</p><p><code>discardingThreshold</code>是控制丢弃日志的阈值，主要是防止队列满后阻塞。默认情况下，队列剩余量低于队列长度的 20%，就会丢弃 TRACE、DEBUG 和 INFO 级别的日志。（参见源码第 3 到 6 行、18 到 19 行、26 到 27 行、33 到 34 行、40 到 42 行）</p><p><code>neverBlock</code> 用于控制队列满的时候，加入的数据是否直接丢弃，不会阻塞等待，默认是 false（源码第 44 到 68 行）。这里需要注意一下 offer 方法和 put 方法的区别，当队列满的时候 offer 方法不阻塞，而 put 方法会阻塞；neverBlock 为 true 时，使用 offer 方法。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncAppender</span> <span class="keyword">extends</span> <span class="title">AsyncAppenderBase</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> includeCallerData = <span class="keyword">false</span>;<span class="comment">//是否收集调用方数据</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDiscardable</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        Level level = event.getLevel();</span><br><span class="line">        <span class="keyword">return</span> level.toInt() &lt;= Level.INFO_INT;<span class="comment">//丢弃&lt;=INFO级别的日志</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">preprocess</span><span class="params">(ILoggingEvent eventObject)</span> </span>&#123;</span><br><span class="line">        eventObject.prepareForDeferredProcessing();</span><br><span class="line">        <span class="keyword">if</span> (includeCallerData)</span><br><span class="line">            eventObject.getCallerData();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncAppenderBase</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnsynchronizedAppenderBase</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">AppenderAttachable</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    BlockingQueue&lt;E&gt; blockingQueue;<span class="comment">//异步日志的关键，阻塞队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_QUEUE_SIZE = <span class="number">256</span>;<span class="comment">//默认队列大小</span></span><br><span class="line">    <span class="keyword">int</span> queueSize = DEFAULT_QUEUE_SIZE;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNDEFINED = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> discardingThreshold = UNDEFINED;</span><br><span class="line">    <span class="keyword">boolean</span> neverBlock = <span class="keyword">false</span>;<span class="comment">//控制队列满的时候加入数据时是否直接丢弃，不会阻塞等待</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">        blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;E&gt;(queueSize);</span><br><span class="line">        <span class="keyword">if</span> (discardingThreshold == UNDEFINED)</span><br><span class="line">            discardingThreshold = queueSize / <span class="number">5</span>;<span class="comment">//默认丢弃阈值是队列剩余量低于队列长度的20%，参见isQueueBelowDiscardingThreshold方法</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) &#123; <span class="comment">//判断是否可以丢数据</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        preprocess(eventObject);</span><br><span class="line">        put(eventObject);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isQueueBelowDiscardingThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (blockingQueue.remainingCapacity() &lt; discardingThreshold);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (neverBlock) &#123; <span class="comment">//根据neverBlock决定使用不阻塞的offer还是阻塞的put方法</span></span><br><span class="line">            blockingQueue.offer(eventObject);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            putUninterruptibly(eventObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//以阻塞方式添加数据到队列</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putUninterruptibly</span><span class="params">(E eventObject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(eventObject);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 看到默认队列大小为 256，达到 80% 容量后开始丢弃 &lt;=INFO 级别的日志后，我们就可以理解日志中为什么会丢失日志了。</p><p><strong>我们可以继续分析下异步记录日志出现坑的原因。</strong></p><ul><li><p>queueSize 设置得特别大，就可能会导致 OOM。</p></li><li><p>queueSize 设置得比较小（默认值就非常小），且 discardingThreshold 设置为大于 0 的值（或者为默认值），队列剩余容量少于 discardingThreshold 的配置就会丢弃 &lt;=INFO 的日志。这里的坑点有两个。一是，因为 discardingThreshold 的存在，设置 queueSize 时容易踩坑。比如，本例中最大日志并发是 1000，即便设置 queueSize 为 1000 同样会导致日志丢失。二是，discardingThreshold 参数容易有歧义，它不是百分比，而是日志条数。对于总容量 10000 的队列，如果希望队列剩余容量少于 1000 条的时候丢弃，需要配置为 1000。</p></li><li><p>neverBlock 默认为 false，意味着总可能会出现阻塞。如果 discardingThreshold 为 0，那么队列满时再有日志写入就会阻塞；如果 discardingThreshold 不为 0，也只会丢弃 &lt;=INFO 级别的日志，那么出现大量错误日志时，还是会阻塞程序。</p><p>可以看出 queueSize、discardingThreshold 和 neverBlock 这三个参数息息相关，务必按需进行设置和取舍，到底是性能为先，还是数据不丢为先：</p><ul><li>如果考虑绝对性能为先，那就设置 neverBlock 为 true，永不阻塞。</li><li>如果考虑绝对不丢数据为先，那就设置 discardingThreshold 为 0，即使是 &lt;=INFO 的级别日志也不会丢，但最好把 queueSize 设置大一点，毕竟默认的 queueSize 显然太小，太容易阻塞。</li><li>如果希望兼顾两者，可以丢弃不重要的日志，把 queueSize 设置大一点，再设置一个合理的 discardingThreshold。</li></ul></li></ul><p>以上就是日志配置最常见的两个误区了 </p><h2 id="文件IO：实现高效正确的文件读写并非易事"><a href="#文件IO：实现高效正确的文件读写并非易事" class="headerlink" title="文件IO：实现高效正确的文件读写并非易事"></a>文件IO：实现高效正确的文件读写并非易事</h2><p> 有一个项目需要读取三方的对账文件定时对账，原先一直是单机处理的，没什么问题。后来为了提升性能，使用双节点同时处理对账，每一个节点处理部分对账数据，但新增的节点在处理文件中中文的时候总是读取到乱码。程序代码都是一致的，为什么老节点就不会有问题呢？我们知道，这很可能是写代码时没有注意编码问题导致的 </p><p> 当时出现问题的文件读取代码是这样的： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">String content = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">try</span> (FileReader fileReader = <span class="keyword">new</span> FileReader(<span class="string">"hello.txt"</span>)) &#123;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">while</span> ((count = fileReader.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        content += <span class="keyword">new</span> String(chars, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">log.info(<span class="string">"result:&#123;&#125;"</span>, content);</span><br></pre></td></tr></table></figure><p> 显然，这里并没有指定以什么字符集来读取文件中的字符。查看JDK 文档可以发现，FileReader 是以当前机器的默认字符集来读取文件的，如果希望指定字符集的话，需要直接使用 InputStreamReader 和 FileInputStream。到这里我们就明白了，FileReader 虽然方便但因为使用了默认字符集对环境产生了依赖，这就是为什么老的机器上程序可以正常运作，在新节点上读取中文时却产生了乱码。 </p><h4 id="思考与讨论"><a href="#思考与讨论" class="headerlink" title="思考与讨论"></a>思考与讨论</h4><p> Files.lines 方法进行流式处理，需要使用 try-with-resources 进行资源释放。那么，使用 Files 类中其他返回 Stream 包装对象的方法进行流式处理，比如 newDirectoryStream 方法返回 DirectoryStream，list、walk 和 find 方法返回 Stream，也同样有资源释放问题吗？</p><p>Java 的 File 类和 Files 类提供的文件复制、重命名、删除等操作，是原子性的吗？ </p><blockquote><p>先说下FileChannel 的 transfreTo 方法，这个方法出现在眼前很多次，因为之前看Kafka为什么吞吐量达的原因的时候，提到了2点：批处理思想和零拷贝；<br>批处理思想：就是对于Kafka内部很多地方来说，不是消息来了就发送，而是有攒一波发送一次，这样对于吞吐量有极大的提升，对于需要实时处理的情况，Kafka就不是很适合的原因；<br>零拷贝：Kafka快的另外一个原因是零拷贝，避免了内存态到内核态以及网络的拷贝，直接读取文件，发送到网络出去，零拷贝的含义不是没有拷贝，而是没有用户态到核心态的拷贝。<br>而在提到零拷贝的实现时，Java中说的就是FileChannel 的 transfreTo 方法。</p><p>然后回答下问题：<br>第一个问题：<br>Files的相关方法文档描述：<br>When not using the try-with-resources construct, then directory stream’s close method should be invoked after iteration is completed so as to free any resources held for the open directory.<br>所以是需要手动关闭的。</p><p>第二个问题：<br>没有原子操作，因此是线程不安全的。个人理解，其实即使加上了原子操作，也是鸡肋，不实用的很，原因是：File 类和 Files的相关操作，其实都是调用操作系统的文件系统操作，这个文件除了JVM操作外，可能别的也在操作，因此还不如不保证，完全基于操作系统的文件系统去保证相关操作的正确性。 </p></blockquote><h2 id="序列化：一来一回你还是原来的你吗"><a href="#序列化：一来一回你还是原来的你吗" class="headerlink" title="序列化：一来一回你还是原来的你吗"></a>序列化：一来一回你还是原来的你吗</h2><h3 id="序列化和反序列化需要确保算法一致"><a href="#序列化和反序列化需要确保算法一致" class="headerlink" title="序列化和反序列化需要确保算法一致"></a>序列化和反序列化需要确保算法一致</h3><p> 业务代码中涉及序列化时，很重要的一点是要确保序列化和反序列化的算法一致性。有一次我要排查缓存命中率问题，需要运维同学帮忙拉取 Redis 中的 Key，结果他反馈 Redis 中存的都是乱码，怀疑 Redis 被攻击了。其实呢，这个问题就是序列化算法导致的 </p><p> Spring 提供的 4 种 RedisSerializer（Redis 序列化器）：</p><ul><li><p>默认情况下，RedisTemplate 使用 JdkSerializationRedisSerializer，也就是 JDK 序列化，容易产生 Redis 中保存了乱码的错觉。</p></li><li><p>通常考虑到易读性，可以设置 Key 的序列化器为 StringRedisSerializer。但直接使用 RedisSerializer.string()，相当于使用了 UTF_8 编码的 StringRedisSerializer，需要注意字符集问题。如果希望 Value 也是使用 JSON 序列化的话，可以把 Value 序列化器设置为 Jackson2JsonRedisSerializer。默认情况下，不会把类型信息保存在 Value 中，即使我们定义 RedisTemplate 的 Value 泛型为实际类型，查询出的 Value 也只能是 LinkedHashMap 类型。</p></li><li><p>如果希望直接获取真实的数据类型，你可以启用 Jackson ObjectMapper 的 activateDefaultTyping 方法，把类型信息一起序列化保存在 Value 中。</p></li><li><p>如果希望 Value 以 JSON 保存并带上类型信息，更简单的方式是，直接使用 RedisSerializer.json() 快捷方法来获取序列化器。 </p><h3 id="枚举作为-API-接口参数或返回值的两个大坑"><a href="#枚举作为-API-接口参数或返回值的两个大坑" class="headerlink" title="枚举作为 API 接口参数或返回值的两个大坑"></a>枚举作为 API 接口参数或返回值的两个大坑</h3></li></ul><p>在前面的例子中，我演示了如何把枚举序列化为索引值。但对于枚举，我建议尽量在程序内部使用，而不是作为 API 接口的参数或返回值，原因是枚举涉及序列化和反序列化时会有两个大坑。</p><ul><li><p><strong>第一个坑是，客户端和服务端的枚举定义不一致时，会出异常。</strong></p></li><li><p><strong>第二个坑，也是更大的坑，枚举序列化反序列化实现自定义的字段非常麻烦，会涉及 Jackson 的 Bug。</strong>比如，下面这个接口，传入枚举 List，为 List 增加一个 CENCELED 枚举值然后返回： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> StatusEnumClient &#123;</span><br><span class="line">    CREATED(<span class="number">1</span>, <span class="string">"已创建"</span>),</span><br><span class="line">    PAID(<span class="number">2</span>, <span class="string">"已支付"</span>),</span><br><span class="line">    DELIVERED(<span class="number">3</span>, <span class="string">"已送到"</span>),</span><br><span class="line">    FINISHED(<span class="number">4</span>, <span class="string">"已完成"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    StatusEnumClient(Integer status, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端比客户端多一个枚举值</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">enum</span> StatusEnumServer &#123;</span><br><span class="line">    ...</span><br><span class="line">    CANCELED(<span class="number">5</span>, <span class="string">"已取消"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br><span class="line"></span><br><span class="line">    StatusEnumServer(Integer status, String desc) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = status;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"queryOrdersByStatusList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;StatusEnumServer&gt; <span class="title">queryOrdersByStatus</span><span class="params">(@RequestBody List&lt;StatusEnumServer&gt; enumServers)</span> </span>&#123;</span><br><span class="line">    enumServers.add(StatusEnumServer.CANCELED);</span><br><span class="line">    <span class="keyword">return</span> enumServers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们希望根据枚举的 Desc 字段来序列化，传入“已送到”作为入参： </p></li></ul><p><img src="https://www.enjoyican.com/img/java-errorcase/eg1.png" alt="eg1"></p><p> 会得到异常，提示“已送到”不是正确的枚举值： </p><p> 显然，这里反序列化使用的是枚举的 name，序列化也是一样： </p><p><img src="https://www.enjoyican.com/img/java-errorcase/eg2.png" alt="eg2"></p><p> 你可能也知道，要让枚举的序列化和反序列化走 desc 字段，可以在字段上加 @JsonValue 注解，修改 StatusEnumServer 和 StatusEnumClient： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonValue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String desc;</span><br></pre></td></tr></table></figure><p> 然后再尝试下，果然可以用 desc 作为入参了，而且出参也使用了枚举的 desc： </p><p><img src="https://www.enjoyican.com/img/java-errorcase/eg3.png" alt="eg3"></p><p> 但是，如果你认为这样就完美解决问题了，那就大错特错了。你可以再尝试把 @JsonValue 注解加在 int 类型的 status 字段上，也就是希望序列化反序列化走 status 字段： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonValue</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> status;</span><br></pre></td></tr></table></figure><p> 写一个客户端测试一下，传入 CREATED 和 PAID 两个枚举值： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"queryOrdersByStatusListClient"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryOrdersByStatusListClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;StatusEnumClient&gt; request = Arrays.asList(StatusEnumClient.CREATED, StatusEnumClient.PAID);</span><br><span class="line">    HttpEntity&lt;List&lt;StatusEnumClient&gt;&gt; entity = <span class="keyword">new</span> HttpEntity&lt;&gt;(request, <span class="keyword">new</span> HttpHeaders());</span><br><span class="line">    List&lt;StatusEnumClient&gt; response = restTemplate.exchange(<span class="string">"http://localhost:45678/enumusedinapi/queryOrdersByStatusList"</span>,</span><br><span class="line">            HttpMethod.POST, entity, <span class="keyword">new</span> ParameterizedTypeReference&lt;List&lt;StatusEnumClient&gt;&gt;() &#123;&#125;).getBody();</span><br><span class="line">    log.info(<span class="string">"result &#123;&#125;"</span>, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 请求接口可以看到，传入的是 CREATED 和 PAID，返回的居然是 DELIVERED 和 FINISHED。果然如标题所说，一来一回你已不是原来的你 </p><p> 出现这个问题的原因是，序列化走了 status 的值，而反序列化并没有根据 status 来，还是使用了枚举的 ordinal() 索引值。这是 Jackson至今（2.10）没有解决的 Bug，应该会在 2.11 解决。 </p><p> 有一个解决办法是，设置 @JsonCreator 来强制反序列化时使用自定义的工厂方法，可以实现使用枚举的 status 字段来取值。我们把这段代码加在 StatusEnumServer 枚举类中： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StatusEnumServer <span class="title">parse</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(StatusEnumServer.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JsonCreator</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StatusEnumClient <span class="title">parse</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.stream(StatusEnumClient.values()).filter(value-&gt;o.equals(value.status)).findFirst().orElse(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 要特别注意的是，我们同样要为 StatusEnumClient 也添加相应的方法。因为除了服务端接口接收 StatusEnumServer 参数涉及一次反序列化外，从服务端返回值转换为 List 还会有一次反序列化： </p><p> 重新调用接口发现，虽然结果正确了，但是服务端不存在的枚举值 CANCELED 被设置为了 null，而不是 @JsonEnumDefaultValue 设置的 UNKNOWN。这个问题，我们之前已经通过设置 @JsonEnumDefaultValue 注解解决了，但现在又出现了： </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[22:20:13.727] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, null]</span><br></pre></td></tr></table></figure><p> 原因也很简单，我们自定义的 parse 方法实现的是找不到枚举值时返回 null。为彻底解决这个问题，并避免通过 @JsonCreator 在枚举中自定义一个非常复杂的工厂方法，我们可以实现一个自定义的反序列化器。这段代码比较复杂，我特意加了详细的注释： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnumDeserializer</span> <span class="keyword">extends</span> <span class="title">JsonDeserializer</span>&lt;<span class="title">Enum</span>&gt; <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">        <span class="title">ContextualDeserializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Class&lt;Enum&gt; targetClass;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumDeserializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumDeserializer</span><span class="params">(Class&lt;Enum&gt; targetClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetClass = targetClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Enum <span class="title">deserialize</span><span class="params">(JsonParser p, DeserializationContext ctxt)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//找枚举中带有@JsonValue注解的字段，这是我们反序列化的基准字段</span></span><br><span class="line">        Optional&lt;Field&gt; valueFieldOpt = Arrays.asList(targetClass.getDeclaredFields()).stream()</span><br><span class="line">                .filter(m -&gt; m.isAnnotationPresent(JsonValue<span class="class">.<span class="keyword">class</span>))</span></span><br><span class="line"><span class="class">                .<span class="title">findFirst</span>()</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (valueFieldOpt.isPresent()) &#123;</span><br><span class="line">            Field valueField = valueFieldOpt.get();</span><br><span class="line">            <span class="keyword">if</span> (!valueField.isAccessible()) &#123;</span><br><span class="line">                valueField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历枚举项，查找字段的值等于反序列化的字符串的那个枚举项</span></span><br><span class="line">            <span class="keyword">return</span> Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> valueField.get(e).toString().equals(p.getValueAsString());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;).findFirst().orElseGet(() -&gt; Arrays.stream(targetClass.getEnumConstants()).filter(e -&gt; &#123;</span><br><span class="line">                <span class="comment">//如果找不到，就需要寻找默认枚举值来替代，同样遍历所有枚举项，查找@JsonEnumDefaultValue注解标识的枚举项</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> targetClass.getField(e.name()).isAnnotationPresent(JsonEnumDefaultValue<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                    ex.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;).findFirst().orElse(<span class="keyword">null</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> JsonDeserializer&lt;?&gt; createContextual(DeserializationContext ctxt,</span><br><span class="line">                                                BeanProperty property) <span class="keyword">throws</span> JsonMappingException &#123;</span><br><span class="line">        targetClass = (Class&lt;Enum&gt;) ctxt.getContextualType().getRawClass();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EnumDeserializer(targetClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后，把这个自定义反序列化器注册到 Jackson 中： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Module <span class="title">enumModule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SimpleModule <span class="keyword">module</span> = <span class="keyword">new</span> SimpleModule();</span><br><span class="line">    <span class="keyword">module</span>.addDeserializer(Enum<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">EnumDeserializer</span>())</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">module</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  第二个大坑终于被完美地解决了： </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[22:32:28.327] [http-nio-45678-exec-1] [INFO ] [o.g.t.c.e.e.EnumUsedInAPIController:34  ] - result [CREATED, PAID, UNKNOWN]</span><br></pre></td></tr></table></figure><p>这样做，虽然解决了序列化反序列化使用枚举中自定义字段的问题，也解决了找不到枚举值时使用默认值的问题，但解决方案很复杂。因此，我还是建议在 DTO 中直接使用 int 或 String 等简单的数据类型，而不是使用枚举再配合各种复杂的序列化配置，来实现枚举到枚举中字段的映射，会更加清晰明了。 </p><h2 id="用好Java-8的日期时间类，少踩一些“老三样”的坑"><a href="#用好Java-8的日期时间类，少踩一些“老三样”的坑" class="headerlink" title="用好Java 8的日期时间类，少踩一些“老三样”的坑"></a>用好Java 8的日期时间类，少踩一些“老三样”的坑</h2><p> 在 Java 8 之前，我们处理日期时间需求时，使用 Date、Calender 和 SimpleDateFormat，来声明时间戳、使用日历处理日期和格式化解析日期时间。但是，这些类的 API 的缺点比较明显，比如可读性差、易用性差、使用起来冗余繁琐，还有线程安全问题。 </p><p> 关于 Date 类，我们要有两点认识：</p><ul><li><p>一是，Date 并无时区问题，世界上任何一台计算机使用 new Date() 初始化得到的时间都一样。因为，Date 中保存的是 UTC 时间，UTC 是以原子钟为基础的统一时间，不以太阳参照计时，并无时区划分。</p></li><li><p>二是，Date 中保存的是一个时间戳，代表的是从 1970 年 1 月 1 日 0 点（Epoch 时间）到现在的毫秒数。尝试输出 Date(0)： </p><p>对于国际化（世界各国的人都在使用）的项目，处理好时间和时区问题首先就是要正确保存日期时间。这里有两种保存方式：</p></li><li><p>方式一，以 UTC 保存，保存的时间没有时区属性，是不涉及时区时间差问题的世界统一时间。我们通常说的时间戳，或 Java 中的 Date 类就是用的这种方式，这也是推荐的方式。</p></li><li><p>方式二，以字面量保存，比如年 / 月 / 日 时: 分: 秒，一定要同时保存时区信息。只有有了时区信息，我们才能知道这个字面量时间真正的时间点，否则它只是一个给人看的时间表示，只在当前时区有意义。Calendar 是有时区概念的，所以我们通过不同的时区初始化 Calendar，得到了不同的时间。 </p></li></ul><p>要正确处理国际化时间问题，我推荐使用 Java 8 的日期时间类，即使用 ZonedDateTime 保存时间，然后使用设置了 ZoneId 的 DateTimeFormatter 配合 ZonedDateTime 进行时间格式化得到本地时间表示。这样的划分十分清晰、细化，也不容易出错。 </p><p> 使用遗留的 SimpleDateFormat，会遇到哪些问题：</p><ul><li><p>日期时间格式化和解析 </p><p>每到年底，就有很多开发同学踩时间格式化的坑，比如“这明明是一个 2019 年的日期，怎么使用 SimpleDateFormat 格式化后就提前跨年了” ， 出现这个问题的原因在于，这位同学混淆了 SimpleDateFormat 的各种格式化模式。JDK 的文档中有说明：小写 y 是年，而大写 Y 是 week year，也就是所在的周属于哪一年。 </p><p>除了格式化表达式容易踩坑外，SimpleDateFormat 还有两个著名的坑。</p></li></ul><p><strong>第一个坑是，定义的 static 的 SimpleDateFormat 可能会出现线程安全问题。</strong> </p><p> SimpleDateFormat 的作用是定义解析和格式化日期时间的模式。这，看起来这是一次性的工作，应该复用，但它的解析和格式化操作是非线程安全的。我们来分析一下相关源码：SimpleDateFormat 继承了 DateFormat，DateFormat 有一个字段 Calendar；SimpleDateFormat 的 parse 方法调用 CalendarBuilder 的 establish 方法，来构建 Calendar；establish 方法内部先清空 Calendar 再构建 Calendar，整个操作没有加锁。显然，如果多线程池调用 parse 方法，也就意味着多线程在并发操作一个 Calendar，可能会产生一个线程还没来得及处理 Calendar 就被另一个线程清空了的情况： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DateFormat</span> <span class="keyword">extends</span> <span class="title">Format</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Calendar calendar;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleDateFormat</span> <span class="keyword">extends</span> <span class="title">DateFormat</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">parse</span><span class="params">(String text, ParsePosition pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CalendarBuilder calb = <span class="keyword">new</span> CalendarBuilder();</span><br><span class="line">    parsedDate = calb.establish(calendar).getTime();</span><br><span class="line">        <span class="keyword">return</span> parsedDate;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CalendarBuilder</span> </span>&#123;</span><br><span class="line">  <span class="function">Calendar <span class="title">establish</span><span class="params">(Calendar cal)</span> </span>&#123;</span><br><span class="line">         ...</span><br><span class="line">        cal.clear();<span class="comment">//清空</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= maxFieldIndex; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (field[index] == stamp) &#123;</span><br><span class="line">                    cal.set(index, field[MAX_FIELD + index]);<span class="comment">//构建</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>第二个坑是，当需要解析的字符串和格式不匹配的时候，SimpleDateFormat 表现得很宽容，还是能得到结果。</strong>比如，我们期望使用 yyyyMM 来解析 20160901 字符串： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String dateString = <span class="string">"20160901"</span>;</span><br><span class="line">SimpleDateFormat dateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMM"</span>);</span><br><span class="line">System.out.println(<span class="string">"result:"</span> + dateFormat.parse(dateString));</span><br></pre></td></tr></table></figure><p> 居然输出了 2091 年 1 月 1 日，原因是把 0901 当成了月份，相当于 75 年： </p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result:Mon Jan 01 00:00:00 CST 2091</span><br></pre></td></tr></table></figure><p> 对于 SimpleDateFormat 的这三个坑，我们使用 Java 8 中的 DateTimeFormatter 就可以避过去。首先，使用 DateTimeFormatterBuilder 来定义格式化字符串，不用去记忆使用大写的 Y 还是小写的 Y，大写的 M 还是小写的 m： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DateTimeFormatter dateTimeFormatter = <span class="keyword">new</span> DateTimeFormatterBuilder()</span><br><span class="line">        .appendValue(ChronoField.YEAR) <span class="comment">//年</span></span><br><span class="line">        .appendLiteral(<span class="string">"/"</span>)</span><br><span class="line">        .appendValue(ChronoField.MONTH_OF_YEAR) <span class="comment">//月</span></span><br><span class="line">        .appendLiteral(<span class="string">"/"</span>)</span><br><span class="line">        .appendValue(ChronoField.DAY_OF_MONTH) <span class="comment">//日</span></span><br><span class="line">        .appendLiteral(<span class="string">" "</span>)</span><br><span class="line">        .appendValue(ChronoField.HOUR_OF_DAY) <span class="comment">//时</span></span><br><span class="line">        .appendLiteral(<span class="string">":"</span>)</span><br><span class="line">        .appendValue(ChronoField.MINUTE_OF_HOUR) <span class="comment">//分</span></span><br><span class="line">        .appendLiteral(<span class="string">":"</span>)</span><br><span class="line">        .appendValue(ChronoField.SECOND_OF_MINUTE) <span class="comment">//秒</span></span><br><span class="line">        .appendLiteral(<span class="string">"."</span>)</span><br><span class="line">        .appendValue(ChronoField.MILLI_OF_SECOND) <span class="comment">//毫秒</span></span><br><span class="line">        .toFormatter();</span><br></pre></td></tr></table></figure><p> 其次，DateTimeFormatter 是线程安全的，可以定义为 static 使用；最后，DateTimeFormatter 的解析比较严格，需要解析的字符串和格式不匹配时，会直接报错，而不会把 0901 解析为月份。 </p><p> 对日期时间做计算操作，Java 8 日期时间 API 会比 Calendar 功能强大很多。</p><p>第一，可以使用各种 minus 和 plus 方法直接对日期进行加减操作，比如如下代码实现了减一天和加一天，以及减一个月和加一个月： </p><p>第二，还可以通过 with 方法进行快捷时间调节，比如：</p><ul><li><p>使用 TemporalAdjusters.firstDayOfMonth 得到当前月的第一天；</p></li><li><p>使用 TemporalAdjusters.firstDayOfYear() 得到当前年的第一天；</p></li><li><p>使用 TemporalAdjusters.previous(DayOfWeek.SATURDAY) 得到上一个周六；</p></li><li><p>使用 TemporalAdjusters.lastInMonth(DayOfWeek.FRIDAY) 得到本月最后一个周五。 </p><p>第三，可以直接使用 lambda 表达式进行自定义的时间调整。 </p><p>使用 Java 8 操作和计算日期时间虽然方便，但计算两个日期差时可能会踩坑：Java 8 中有一个专门的类 Period 定义了日期间隔，通过 Period.between 得到了两个 LocalDate 的差，返回的是两个日期差几年零几月零几天。如果希望得知两个日期之间差几天，直接调用 Period 的 getDays() 方法得到的只是最后的“零几天”，而不是算总的间隔天数。 </p><p>可以使用 ChronoUnit.DAYS.between 解决这个问题： </p><p>如果有条件的话，我还是建议全面改为使用 Java 8 的日期时间类型。我把 Java 8 前后的日期时间类型，汇总到了一张思维导图上，图中箭头代表的是新老类型在概念上等价的类型： </p></li></ul><p><img src="https://www.enjoyican.com/img/java-errorcase/java-date.png" alt="java时间类型"></p><p>思考与讨论：</p><p> 我今天多次强调 Date 是一个时间戳，是 UTC 时间、没有时区概念，为什么调用其 toString 方法会输出类似 CST 之类的时区字样呢？</p><p>日期时间数据始终要保存到数据库中，MySQL 中有两种数据类型 datetime 和 timestamp 可以用来保存日期时间。你能说说它们的区别吗，它们是否包含时区信息呢？ </p><blockquote><p> 第一个：<br>Date的toString()方法处理的，同String中有BaseCalendar.Date date = normalize();<br>而normalize中进行这样处理cdate = (BaseCalendar.Date) cal.getCalendarDate(fastTime,TimeZone.getDefaultRef()；<br>因此其实是获取当前的默认时区的。<br>第二个：<br>从下面几个维度进行区分：<br>占用空间：datetime：8字节。timestamp 4字节<br>表示范围：datetime ‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’<br>timestamp ‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’<br>时区：timestamp 只占 4 个字节，而且是以utc的格式储存， 它会自动检索当前时区并进行转换。<br>datetime以 8 个字节储存，不会进行时区的检索.<br>也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。<br>更新：timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP；<br>这个特性是自动初始化和自动更新（Automatic Initialization and Updating）。<br>自动更新指的是如果修改了其它字段，则该字段的值将自动更新为当前系统时间。<br>它与“explicit_defaults_for_timestamp”参数有关。</p><p>By default, the first TIMESTAMP column has both DEFAULT CURRENT_TIMESTAMP and ON UPDATE CURRENT_TIMESTAMP if neither is specified explicitly。<br>很多时候，这并不是我们想要的，如何禁用呢？<br>\1. 将“explicit_defaults_for_timestamp”的值设置为ON。<br>\2. “explicit_defaults_for_timestamp”的值依旧是OFF，也有两种方法可以禁用<br>   1&gt; 用DEFAULT子句该该列指定一个默认值<br>   2&gt; 为该列指定NULL属性。</p><p>  在MySQL 5.6.5版本之前，Automatic Initialization and Updating只适用于TIMESTAMP，而且一张表中，最多允许一个TIMESTAMP字段采用该特性。从MySQL 5.6.5开始，Automatic Initialization and Updating同时适用于TIMESTAMP和DATETIME，且不限制数量。 </p></blockquote><h2 id="OOM相关"><a href="#OOM相关" class="headerlink" title="OOM相关"></a>OOM相关</h2><p> Spring 提供的ConcurrentReferenceHashMap类可以使用弱引用、软引用做缓存，Key 和 Value 同时被软引用或弱引用包装，也能解决相互引用导致的数据不能释放问题。与 WeakHashMap 相比，ConcurrentReferenceHashMap 不但性能更好，还可以确保线程安全。你可以自己做实验测试下。 </p><p> 建议你为生产系统的程序配置 JVM 参数启用详细的 GC 日志，方便观察垃圾收集器的行为，并开启 HeapDumpOnOutOfMemoryError，以便在出现 OOM 时能自动 Dump 留下第一问题现场。对于 JDK8，你可以这么设置： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=. -XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:gc.log -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M</span><br></pre></td></tr></table></figure><h2 id="反射相关"><a href="#反射相关" class="headerlink" title="反射相关"></a>反射相关</h2><p>使用反射查询类方法清单时，我们要注意两点：getMethods 和 getDeclaredMethods 是有区别的，前者可以查询到父类方法，后者只能查询到当前类。反射进行方法调用要注意过滤桥接方法。</p><p> <strong>使用 Java 反射、注解和泛型高级特性配合 OOP 时，可能会遇到的一些坑。</strong></p><ul><li>第一，反射调用方法并不是通过调用时的传参确定方法重载，而是在获取方法的时候通过方法名和参数类型来确定的。遇到方法有包装类型和基本类型重载的时候，你需要特别注意这一点。</li><li>第二，反射获取类成员，需要注意 getXXX 和 getDeclaredXXX 方法的区别，其中 XXX 包括 Methods、Fields、Constructors、Annotations。这两类方法，针对不同的成员类型 XXX 和对象，在实现上都有一些细节差异，详情请查看官方文档。今天提到的 getDeclaredMethods 方法无法获得父类定义的方法，而 getMethods 方法可以，只是差异之一，不能适用于所有的 XXX。</li><li>第三，泛型因为类型擦除会导致泛型方法 T 占位符被替换为 Object，子类如果使用具体类型覆盖父类实现，编译器会生成桥接方法。这样既满足子类方法重写父类方法的定义，又满足子类实现的方法有具体的类型。使用反射来获取方法清单时，你需要特别注意这一点。</li><li>第四，自定义注解可以通过标记元注解 @Inherited 实现注解的继承，不过这只适用于类。如果要继承定义在接口或方法上的注解，可以使用 Spring 的工具类 AnnotatedElementUtils，并注意各种 getXXX 方法和 findXXX 方法的区别，详情查看Spring 的文档<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/core/annotation/AnnotatedElementUtils.html" target="_blank" rel="noopener">AnnotatedElementUtils</a>。最后，我要说的是。编译后的代码和原始代码并不完全一致，编译器可能会做一些优化，加上还有诸如 AspectJ 等编译时增强框架，使用反射动态获取类型的元数据可能会和我们编写的源码有差异，这点需要特别注意。你可以在反射中多写断言，遇到非预期的情况直接抛异常，避免通过反射实现的业务逻辑不符合预期。  </li></ul><h2 id="springaop"><a href="#springaop" class="headerlink" title="springaop"></a>springaop</h2><p> Bean 默认是单例的，所以单例的 Controller 注入的 Service 也是一次性创建的，即使 Service 本身标识了 prototype 的范围也没用。修复方式是，让 Service 以代理方式注入。这样虽然 Controller 本身是单例的，但每次都能从代理获取 Service。这样一来，prototype 范围的配置才能真正生效： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//让Spring帮我们注入ObjectMapper，以方便通过JSON序列化来记录方法入参和出参</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现一个返回Java基本类型默认值的工具。其实，你也可以逐一写很多if-else判断类型，然后手动设置其默认值。这里为了减少代码量用了一个小技巧，即通过初始化一个具有1个元素的数组，然后通过获取这个数组的值来获取基本类型默认值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; DEFAULT_VALUES = Stream</span><br><span class="line">            .of(<span class="keyword">boolean</span><span class="class">.<span class="keyword">class</span>, <span class="title">byte</span>.<span class="title">class</span>, <span class="title">char</span>.<span class="title">class</span>, <span class="title">double</span>.<span class="title">class</span>, <span class="title">float</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">long</span>.<span class="title">class</span>, <span class="title">short</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">collect</span>(<span class="title">toMap</span>(<span class="title">clazz</span> -&gt; (<span class="title">Class</span>&lt;?&gt;) <span class="title">clazz</span>, <span class="title">clazz</span> -&gt; <span class="title">Array</span>.<span class="title">get</span>(<span class="title">Array</span>.<span class="title">newInstance</span>(<span class="title">clazz</span>, 1), 0)))</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getDefaultValue</span><span class="params">(Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) DEFAULT_VALUES.get(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//@annotation指示器实现对标记了Metrics注解的方法进行匹配</span></span><br><span class="line">   <span class="meta">@Pointcut</span>(<span class="string">"within(@org.geekbang.time.commonmistakes.springpart1.aopmetrics.Metrics *)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">withMetricsAnnotation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//within指示器实现了匹配那些类型上标记了@RestController注解的方法</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(@org.springframework.web.bind.annotation.RestController *)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"controllerBean() || withMetricsAnnotation())"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">metrics</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//通过连接点获取方法签名和方法上Metrics注解，并根据方法签名生成日志中要输出的方法定义描述</span></span><br><span class="line">        MethodSignature signature = (MethodSignature) pjp.getSignature();</span><br><span class="line">        Metrics metrics = signature.getMethod().getAnnotation(Metrics<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"> </span><br><span class="line">        String name = String.format(<span class="string">"【%s】【%s】"</span>, signature.getDeclaringType().toString(), signature.toLongString());</span><br><span class="line">        <span class="comment">//因为需要默认对所有@RestController标记的Web控制器实现@Metrics注解的功能，在这种情况下方法上必然是没有@Metrics注解的，我们需要获取一个默认注解。虽然可以手动实例化一个@Metrics注解的实例出来，但为了节省代码行数，我们通过在一个内部类上定义@Metrics注解方式，然后通过反射获取注解的小技巧，来获得一个默认的@Metrics注解的实例</span></span><br><span class="line">        <span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@Metrics</span></span><br><span class="line">            <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">c</span> </span>&#123;&#125;</span><br><span class="line">            metrics = c<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">Metrics</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试从请求上下文（如果有的话）获得请求URL，以方便定位问题</span></span><br><span class="line">        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();</span><br><span class="line">        <span class="keyword">if</span> (requestAttributes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();</span><br><span class="line">            <span class="keyword">if</span> (request != <span class="keyword">null</span>)</span><br><span class="line">                name += String.format(<span class="string">"【%s】"</span>, request.getRequestURL().toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现的是入参的日志输出</span></span><br><span class="line">        <span class="keyword">if</span> (metrics.logParameters())</span><br><span class="line">            log.info(String.format(<span class="string">"【入参日志】调用 %s 的参数是：【%s】"</span>, name, objectMapper.writeValueAsString(pjp.getArgs())));</span><br><span class="line">        <span class="comment">//实现连接点方法的执行，以及成功失败的打点，出现异常的时候还会记录日志</span></span><br><span class="line">        Object returnValue;</span><br><span class="line">        Instant start = Instant.now();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnValue = pjp.proceed();</span><br><span class="line">            <span class="keyword">if</span> (metrics.recordSuccessMetrics())</span><br><span class="line">                <span class="comment">//在生产级代码中，我们应考虑使用类似Micrometer的指标框架，把打点信息记录到时间序列数据库中，实现通过图表来查看方法的调用次数和执行时间，在设计篇我们会重点介绍</span></span><br><span class="line">                log.info(String.format(<span class="string">"【成功打点】调用 %s 成功，耗时：%d ms"</span>, name, Duration.between(start, Instant.now()).toMillis()));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (metrics.recordFailMetrics())</span><br><span class="line">                log.info(String.format(<span class="string">"【失败打点】调用 %s 失败，耗时：%d ms"</span>, name, Duration.between(start, Instant.now()).toMillis()));</span><br><span class="line">            <span class="keyword">if</span> (metrics.logException())</span><br><span class="line">                log.error(String.format(<span class="string">"【异常日志】调用 %s 出现异常！"</span>, name), ex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//忽略异常的时候，使用一开始定义的getDefaultValue方法，来获取基本类型的默认值</span></span><br><span class="line">            <span class="keyword">if</span> (metrics.ignoreException())</span><br><span class="line">                returnValue = getDefaultValue(signature.getReturnType());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现了返回值的日志输出</span></span><br><span class="line">        <span class="keyword">if</span> (metrics.logReturn())</span><br><span class="line">            log.info(String.format(<span class="string">"【出参日志】调用 %s 的返回是：【%s】"</span>, name, returnValue));</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 我们要知道切入的连接点是方法，注解定义在类上是无法直接从方法上获取到注解的。修复方式是，改为优先从方法获取，如果获取不到再从类获取，如果还是获取不到再使用默认的注解： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Metrics metrics = signature.getMethod().getAnnotation(Metrics<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> (metrics == <span class="keyword">null</span>) &#123;</span><br><span class="line">    metrics = signature.getMethod().getDeclaringClass().getAnnotation(Metrics<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口统一包装"><a href="#接口统一包装" class="headerlink" title="接口统一包装"></a>接口统一包装</h2><p> 分享一个小技巧。为了简化服务端代码，我们可以把包装 API 响应体 APIResponse 的工作交由框架自动完成，这样直接返回 DTO OrderInfo 即可。对于业务逻辑错误，可以抛出一个自定义异常： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"server"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> OrderInfo <span class="title">server</span><span class="params">(@RequestParam(<span class="string">"userId"</span>)</span> Long userId) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (userId == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="number">3001</span>, <span class="string">"Illegal userId"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userId == <span class="number">1</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//直接抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> APIException(<span class="number">3002</span>, <span class="string">"Internal Error, order is cancelled"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//直接返回DTO</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> OrderInfo(<span class="string">"Created"</span>, <span class="number">2L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在 APIException 中包含错误码和错误消息： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(<span class="keyword">int</span> errorCode, String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMessage);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">APIException</span><span class="params">(Throwable cause, <span class="keyword">int</span> errorCode, String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(errorMessage, cause);</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后，定义一个 @RestControllerAdvice 来完成自动包装响应体的工作：通过实现 ResponseBodyAdvice 接口的 beforeBodyWrite 方法，来处理成功请求的响应体转换。实现一个 @ExceptionHandler 来处理业务异常时，APIException 到 APIResponse 的转换。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此段代码只是Demo，生产级应用还需要扩展很多细节</span></span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APIResponseAdvice</span> <span class="keyword">implements</span> <span class="title">ResponseBodyAdvice</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动处理APIException，包装为APIResponse</span></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(APIException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">APIResponse</span> <span class="title">handleApiException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">APIException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        log.error(<span class="string">"process url &#123;&#125; failed"</span>, request.getRequestURL().toString(), ex);</span><br><span class="line">        APIResponse apiResponse = <span class="keyword">new</span> APIResponse();</span><br><span class="line">        apiResponse.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        apiResponse.setCode(ex.getErrorCode());</span><br><span class="line">        apiResponse.setMessage(ex.getErrorMessage());</span><br><span class="line">        <span class="keyword">return</span> apiResponse;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//仅当方法或类没有标记@NoAPIResponse才自动包装</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(MethodParameter returnType, Class converterType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> returnType.getParameterType() != APIResponse<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class">                &amp;&amp; <span class="title">AnnotationUtils</span>.<span class="title">findAnnotation</span>(<span class="title">returnType</span>.<span class="title">getMethod</span>(), <span class="title">NoAPIResponse</span>.<span class="title">class</span>) </span>== <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; AnnotationUtils.findAnnotation(returnType.getDeclaringClass(), NoAPIResponse<span class="class">.<span class="keyword">class</span>) </span>== <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自动包装外层APIResposne响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">beforeBodyWrite</span><span class="params">(Object body, MethodParameter returnType, MediaType selectedContentType, Class&lt;? extends HttpMessageConverter&lt;?&gt;&gt; selectedConverterType, ServerHttpRequest request, ServerHttpResponse response)</span> </span>&#123;</span><br><span class="line">        APIResponse apiResponse = <span class="keyword">new</span> APIResponse();</span><br><span class="line">        apiResponse.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        apiResponse.setMessage(<span class="string">"OK"</span>);</span><br><span class="line">        apiResponse.setCode(<span class="number">2000</span>);</span><br><span class="line">        apiResponse.setData(body);</span><br><span class="line">        <span class="keyword">return</span> apiResponse;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><p> 注意缓存数据同步策略 </p><p>在实际情况下，修改了原始数据后，考虑到缓存数据更新的及时性，我们可能会采用主动更新缓存的策略。这些策略可能是：</p><ul><li>先更新缓存，再更新数据库；</li><li>先更新数据库，再更新缓存；</li><li>先删除缓存，再更新数据库，访问的时候按需加载数据到缓存；</li><li>先更新数据库，再删除缓存，访问的时候按需加载数据到缓存。</li></ul><p>那么，我们应该选择哪种更新策略呢？逐一分析下这 4 种策略：</p><ul><li><p>“先更新缓存再更新数据库”策略不可行。数据库设计复杂，压力集中，数据库因为超时等原因更新操作失败的可能性较大，此外还会涉及事务，很可能因为数据库更新失败，导致缓存和数据库的数据不一致。</p></li><li><p>“先更新数据库再更新缓存”策略不可行。一是，如果线程 A 和 B 先后完成数据库更新，但更新缓存时却是 B 和 A 的顺序，那很可能会把旧数据更新到缓存中引起数据不一致；二是，我们不确定缓存中的数据是否会被访问，不一定要把所有数据都更新到缓存中去。</p></li><li><p>“先删除缓存再更新数据库，访问的时候按需加载数据到缓存”策略也不可行。在并发的情况下，很可能删除缓存后还没来得及更新数据库，就有另一个线程先读取了旧值到缓存中，如果并发量很大的话这个概率也会很大。 </p></li><li><p>“先更新数据库再删除缓存，访问的时候按需加载数据到缓存”策略是最好的。虽然在极端情况下，这种策略也可能出现数据不一致的问题，但概率非常低，基本可以忽略。举一个“极端情况”的例子，比如更新数据的时间节点恰好是缓存失效的瞬间，这时 A 先读取到了旧值，随后在 B 操作数据库完成更新并且删除了缓存之后，A 再把旧值加入缓存。 </p><p>需要注意的是，更新数据库后删除缓存的操作可能失败，如果失败则考虑把任务加入延迟队列进行延迟重试，确保数据可以删除，缓存可以及时更新。因为删除操作是幂等的，所以即使重复删问题也不是太大，这又是删除比更新好的一个原因。因此，针对缓存更新更推荐的方式是，缓存中的数据不由数据更新操作主动触发，统一在需要使用的时候按需加载，数据更新后及时删除缓存中的数据即可。 </p></li></ul><h2 id="JAVA8新特性"><a href="#JAVA8新特性" class="headerlink" title="JAVA8新特性"></a>JAVA8新特性</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Predicate接口是输入一个参数，返回布尔值。我们通过and方法组合两个Predicate条件，判断是否值大于0并且是偶数</span></span><br><span class="line">Predicate&lt;Integer&gt; positiveNumber = i -&gt; i &gt; <span class="number">0</span>;</span><br><span class="line">Predicate&lt;Integer&gt; evenNumber = i -&gt; i % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">assertTrue(positiveNumber.and(evenNumber).test(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Consumer接口是消费一个数据。我们通过andThen方法组合调用两个Consumer，输出两行abcdefg</span></span><br><span class="line">Consumer&lt;String&gt; println = System.out::println;</span><br><span class="line">println.andThen(println).accept(<span class="string">"abcdefg"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//Function接口是输入一个数据，计算后输出一个数据。我们先把字符串转换为大写，然后通过andThen组合另一个Function实现字符串拼接</span></span><br><span class="line">Function&lt;String, String&gt; upperCase = String::toUpperCase;</span><br><span class="line">Function&lt;String, String&gt; duplicate = s -&gt; s.concat(s);</span><br><span class="line">assertThat(upperCase.andThen(duplicate).apply(<span class="string">"test"</span>), is(<span class="string">"TESTTEST"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Supplier是提供一个数据的接口。这里我们实现获取一个随机数</span></span><br><span class="line">Supplier&lt;Integer&gt; random = ()-&gt;ThreadLocalRandom.current().nextInt();</span><br><span class="line">System.out.println(random.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">//BinaryOperator是输入两个同类型参数，输出一个同类型参数的接口。这里我们通过方法引用获得一个整数加法操作，通过Lambda表达式定义一个减法操作，然后依次调用</span></span><br><span class="line">BinaryOperator&lt;Integer&gt; add = Integer::sum;</span><br><span class="line">BinaryOperator&lt;Integer&gt; subtraction = (a, b) -&gt; a - b;</span><br><span class="line">assertThat(subtraction.apply(add.apply(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>), is(<span class="number">0</span>));</span><br></pre></td></tr></table></figure><p> 有很多类似使用 threadCount 个线程对某个方法总计执行 taskCount 次操作的案例，用于演示并发情况下的多线程问题或多线程处理性能。除了会用到并行流，我们有时也会使用线程池或直接使用线程进行类似操作。为了方便你对比各种实现，这里我一次性给出实现此类操作的五种方式。</p><p>为了测试这五种实现方式，我们设计一个场景：使用 20 个线程（threadCount）以并行方式总计执行 10000 次（taskCount）操作。因为单个任务单线程执行需要 10 毫秒（任务代码如下），也就是每秒吞吐量是 100 个操作，那 20 个线程 QPS 是 2000，执行完 10000 次操作最少耗时 5 秒。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">(AtomicInteger atomicInteger)</span> </span>&#123;</span><br><span class="line">    atomicInteger.incrementAndGet();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 现在我们测试一下这五种方式，是否都可以利用更多的线程并行执行操作。</p><p>第一种方式是使用线程。直接把任务按照线程数均匀分割，分配到不同的线程执行，使用 CountDownLatch 来阻塞主线程，直到所有线程都完成操作。这种方式，需要我们自己分割任务： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">thread</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//总操作次数计数器</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//使用CountDownLatch来等待所有线程执行完成</span></span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="comment">//使用IntStream把数字直接转为Thread</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, threadCount).mapToObj(i -&gt; <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="comment">//手动把taskCount分成taskCount份，每一份有一个线程执行</span></span><br><span class="line">        IntStream.rangeClosed(<span class="number">1</span>, taskCount / threadCount).forEach(j -&gt; increment(atomicInteger));</span><br><span class="line">        <span class="comment">//每一个线程处理完成自己那部分数据之后，countDown一次</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">    &#125;)).forEach(Thread::start);</span><br><span class="line">    <span class="comment">//等到所有线程执行完成</span></span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    <span class="comment">//查询计数器当前值</span></span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二种方式是，使用 Executors.newFixedThreadPool 来获得固定线程数的线程池，使用 execute 提交所有任务到线程池执行，最后关闭线程池等待所有任务执行完成： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">threadpool</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//总操作次数计数器</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//初始化一个线程数量=threadCount的线程池</span></span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(threadCount);</span><br><span class="line">    <span class="comment">//所有任务直接提交到线程池处理</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, taskCount).forEach(i -&gt; executorService.execute(() -&gt; increment(atomicInteger)));</span><br><span class="line">    <span class="comment">//提交关闭线程池申请，等待之前所有任务执行完成</span></span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    executorService.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    <span class="comment">//查询计数器当前值</span></span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第三种方式是，使用 ForkJoinPool 而不是普通线程池执行任务。</p><p>ForkJoinPool 和传统的 ThreadPoolExecutor 区别在于，前者对于 n 并行度有 n 个独立队列，后者是共享队列。如果有大量执行耗时比较短的任务，ThreadPoolExecutor 的单队列就可能会成为瓶颈。这时，使用 ForkJoinPool 性能会更好。</p><p>因此，ForkJoinPool 更适合大任务分割成许多小任务并行执行的场景，而 ThreadPoolExecutor 适合许多独立任务并发执行的场景。在这里，我们先自定义一个具有指定并行数的 ForkJoinPool，再通过这个 ForkJoinPool 并行执行操作： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">forkjoin</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//总操作次数计数器</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//自定义一个并行度=threadCount的ForkJoinPool</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(threadCount);</span><br><span class="line">    <span class="comment">//所有任务直接提交到线程池处理</span></span><br><span class="line">    forkJoinPool.execute(() -&gt; IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)));</span><br><span class="line">    <span class="comment">//提交关闭线程池申请，等待之前所有任务执行完成</span></span><br><span class="line">    forkJoinPool.shutdown();</span><br><span class="line">    forkJoinPool.awaitTermination(<span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line">    <span class="comment">//查询计数器当前值</span></span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第四种方式是，直接使用并行流，并行流使用公共的 ForkJoinPool，也就是 ForkJoinPool.commonPool()。公共的 ForkJoinPool 默认的并行度是 CPU 核心数 -1，原因是对于 CPU 绑定的任务分配超过 CPU 个数的线程没有意义。由于并行流还会使用主线程执行任务，也会占用一个 CPU 核心，所以公共 ForkJoinPool 的并行度即使 -1 也能用满所有 CPU 核心。</p><p>这里，我们通过配置强制指定（增大）了并行数，但因为使用的是公共 ForkJoinPool，所以可能会存在干扰，你可以回顾下第 3 讲有关线程池混用产生的问题： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">stream</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置公共ForkJoinPool的并行度</span></span><br><span class="line">System.setProperty(<span class="string">"java.util.concurrent.ForkJoinPool.common.parallelism"</span>, String.valueOf(threadCount));</span><br><span class="line">    <span class="comment">//总操作次数计数器</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//由于我们设置了公共ForkJoinPool的并行度，直接使用parallel提交任务即可</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger));</span><br><span class="line">    <span class="comment">//查询计数器当前值</span></span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第五种方式是，使用 CompletableFuture 来实现。CompletableFuture.runAsync 方法可以指定一个线程池，一般会在使用 CompletableFuture 的时候用到： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">completableFuture</span><span class="params">(<span class="keyword">int</span> taskCount, <span class="keyword">int</span> threadCount)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">    <span class="comment">//总操作次数计数器</span></span><br><span class="line">    AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="comment">//自定义一个并行度=threadCount的ForkJoinPool</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool(threadCount);</span><br><span class="line">    <span class="comment">//使用CompletableFuture.runAsync通过指定线程池异步执行任务</span></span><br><span class="line">    CompletableFuture.runAsync(() -&gt; IntStream.rangeClosed(<span class="number">1</span>, taskCount).parallel().forEach(i -&gt; increment(atomicInteger)), forkJoinPool).get();</span><br><span class="line">    <span class="comment">//查询计数器当前值</span></span><br><span class="line">    <span class="keyword">return</span> atomicInteger.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近抽零碎时间过了一个极客时间的专栏，感觉讲的还不错，本篇内容基本是原文复制粘贴了一些点过来，至于为啥没归纳总结，我说是因为时间原因，你也可以说是因为懒😂😂😂，总之这里做个记录，以备以后再看。有任何问题可以在我的&lt;a href=&quot;https://www.enjoyican.com/posts/java-errorcase&quot;&gt;博客&lt;/a&gt;留言,或者直接在&lt;a href=&quot;https://blog.csdn.net/u010408502/article/details/106312674&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CSDN&lt;/a&gt;留言。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="note" scheme="https://www.enjoyican.com/tags/note/"/>
    
  </entry>
  
  <entry>
    <title>spring-aop常用切点表达式</title>
    <link href="https://www.enjoyican.com/posts/spring-aop-pointcut/"/>
    <id>https://www.enjoyican.com/posts/spring-aop-pointcut/</id>
    <published>2020-04-06T15:52:39.748Z</published>
    <updated>2020-04-06T15:52:39.748Z</updated>
    
    <content type="html"><![CDATA[<p>AOP是spring的最重要模块之一，关于AOP的原理，主要就是基于动态代理，可以查看官网<a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-understanding-aop-proxies" target="_blank" rel="noopener">Understanding AOP Proxies</a>，本节内容不去深究AOP原理，仅仅列出在spring框架中编写AOP代码时，常用的切点表达式写法，官网上关于AOP这一节的说明，也可以看下，一定会有收获<a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop" target="_blank" rel="noopener">Aspect Oriented Programming with Spring</a>本文也是基于官方文档形成的。</p><p>需要说明的是在spring框架中共用了AspectJ的一些注解，且目前仅支持方法级别的增强，AspectJ支持更多的切点表达式，在本文例子中也不去详述，想要了解的可以去看<a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="noopener">The AspectJTM Programming Guide</a></p><p>由于本文的重点在于切点表达式的例子，所以本文所采用的增强方式一般以环绕增强为主。</p><h3 id="1-spring-aop支持的切点表达式关键字"><a href="#1-spring-aop支持的切点表达式关键字" class="headerlink" title="1. spring-aop支持的切点表达式关键字"></a>1. spring-aop支持的切点表达式关键字</h3><p>官网很明确的说明了spring支持哪些切点表达式关键字，如下:</p><blockquote><p>Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions:</p><ul><li><code>execution</code>: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP.</li><li><code>within</code>: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP).</li><li><code>this</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type.</li><li><code>target</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type.</li><li><code>args</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types.</li><li><code>@target</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type.</li><li><code>@args</code>: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types.</li><li><code>@within</code>: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP).</li><li><code>@annotation</code>: Limits matching to join points where the subject of the join point (the method being executed in Spring AOP) has the given annotation.</li></ul></blockquote><p>至于官方暂时不支持的切点表达式关键字，也列举出来了，还表示将来的版本可能会支持更多的关键字：</p><blockquote><p>Other pointcut types</p><p>The full AspectJ pointcut language supports additional pointcut designators that are not supported in Spring: <code>call</code>, <code>get</code>, <code>set</code>, <code>preinitialization</code>, <code>staticinitialization</code>, <code>initialization</code>, <code>handler</code>, <code>adviceexecution</code>, <code>withincode</code>, <code>cflow</code>, <code>cflowbelow</code>, <code>if</code>, <code>@this</code>, and <code>@withincode</code>. Use of these pointcut designators in pointcut expressions interpreted by Spring AOP results in an <code>IllegalArgumentException</code> being thrown.</p><p>The set of pointcut designators supported by Spring AOP may be extended in future releases to support more of the AspectJ pointcut designators.</p></blockquote><p>切点表达式之间支持<code>&amp;&amp;,</code> <code>||</code>  <code>!</code> 连接，连接时候可以采用具体的表达式，也可以采用pointcut注解对应的方法签名：比如在<a href="https://www.enjoyican.com/posts/custom-annotation/">spring中自定义注解</a>中用到的<code>myAnnoCut()&amp;&amp;myPointCut()</code></p><h3 id="2-常用切点表达式"><a href="#2-常用切点表达式" class="headerlink" title="2. 常用切点表达式"></a>2. 常用切点表达式</h3><p>采用<code>execution</code>关键字定义的切点表达式格式如下：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern)</span><br><span class="line">                <span class="keyword">throws</span>-pattern?)</span><br></pre></td></tr></table></figure></blockquote><p>表达式中除了返回值类型匹配规则<code>ret-type-pattern</code> (通常是 *来匹配所有返回值类型)之外的其他类型匹配规则都是可选的</p><p><code>name-pattern</code>方法名，可以是具体的方法名，也可以用*圈定所有方法</p><p><code>param-pattern</code>方法入参：<code>（）</code>匹配无参方法，<code>(..)</code>匹配多参数方法，<code>（*）</code>匹配单参数任意入参类型的方法，<code>(*,String)</code>匹配有两个入参的方法，第一个可以是任意类型，第二个必须是字符串类型。</p><p>以下是官方文档中提到的一些表达式：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> * *(..)) <span class="comment">//匹配所有public方法</span></span><br><span class="line">execution(* set*(..))<span class="comment">//匹配所有方法名开头为set的方法</span></span><br><span class="line">execution(* com.xyz.service.AccountService.*(..))<span class="comment">//匹配AccountService下的所有方法</span></span><br><span class="line">execution(* com.xyz.service.*.*(..))<span class="comment">//匹配service包下的所有方法</span></span><br><span class="line">execution(* com.xyz.service..*.*(..))<span class="comment">//匹配service包或其子包下的所有方法</span></span><br><span class="line">within(com.xyz.service.*)<span class="comment">//匹配service包下的所有方法</span></span><br><span class="line">within(com.xyz.service..*)<span class="comment">//匹配service包或其子包下的所有方法</span></span><br><span class="line"><span class="keyword">this</span>(com.xyz.service.AccountService)<span class="comment">//匹配所有实现了AccountService接口的类的代理类的方法（注意是代理类）</span></span><br><span class="line">target(com.xyz.service.AccountService)<span class="comment">//匹配所有实现了AccountService接口的类的方法（注意是本类）</span></span><br><span class="line">args(java.io.Serializable)<span class="comment">//匹配只有一个入参，且入参实现了Serializable接口的方法</span></span><br><span class="line"><span class="meta">@target</span>(org.springframework.transaction.annotation.Transactional)<span class="comment">//匹配类上标注了@Transactional注解的类中方法</span></span><br><span class="line"><span class="meta">@within</span>(org.springframework.transaction.annotation.Transactional)<span class="comment">//匹配运行时子类上标注了@Transactional注解的类中方法</span></span><br><span class="line"><span class="meta">@annotation</span>(org.springframework.transaction.annotation.Transactional)<span class="comment">//匹配所有打了@Transactional注解的方法</span></span><br><span class="line"><span class="meta">@args</span>(com.xyz.security.Classified)<span class="comment">//匹配只有一个入参，且运行时入参有@Classified注解的方法</span></span><br><span class="line">bean(tradeService)<span class="comment">//匹配命名为tradeService的类的方法</span></span><br><span class="line">bean(*Service)<span class="comment">//匹配命名后缀为Service的类的方法</span></span><br></pre></td></tr></table></figure></blockquote><blockquote><p> ‘this’ is more commonly used in a binding form. See the section on <a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-advice" target="_blank" rel="noopener">Declaring Advice</a> for how to make the proxy object available in the advice body.</p></blockquote><p>关于上面<code>@target和@within</code>区别请看<a href="https://blog.csdn.net/demon7552003/article/details/97601209" target="_blank" rel="noopener">博客</a></p><h3 id="3-运算符组合切点表达式"><a href="#3-运算符组合切点表达式" class="headerlink" title="3. 运算符组合切点表达式"></a>3. 运算符组合切点表达式</h3><p>这一部分直接列举几个，基础表达式会写之后，组合按照自己想圈定的范围进行组合运算匹配即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//或（||）运算符</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xxx.yyy.service.*.*.*(..))||"</span> +</span><br><span class="line">        <span class="string">"execution(* com.xxx.yyy.api.*.*.*(..))"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myElseCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//与（&amp;&amp;）运算符</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* com.xxx.yyy.controller..*.*(..))"</span></span><br><span class="line">        + <span class="string">"&amp;&amp; @within(org.springframework.web.bind.annotation.RestController)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAndCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"><span class="comment">//非（！）运算符</span></span><br><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"@within(org.springframework.validation.annotation.Validated)"</span></span><br><span class="line">            + <span class="string">"&amp;&amp; !@within(org.springframework.web.bind.annotation.RestController)"</span></span><br><span class="line">            + <span class="string">"&amp;&amp; !@within(org.springframework.stereotype.Controller)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myNotCut</span><span class="params">()</span></span>&#123;&#125;;</span><br></pre></td></tr></table></figure><p>组合切点表达式均可以拆分成两个切点声明，然后再使用运算符连接，这样可读性好些，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyselfAnnotionAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过切点表达式定义切点</span></span><br><span class="line">    <span class="comment">/**<span class="doctag">@Pointcut</span>("execution(* com.enjoyican.demo.selfannotion.service.impl..*(..))")</span></span><br><span class="line"><span class="comment">    public void myPointCut()&#123;&#125;;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@Pointcut</span>("<span class="doctag">@annotation</span>(MyselfAnnotion)")</span></span><br><span class="line"><span class="comment">    public void myAnnoCut()&#123;&#125;;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@Pointcut</span>("within(com.enjoyican.demo.selfannotion.service..*)")</span></span><br><span class="line"><span class="comment">    public void myWithinCut()&#123;&#125;;</span></span><br><span class="line"><span class="comment">    <span class="doctag">@Pointcut</span>("target(com.enjoyican.demo.selfannotion.service.MyAnnotionTestService)")</span></span><br><span class="line"><span class="comment">    public void myTargetCut()&#123;&#125;;*/</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@target(MyselfAnnotion)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAtTargetCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"bean(myAnnotionTestServiceImpl)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myBeanCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="comment">//定义方法增强类型（本例子采用环绕增强）</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"myBeanCut()&amp;&amp;myAtTargetCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之前增强"</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之后增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于切点表达式的熟悉可以使我们在项目中更好的写出匹配到更灵活规则的类的表达式，强烈建议看下官网中<a href="https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop" target="_blank" rel="noopener">Aspect Oriented Programming with Spring</a>这一节的内容，很多我们平时用的其实官方文档上都说明了，而且这里的英文相对简单，除了一些专业词汇外都是很通俗易懂的语句。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;AOP是spring的最重要模块之一，关于AOP的原理，主要就是基于动态代理，可以查看官网&lt;a href=&quot;https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/core.ht
      
    
    </summary>
    
    
      <category term="框架" scheme="https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="aop" scheme="https://www.enjoyican.com/tags/aop/"/>
    
      <category term="aspectj" scheme="https://www.enjoyican.com/tags/aspectj/"/>
    
      <category term="pointcut" scheme="https://www.enjoyican.com/tags/pointcut/"/>
    
  </entry>
  
  <entry>
    <title>spring中自定义注解</title>
    <link href="https://www.enjoyican.com/posts/custom-annotation/"/>
    <id>https://www.enjoyican.com/posts/custom-annotation/</id>
    <published>2020-04-06T07:33:57.500Z</published>
    <updated>2020-04-06T07:33:57.500Z</updated>
    
    <content type="html"><![CDATA[<p>自定义注解在项目开发过程中非常有用，当框架提供的注解无法满足我们的业务逻辑需求时会需要我们自定义注解，了解自定义注解之前需要先了解元注解，即所谓注解的注解，本文不详聊元注解的概念，简单粗暴上示例代码演示几种常见的自定义注解方式，<strong>想了解元注解的可以查看</strong><code>JAVA编程思想第四版第二十章注解一章</code>，或者直接网上找博客内容会有很多，下面开始正文。</p><h2 id="Controller层注解-结合spring拦截器自定义注解"><a href="#Controller层注解-结合spring拦截器自定义注解" class="headerlink" title="Controller层注解-结合spring拦截器自定义注解"></a>Controller层注解-结合spring拦截器自定义注解</h2><p>针对controller层的注解，我们一般可以采用自定义注解结合spring拦截器的方式：</p><h3 id="1-自定义注解"><a href="#1-自定义注解" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><p>首先你需要自定义一个注解，注解的定义采用关键字<code>@interface</code>来定义，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//关于元注解的知识可以网上查看资料</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="comment">//该注解只用在方法上，用在其他地方的可以查看元注解的其他枚举值，不赘述</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyselfAnnotion &#123;</span><br><span class="line">    <span class="comment">//注解的变量支持基本数据类型，字符串，枚举，以及对应的数组类型</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> "guanyu"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span> <span class="keyword">default</span> 18</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isHero</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    String[] bros() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-自定义拦截器处理注解"><a href="#2-自定义拦截器处理注解" class="headerlink" title="2. 自定义拦截器处理注解"></a>2. 自定义拦截器处理注解</h3><p>当你定义好了注解后，你需要自定义处理该注解的拦截器，在拦截器中进行业务的处理，自定义拦截器实现spring提供的接口HandlerInterceptor即可，如下</p><p>spring提供的拦截器接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求发送到Controller之前调用</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//请求发送到Controller之后调用</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完成请求的处理的回调方法</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到spring提供的拦截器接口主要有三个方法，分别用来处理不同阶段的请求，按照自己项目的需要重写其中的方法即可，比如有时候在controller你需要自定义一个注解来检测用户是否登录，登录之后将用户信息存在threadLocal中供后续调用，那么你可以在<code>preHandle</code>方法中实现相应的业务逻辑，当一次请求完成之后，你又需要将threadlocal中的信息remove掉，那么你可以在<code>afterCompletion</code>方法中进行释放，本例子中展示简单的在请求发送到controller之前的处理，因此只重写<code>preHandle</code>方法,如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotionInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (handler <span class="keyword">instanceof</span> HandlerMethod)&#123;</span><br><span class="line">            HandlerMethod method = (HandlerMethod) handler;</span><br><span class="line">            <span class="comment">//1获取方法上的注解</span></span><br><span class="line">            MyselfAnnotion methodAnnotation = method.getMethodAnnotation(MyselfAnnotion<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">//2获取类上的注解</span></span><br><span class="line">            <span class="comment">//MyselfAnnotion annotation = method.getBeanType().getAnnotation(MyselfAnnotion.class);</span></span><br><span class="line">            <span class="comment">//3获取类中属性的注解</span></span><br><span class="line">            <span class="comment">/*Field[] declaredFields = method.getBeanType().getDeclaredFields();</span></span><br><span class="line"><span class="comment">            for (Field field:declaredFields)&#123;</span></span><br><span class="line"><span class="comment">                field.setAccessible(true);</span></span><br><span class="line"><span class="comment">                MyselfAnnotion annotation = field.getAnnotation(MyselfAnnotion.class);</span></span><br><span class="line"><span class="comment">            &#125;*/</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == methodAnnotation)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MyAnnotionEnum.GUANYU.getName().equals(methodAnnotation.name()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"拦截器检测到是五虎上将"</span> + methodAnnotation.name());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"拦截器检测到不是关羽，是"</span>+ methodAnnotation.name() +<span class="string">"不能通关"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (MyAnnotionEnum.GUANYU.getAge().equals(methodAnnotation.age()))&#123;</span><br><span class="line">                System.out.println(<span class="string">"拦截器检测到这是18岁的关羽，威猛，过关"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"拦截器检测到这个关羽老了，不能通关"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拦截器中用到的枚举类</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> MyAnnotionEnum &#123;</span><br><span class="line">    LIUBEI(<span class="string">"liubei"</span>,<span class="number">48</span>),</span><br><span class="line">    ZHANGFEI(<span class="string">"zhangfei"</span>,<span class="number">24</span>),</span><br><span class="line">    GUANYU(<span class="string">"guanyu"</span>,<span class="number">18</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面自定义的拦截器中，在preHandle方法中有如下的逻辑，首先获取判定该handler是否是handlermethod实例,关于handlermethod可以理解为存储着controller中每个@RequestMapping注解方法的对象，可以上官网了解下：<a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">springmvc</a>，这里简单说下理解：</p><p><code>Spring MVC</code>应用启动时会搜集并分析每个Web控制器方法，从中提取对应的<code>&quot;&lt;请求匹配条件,控制器方法&gt;&quot;</code>映射关系，形成一个映射关系表保存在一个<code>RequestMappingHandlerMapping bean</code>中。然后在客户请求到达时，再使用<code>RequestMappingHandlerMapping</code>中的该映射关系表找到相应的控制器方法去处理该请求。在<code>RequestMappingHandlerMapping</code>中保存的每个<code>”&lt;请求匹配条件,控制器方法&gt;&quot;</code>映射关系对儿中,”请求匹配条件”通过<code>RequestMappingInfo</code>包装和表示，而”控制器方法”则通过<code>HandlerMethod</code>来包装和表示。(<strong>想了解这部分内容的可以查看spring技术内幕-计文柯第二版中p166，第4.4.4小节 Mvc处理HTTP分发请求这一小节，也可以看看spring源码深度解析-郝佳一书中p291，第11章 springmvc</strong>)</p><p>一个<code>HandlerMethod</code>对象，可以认为是对如下信息的一个包装 :<br><code>Object bean</code>    Web控制器方法所在的Web控制器bean。可以是字符串，代表bean的名称;也可以是bean实例对象本身。<br><code>Class beanType</code>    Web控制器方法所在的Web控制器bean的类型,如果该bean被代理，这里记录的是被代理的用户类信息<br><code>Method method</code>    Web控制器方法<br><code>Method bridgedMethod</code>    被桥接的Web控制器方法<br><code>MethodParameter[] parameters</code>    Web控制器方法的参数信息:所在类所在方法,参数,索引,参数类型<br><code>HttpStatus responseStatus</code>    注解@ResponseStatus的code属性<br><code>String responseStatusReason</code>    注解@ResponseStatus的reason属性</p><p>如果该handler是handlermethod实例，则判断是否有自定义注解<code>MyselfAnnotion</code>在方法上，如果没有直接返回true放行，如果有继续判断注解中name是否关羽，是否年龄18，两者都满足就放行，不满足则不放行。</p><h3 id="3-将自定义拦截器注册进webMvc拦截器链并定义拦截路由"><a href="#3-将自定义拦截器注册进webMvc拦截器链并定义拦截路由" class="headerlink" title="3.  将自定义拦截器注册进webMvc拦截器链并定义拦截路由"></a>3.  将自定义拦截器注册进webMvc拦截器链并定义拦截路由</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注册拦截器，拦截特定请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotionInterceptorConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurationSupport</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入自定义的拦截器</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAnnotionInterceptor myAnnotionInterceptor;</span><br><span class="line">    <span class="comment">//注册拦截器并定义拦截路由</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myAnnotionInterceptor).addPathPatterns(<span class="string">"/testMyselfAnno/**"</span>);</span><br><span class="line">        <span class="keyword">super</span>.addInterceptors(registry);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，结合拦截器自定义的注解已经完成，可以编写测试类controller测试下，如下：</p><h3 id="4-编写测试Controller类"><a href="#4-编写测试Controller类" class="headerlink" title="4. 编写测试Controller类"></a>4. 编写测试Controller类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testMyselfAnno/no"</span>)</span><br><span class="line">  <span class="meta">@MyselfAnnotion</span>(name = <span class="string">"guanyu"</span>, age = <span class="number">50</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion1</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"虽然是关羽，但是年龄大了，没通过校验"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/yes"</span>)</span><br><span class="line">  <span class="meta">@MyselfAnnotion</span>(name = <span class="string">"guanyu"</span>, age = <span class="number">50</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion2</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"虽然有注解，但是路径不属于拦截范围，通过校验,进入方法体"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/testMyselfAnno/liubei/no"</span>)</span><br><span class="line">  <span class="meta">@MyselfAnnotion</span>(name = <span class="string">"liubei"</span>, age = <span class="number">48</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion3</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"不是关羽，无法通过校验"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@RequestMapping</span>(<span class="string">"/testMyselfAnno/defaultyes"</span>)</span><br><span class="line">  <span class="meta">@MyselfAnnotion</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion4</span><span class="params">()</span></span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"注解默认值是关羽，而且很年轻，通过校验，进入方法体"</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们依次在<code>postman</code>上访问对应的接口（或者通过spring-test包的mockmvc去mock）查看对应结果：</p><p>1）访问方法testMyAnnotion1上的路由 /testMyselfAnno/no</p><p>首先该路径能够匹配上我们在配置中配的要拦截的路径，且该方法上含有<code>@MyselfAnnotion</code>自定义注解，其中name的确是关羽，所以在拦截器处理时会打印出<code>&quot;拦截器检测到是五虎上将guanyu&quot;</code>,之后判定年龄，由于注解中年龄为50，拦截器处理时会打印出<code>&quot;拦截器检测到这个关羽老了，不能通关&quot;</code>,之后返回false，不会走进方法中的具体打印。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/annotion1.png" alt="访问接口1" title="">                </div>                <div class="image-caption">访问接口1</div>            </figure><p>其他例子也可自行分析后自测体验下。</p><h2 id="Service层注解-结合SpringAOP自定义注解"><a href="#Service层注解-结合SpringAOP自定义注解" class="headerlink" title="Service层注解-结合SpringAOP自定义注解"></a>Service层注解-结合SpringAOP自定义注解</h2><h3 id="1-自定义注解-1"><a href="#1-自定义注解-1" class="headerlink" title="1. 自定义注解"></a>1. 自定义注解</h3><p>注解还是采用上文中的注解@MyselfAnnotion</p><h3 id="2-自定义切面处理注解"><a href="#2-自定义切面处理注解" class="headerlink" title="2.自定义切面处理注解"></a>2.自定义切面处理注解</h3><p>在自定义切面之前，先在之前的Controller层新增加一个接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotionTestController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> MyAnnotionTestService myAnnotionTestService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/test/aop"</span>)</span><br><span class="line">    <span class="meta">@MyselfAnnotion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自Controller层，我用来测试自定义注解"</span>);</span><br><span class="line">        myAnnotionTestService.testAopAnnotion();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后定义service层接口及实现类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyAnnotionTestService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAopAnnotion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现类</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAnnotionTestServiceImpl</span> <span class="keyword">implements</span> <span class="title">MyAnnotionTestService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@MyselfAnnotion</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAopAnnotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我来自service层，我用来测试自定义注解"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于本案例展示service层的注解与AOP切面的结合，所以暂时在示例时指定切点表达式具体到service层，下面定义切面，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyselfAnnotionAspect</span> </span>&#123;</span><br><span class="line">    <span class="comment">//通过切点表达式定义切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.enjoyican.demo.selfannotion.service.impl..*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"@annotation(MyselfAnnotion)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myAnnoCut</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义方法增强类型（本例子采用环绕增强）</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"myAnnoCut()&amp;&amp;myPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之前增强"</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之后增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先上面的切面定义了两个切点，一个是定义到<code>service.impl</code>包下,另一个定义成带有注解<code>MyselfAnnotion</code>的类，然后定义一个环绕增强，切点表达式采用两者结合即可定位到对应的service层下面打了<code>@MyselfAnnotion</code>注解的类中（本例子之所以这么定义是为了稍后演示方便，切点表达式也可以合成一个，后面我会专门说下spring中切点表达式的案例的）</p><p>现在的IDEA智能提示非常方便，当你的切面定义好后，在增强方法对应地方光标会显示增强了哪些方法，比如按照我上面的写法，会出现如下提示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/2.png" alt="IDEA提示" title="">                </div>                <div class="image-caption">IDEA提示</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/3.png" alt="IDEA提示" title="">                </div>                <div class="image-caption">IDEA提示</div>            </figure><h3 id="3-测试注解"><a href="#3-测试注解" class="headerlink" title="3.  测试注解"></a>3.  测试注解</h3><p>如上面切面定义好了，在切面中我们做了一件事就是在执行service方法的前后打印了两句话（在实际业务中可以是在执行service方法前后进行一些处理，比如打印入参，返回值或其他功能），接下来通过postman跑下对应的接口，得到如下响应：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/4.png" alt="注解响应" title="">                </div>                <div class="image-caption">注解响应</div>            </figure><p>可以看到虽然我们在controller层和service层都加了<code>@MyselfAnnotion</code>注解，但是我们切面只处理service层的，所以在打印controller层的“我来自Controller层，我用来测试自定义注解”这句话的前后并没有进行增强，而service按照我们想的进行了方法增强。</p><p>上面举的例子比较简单，实际业务中将注解用到service层某些方法之上来实现我们的业务逻辑的情况很常见，相比仅仅用切面去控制，通过一个注解控制的力度更细更灵活一些，也更方便操作。</p><p>另外本例中虽然以在service层通过注解加AOP的形式来自定义注解处理业务逻辑，但实际上controller层的有些场景也可以用aop来控制，并不是必须要采用拦截器，这个要看你具体想获取的是哪些信息以及需要在哪个阶段增强有关，如果用aop控制的话也就是切点表达式怎么写的问题。</p><p>比如，在上面例子中，加入将环绕增强变成如下形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义方法增强类型（本例子采用环绕增强）</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"myAnnoCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之前增强"</span>);</span><br><span class="line">        point.proceed();</span><br><span class="line">        System.out.println(<span class="string">"AOP切面在执行service方法之后增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时我们的增强对象是所有打了<code>@MyselfAnnotion</code>注解的方法，因此这个情况下controller层的方法也会被增强，此时IDEA的提示也会显示出来，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/5.png" alt="IDEA提示" title="">                </div>                <div class="image-caption">IDEA提示</div>            </figure><p>因为此时被增强的方法多了，所以点击时候会显示都有哪些被增强。此时我们再访问刚才的接口，得到的响应如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/6.png" alt="注解响应" title="">                </div>                <div class="image-caption">注解响应</div>            </figure><p>可看到在controller和service层方法执行前后，都被增强了（<strong>忽略上面AOP提示中都是显示service增强</strong>）</p><h2 id="参数校验型自定义注解"><a href="#参数校验型自定义注解" class="headerlink" title="参数校验型自定义注解"></a>参数校验型自定义注解</h2><p>在开发过程中，还有一类注解不得不提，就是通常用来对方法入参进行校验的注解。对方法入参进行校验，当然也可以通过aop来处理，通过获取属性上的注解，进行判定。在springmvc中，我们借助常用的hibernate-validator即可实现大部分入参的校验，<strong>关于使用hibernate-validator进行校验的知识，可以参考<a href="http://hibernate.org/validator/" target="_blank" rel="noopener">官方文档</a>或者从网上搜索相关资源即可，本小结不对此做特别说明，也可以看下如下博客<a href="https://blog.csdn.net/fred_lzy/article/details/81099699" target="_blank" rel="noopener">基于注解校验入参</a></strong>，<strong><a href="https://spldeolin.com/posts/spring-component-validated/" target="_blank" rel="noopener">spring组件参数校验</a></strong></p><p>有时候我们的需求在现有的注解中可能没找到合适的，这时候可能需要我们自定义注解 ，本例子中说明一个自定义校验入参中枚举值是否符合现有枚举值的自定义注解，前置知识可以看下<a href="https://blog.csdn.net/lwg_1540652358/article/details/84193759" target="_blank" rel="noopener">这篇博客</a></p><h3 id="1-自定义注解-2"><a href="#1-自定义注解-2" class="headerlink" title="1.自定义注解"></a>1.自定义注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="comment">//注意这个注解</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;ValidEnumValueValidator<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">Target</span>(</span>&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> ValidEnumValue &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "不是有效的枚举值"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"><span class="comment">//这里的ValidityInterpretable接口在后面定义</span></span><br><span class="line">    Class&lt;? extends ValidityInterpretable&gt; enumType();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-定义-Constraint中用到的校验规则类"><a href="#2-定义-Constraint中用到的校验规则类" class="headerlink" title="2.定义@Constraint中用到的校验规则类"></a>2.定义@Constraint中用到的校验规则类</h3><p>在本例中即为<code>ValidEnumValueValidator</code>，注意需要实现<code>ConstraintValidator&lt;ValidEnumValue, Integer&gt;</code>接口，泛型接口中的两个参数一个是自定义的注解<code>ValidEnumValue</code>，另外一个为自定义的校验注解中校验值的类型，根据实际业务需要确定</p><p>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidEnumValueValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">ValidEnumValue</span>, <span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ValidityInterpretable validityInterpretable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(ValidEnumValue constraintAnnotation)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化加载所有枚举类</span></span><br><span class="line">        ValidityInterpretable[] enumConstants = constraintAnnotation.enumType().getEnumConstants();</span><br><span class="line">        <span class="keyword">if</span> (enumConstants.length == <span class="number">0</span>) &#123;</span><br><span class="line">            isEmpty = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        validityInterpretable = enumConstants[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//判断有效性的具体逻辑由子类重写</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validityInterpretable.isValid(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-定义对应的子类重写父类中的方法-即相关的校验逻辑"><a href="#3-定义对应的子类重写父类中的方法-即相关的校验逻辑" class="headerlink" title="3.定义对应的子类重写父类中的方法,即相关的校验逻辑"></a>3.定义对应的子类重写父类中的方法,即相关的校验逻辑</h3><p>首先定义注解中用到的<code>ValidityInterpretable</code>接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidityInterpretable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断value对该enum而言是否是有效的枚举值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次定义一个子类实现该接口，重写校验的方法，该子类为我们枚举值定义的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdolOrderEnum implements ValidityInterpretable &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 蔡徐坤</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CAI_XU_KUN(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 陈立农</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CHEN_LI_NONG(<span class="number">2</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 范丞丞</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FAN_CHEN_CHEN(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values()).anyMatch(one -&gt; one.getValue().equals(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的枚举我们定义了一个偶像排名的枚举类（此处引用偶像练习生ninepercent出道排名，没别的原因，仅仅是今天微博热搜上看到的），其中提供了一个<code>isValid</code>方法用来校验所有的枚举值value中有没有与我传入的value相同的，有说明该入参符合规范，没有说明入参不符合规矩，下面编写一个测试类来说明</p><h3 id="4-注解的使用"><a href="#4-注解的使用" class="headerlink" title="4.注解的使用"></a>4.注解的使用</h3><p>注解的使用，在入参dto中需要校验字段有效性的地方，打上自定义的注解，来判断前端或者api调用中对方传来的参数是否符合要求：</p><p>首先定义一个入参DTO对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRequest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="comment">//此处打上对应的注解，注明校验的枚举类</span></span><br><span class="line">    <span class="meta">@ValidEnumValue</span>(enumType = IdolOrderEnum<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Integer</span> <span class="title">order</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后依然采用之前的<code>MyAnnotionTestController</code>在其中添加一个方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test/validator"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMyAnnotion6</span><span class="params">(@RequestBody @Valid MyRequest request, BindingResult result)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result.hasErrors())&#123;</span><br><span class="line">            List&lt;FieldError&gt; fieldErrors = result.getFieldErrors();</span><br><span class="line">            <span class="keyword">for</span> (FieldError error : fieldErrors) &#123;</span><br><span class="line">                <span class="comment">//可以返回具体的错误异常</span></span><br><span class="line">                System.out.println(error.getField()+error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"测试入参校验自定义注解,入参："</span>+request.toString());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>之后用postman访问，加入我们传入一个枚举中没有的值，order=4，就会无法通过校验，如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/7.png" alt="注解响应" title="">                </div>                <div class="image-caption">注解响应</div>            </figure><p>如果我们传入正确的值，就会通过校验，执行方法后面的代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/custom-annotion/8.png" alt="注解响应" title="">                </div>                <div class="image-caption">注解响应</div>            </figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上总结了结合拦截器，aop，以及@Constraint注解来处理自定义注解的案例，在实际开发中自定义注解是比较有用的，可以方便我们开发。需要注意的是，自定义注解的使用并不是一定要结合上面三种情况，我们知道注解通过反射可以拿到，那么有时候我们在类属性字段上的注解只需要通过反射获取之后，进行对应的判定和业务逻辑处理即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自定义注解在项目开发过程中非常有用，当框架提供的注解无法满足我们的业务逻辑需求时会需要我们自定义注解，了解自定义注解之前需要先了解元注解，即所谓注解的注解，本文不详聊元注解的概念，简单粗暴上示例代码演示几种常见的自定义注解方式，&lt;strong&gt;想了解元注解的可以查看&lt;/st
      
    
    </summary>
    
    
      <category term="spring" scheme="https://www.enjoyican.com/categories/spring/"/>
    
    
      <category term="aop" scheme="https://www.enjoyican.com/tags/aop/"/>
    
      <category term="annotion" scheme="https://www.enjoyican.com/tags/annotion/"/>
    
  </entry>
  
  <entry>
    <title>转载-设计模式也可以这么简单</title>
    <link href="https://www.enjoyican.com/posts/design-pattern/"/>
    <id>https://www.enjoyican.com/posts/design-pattern/</id>
    <published>2020-03-23T15:22:15.000Z</published>
    <updated>2020-03-23T15:22:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明</em></strong>  :  <strong>本文转载自我关注的一位大佬的博客,<a href="https://www.javadoop.com/post/design-pattern" target="_blank" rel="noopener">原文链接</a> 如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.</strong></p><p><strong>可在<a href="https://www.enjoyican.com/posts/design-pattern/">blog-design-pattern</a> 或CSDN留言</strong></p><p>一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。</p><p>设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 <em>Gang of Four</em> (<em>GoF</em>) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。</p><p>有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：</p><ol><li>面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。</li><li>职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。</li><li>对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。</li></ol><p><strong>创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。</strong></p><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>和名字一样简单，非常简单，直接上代码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"noodle"</span>)) &#123;</span><br><span class="line">            Food noodle = <span class="keyword">new</span> LanZhouNoodle();</span><br><span class="line">            noodle.addSpicy(<span class="string">"more"</span>);</span><br><span class="line">            <span class="keyword">return</span> noodle;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"chicken"</span>)) &#123;</span><br><span class="line">            Food chicken = <span class="keyword">new</span> HuangMenChicken();</span><br><span class="line">            chicken.addCondiment(<span class="string">"potato"</span>);</span><br><span class="line">            <span class="keyword">return</span> chicken;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</em></p><p>简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。</p><blockquote><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。</p></blockquote><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。</p><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然都是调用 makeFood(“A”)  制作 A 类食物，但是，不同的工厂生产出来的完全不一样。</p><p>第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。</p><p><strong>核心在于，我们需要在第一步选好我们需要的工厂</strong>。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。</p><p>虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/factory-1.png" alt="工厂模式类图" title="">                </div>                <div class="image-caption">工厂模式类图</div>            </figure><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/abstract-factory-1.png" alt="抽象工厂模式类图" title="">                </div>                <div class="image-caption">抽象工厂模式类图</div>            </figure><p>这个时候的客户端调用是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">CPUFactory intelCPUFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">MainBoard mainBoard = mainBoardFactory.make();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br></pre></td></tr></table></figure><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/abstract-factory-2.png" alt="产品族示意图" title="">                </div>                <div class="image-caption">产品族示意图</div>            </figure><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/abstract-factory-3.png" alt="抽象工厂模式示例" title="">                </div>                <div class="image-caption">抽象工厂模式示例</div>            </figure><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">    ComputerFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">    <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">    CPU cpu = cf.makeCPU();</span><br><span class="line">    <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">    MainBoard board = cf.makeMainBoard();</span><br><span class="line">  <span class="comment">// 从这个大厂造硬盘</span></span><br><span class="line">  HardDisk hardDisk = cf.makeHardDisk();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">    Computer result = <span class="keyword">new</span> Computer(cpu, board, hardDisk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式用得最多，错得最多。</p><p>饿汉模式最简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，将 new Singleton() 堵死</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line">    <span class="comment">// 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)，</span></span><br><span class="line">    <span class="comment">// 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">getDate</span><span class="params">(String mode)</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Date();&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。</p></blockquote><p>饱汉模式最容易出错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，也是先堵死 new Singleton() 这条路</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 加锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="comment">// 这一次判断也是必须的，不然会有并发问题</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双重检查，指的是两次检查 instance 是否为 null。</p><p>volatile 在这里是需要的，希望能引起读者的关注。</p><p>很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。</p></blockquote><p>嵌套类最经典，以后大家就用它吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，很多人都会把这个<strong>嵌套类</strong>说成是<strong>静态内部类</strong>，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。</p></blockquote><p>最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。</p><p>虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。</p><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><p>经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Food food = <span class="keyword">new</span> FoodBuilder().a().b().c().build();</span><br><span class="line">Food food = Food.builder().a().b().c().build();</span><br></pre></td></tr></table></figure><p>套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。</p><p>来一个中规中矩的建造者模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 下面是“一堆”的属性</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造方法私有化，不然客户端就会直接调用构造方法了</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">User</span><span class="params">(String name, String password, String nickName, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">        <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯，</span></span><br><span class="line">    <span class="comment">// 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserBuilder();</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBuilder</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 下面是和 User 一模一样的一堆属性</span></span><br><span class="line">        <span class="keyword">private</span> String  name;</span><br><span class="line">        <span class="keyword">private</span> String password;</span><br><span class="line">        <span class="keyword">private</span> String nickName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">UserBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 链式调用设置各个属性值，返回 this，即 UserBuilder</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">password</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.password = password;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">nickName</span><span class="params">(String nickName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.nickName = nickName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> UserBuilder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。</span></span><br><span class="line">        <span class="comment">// 当然，可以在 “复制” 之前做点检验</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span> || password == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"用户名和密码必填"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (age &lt;= <span class="number">0</span> || age &gt;= <span class="number">150</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"年龄不合法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 还可以做赋予”默认值“的功能</span></span><br><span class="line">          <span class="keyword">if</span> (nickName == <span class="keyword">null</span>) &#123;</span><br><span class="line">                nickName = name;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(name, password, nickName, age);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性<strong>复制</strong>给实际产生的对象。</p><p>看看客户端的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">APP</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User d = User.builder()</span><br><span class="line">                .name(<span class="string">"foo"</span>)</span><br><span class="line">                .password(<span class="string">"pAss12345"</span>)</span><br><span class="line">                .age(<span class="number">25</span>)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说实话，建造者模式的<strong>链式</strong>写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 <strong>Builder 的构造方法</strong>中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。</p><blockquote><p>题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String  name;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>怎么样，省下来的时间是不是又可以干点别的了。</p></blockquote><p>当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 <strong>return this</strong> 就可以了，然后就可以像下面这样调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User().setName(<span class="string">""</span>).setPassword(<span class="string">""</span>).setAge(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><blockquote><p>很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。</p></blockquote><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>这是我要说的创建型模式的最后一个设计模式了。</p><p>原型模式很简单：有一个原型<strong>实例</strong>，基于这个原型实例产生新的实例，也就是“克隆”了。</p><p>Object 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先<strong>实现 Cloneable 接口</strong>，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure><blockquote><p>java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。</p></blockquote><p>原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。</p><h3 id="创建型模式总结"><a href="#创建型模式总结" class="headerlink" title="创建型模式总结"></a>创建型模式总结</h3><p>创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是<strong>面向对象</strong>的代码，所以我们第一步当然是需要创建一个对象了。</p><p>简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。</p><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><p>前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。</p><p>既然说是<strong>代理</strong>，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。</p><blockquote><p>理解<strong>代理</strong>这个词，这个模式其实就简单了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeChicken</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Food <span class="title">makeNoodle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodServiceImpl</span> <span class="keyword">implements</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      Food f = <span class="keyword">new</span> Chicken()</span><br><span class="line">        f.setChicken(<span class="string">"1kg"</span>);</span><br><span class="line">      f.setSpicy(<span class="string">"1g"</span>);</span><br><span class="line">      f.setSalt(<span class="string">"3g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Food f = <span class="keyword">new</span> Noodle();</span><br><span class="line">        f.setNoodle(<span class="string">"500g"</span>);</span><br><span class="line">        f.setSalt(<span class="string">"5g"</span>);</span><br><span class="line">        <span class="keyword">return</span> f;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理要表现得“就像是”真实实现类，所以需要实现 FoodService</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FoodServiceProxy</span> <span class="keyword">implements</span> <span class="title">FoodService</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 内部一定要有一个真实的实现类，当然也可以通过构造方法注入</span></span><br><span class="line">    <span class="keyword">private</span> FoodService foodService = <span class="keyword">new</span> FoodServiceImpl();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeChicken</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我们马上要开始制作鸡肉了"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的，</span></span><br><span class="line">        <span class="comment">// 代理只是在核心代码前后做些“无足轻重”的事情</span></span><br><span class="line">        Food food = foodService.makeChicken();</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"鸡肉制作完成啦，加点胡椒粉"</span>); <span class="comment">// 增强</span></span><br><span class="line">      food.addCondiment(<span class="string">"pepper"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeNoodle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备制作拉面~"</span>);</span><br><span class="line">        Food food = foodService.makeNoodle();</span><br><span class="line">        System.out.println(<span class="string">"制作完成啦"</span>)</span><br><span class="line">        <span class="keyword">return</span> food;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用，注意，我们要用代理来实例化接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里用代理类来实例化</span></span><br><span class="line">FoodService foodService = <span class="keyword">new</span> FoodServiceProxy();</span><br><span class="line">foodService.makeChicken();</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/proxy-1.png" alt="代理模式类图" title="">                </div>                <div class="image-caption">代理模式类图</div>            </figure><p>我们发现没有，代理模式说白了就是做 <strong>“方法包装”</strong> 或做 <strong>“方法增强”</strong>。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。</p><p>说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。</p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。</p><p>适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。</p><p>适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。</p><h4 id="默认适配器模式"><a href="#默认适配器模式" class="headerlink" title="默认适配器模式"></a>默认适配器模式</h4><p>首先，我们先看看最简单的适配器模式<strong>默认适配器模式(Default Adapter)</strong>是怎么样的。</p><p>我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileAlterationListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的<strong>文件创建</strong>和<strong>文件删除</strong>事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。</p><p>所以，我们需要下面的一个<strong>适配器</strong>，它用于实现上面的接口，但是<strong>所有的方法都是空方法</strong>，这样，我们就可以转而定义自己的类来继承下面这个类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileAlterationListenerAdaptor</span> <span class="keyword">implements</span> <span class="title">FileAlterationListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryCreate</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryChange</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDirectoryDelete</span><span class="params">(<span class="keyword">final</span> File directory)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileChange</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">(<span class="keyword">final</span> FileAlterationObserver observer)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileMonitor</span> <span class="keyword">extends</span> <span class="title">FileAlterationListenerAdaptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileCreate</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件创建</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFileDelete</span><span class="params">(<span class="keyword">final</span> File file)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 文件删除</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍<strong>“正统的”</strong>适配器模式。</p><h4 id="对象适配器模式"><a href="#对象适配器模式" class="headerlink" title="对象适配器模式"></a>对象适配器模式</h4><p>来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>; <span class="comment">// 鸭的呱呱叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>; <span class="comment">// 鸡的咕咕叫</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>; <span class="comment">// 飞</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildCock</span> <span class="keyword">implements</span> <span class="title">Cock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"咕咕叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"鸡也会飞哦"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CockAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    Cock cock;</span><br><span class="line">    <span class="comment">// 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CockAdapter</span><span class="params">(Cock cock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cock = cock;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 实现鸭的呱呱叫方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 内部其实是一只鸡的咕咕叫</span></span><br><span class="line">        cock.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cock.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用很简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 有一只野鸡</span></span><br><span class="line">  Cock wildCock = <span class="keyword">new</span> WildCock();</span><br><span class="line">  <span class="comment">// 成功将野鸡适配成鸭</span></span><br><span class="line">  Duck duck = <span class="keyword">new</span> CockAdapter(wildCock);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。</p><p>我们用一个图来简单说明下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/adapter-1.png" alt="对象适配器类图" title="">                </div>                <div class="image-caption">对象适配器类图</div>            </figure><p>上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。</p><h4 id="类适配器模式"><a href="#类适配器模式" class="headerlink" title="类适配器模式"></a>类适配器模式</h4><p>废话少说，直接上图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/adapter-2.png" alt="类适配器模式类图" title="">                </div>                <div class="image-caption">类适配器模式类图</div>            </figure><p>看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 <code>Target t = new SomeAdapter();</code> 就可以了。</p><h4 id="适配器模式总结"><a href="#适配器模式总结" class="headerlink" title="适配器模式总结"></a>适配器模式总结</h4><ol><li><p>类适配和对象适配的异同</p><blockquote><p>一个采用继承，一个采用组合；</p><p>类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。</p><p>总体来说，对象适配用得比较多。</p></blockquote></li><li><p>适配器模式和代理模式的异同</p><p>比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。</p><p><img src="https://www.enjoyican.com/img/design-pattern/adapter-5.png" alt="代理模式与适配器模式类图对比"></p></li></ol><h3 id="桥梁模式"><a href="#桥梁模式" class="headerlink" title="桥梁模式"></a>桥梁模式</h3><p>理解桥梁模式，其实就是理解代码抽象和解耦。</p><p>我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一系列实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">DrawAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义一个抽象类，此类的实现类都需要使用 DrawAPI：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> DrawAPI drawAPI;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drawAPI = drawAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义抽象类的子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">int</span> radius, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawAPI.draw(radius, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 长方形</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, DrawAPI drawAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drawAPI);</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        drawAPI.draw(<span class="number">0</span>, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们来看客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Shape greenCircle = <span class="keyword">new</span> Circle(<span class="number">10</span>, <span class="keyword">new</span> GreenPen());</span><br><span class="line">    Shape redRectangle = <span class="keyword">new</span> Rectangle(<span class="number">4</span>, <span class="number">8</span>, <span class="keyword">new</span> RedPen());</span><br><span class="line">    greenCircle.draw();</span><br><span class="line">    redRectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/bridge-1.png" alt="桥梁模式类图示例" title="">                </div>                <div class="image-caption">桥梁模式类图示例</div>            </figure><p>这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。</p><blockquote><p>本节引用了<a href="https://www.tutorialspoint.com/design_pattern/bridge_pattern.htm" target="_blank" rel="noopener">这里</a>的例子，并对其进行了修改。</p></blockquote><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 <strong>Java IO</strong> 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。</p><p>首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/decorator-1.png" alt="装饰者模式类图示例" title="">                </div>                <div class="image-caption">装饰者模式类图示例</div>            </figure><p>我们来说说装饰模式的优缺点，从图中可以看到，接口 <code>Component</code> 其实已经有了 <code>ConcreteComponentA</code> 和 <code>ConcreteComponentB</code> 两个实现类了，但是，如果我们要<strong>增强</strong>这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来<strong>装饰</strong>实现类，以达到增强的目的。</p><blockquote><p>从名字来简单解释下装饰器。既然说是装饰，那么往往就是<strong>添加小功能</strong>这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。</p></blockquote><p>首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们 <strong>ConcreteDecorator</strong> 都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 <strong>ConcreteComponent</strong> 的区别是，它们只是装饰者，起<strong>装饰</strong>作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中<strong>加了层皮来装饰</strong>而已。</p><blockquote><p>注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。</p></blockquote><p>下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。</p><p>最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。</p><p>在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea……但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？</p><p>不说废话了，上代码。</p><p>首先，定义饮料抽象基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 返回描述</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 返回价格</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是三个基础饮料实现类，红茶、绿茶和咖啡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlackTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"红茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenTea</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"绿茶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 咖啡省略</span></span><br></pre></td></tr></table></figure><p>定义调料，也就是装饰者的基类，此类必须继承自 Beverage：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调料</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Condiment</span> <span class="keyword">extends</span> <span class="title">Beverage</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lemon</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="comment">// 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶，</span></span><br><span class="line">    <span class="comment">// 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Lemon</span><span class="params">(Beverage bevarage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加柠檬"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 装饰</span></span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">2</span>; <span class="comment">// 加柠檬需要 2 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mango</span> <span class="keyword">extends</span> <span class="title">Condiment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Beverage bevarage;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Mango</span><span class="params">(Beverage bevarage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bevarage = bevarage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bevarage.getDescription() + <span class="string">", 加芒果"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beverage.cost() + <span class="number">3</span>; <span class="comment">// 加芒果需要 3 元</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...<span class="comment">// 给每一种调料都加一个类</span></span><br></pre></td></tr></table></figure><p>看客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 首先，我们需要一个基础饮料，红茶、绿茶或咖啡</span></span><br><span class="line">    Beverage beverage = <span class="keyword">new</span> GreenTea();</span><br><span class="line">    <span class="comment">// 开始装饰</span></span><br><span class="line">    beverage = <span class="keyword">new</span> Lemon(beverage); <span class="comment">// 先加一份柠檬</span></span><br><span class="line">    beverage = <span class="keyword">new</span> Mongo(beverage); <span class="comment">// 再加一份芒果</span></span><br><span class="line"></span><br><span class="line">    System.out.println(beverage.getDescription() + <span class="string">" 价格：￥"</span> + beverage.cost());</span><br><span class="line">    <span class="comment">//"绿茶, 加柠檬, 加芒果 价格：￥16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们需要 <strong>芒果-珍珠-双份柠檬-红茶</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Beverage beverage = <span class="keyword">new</span> Mongo(<span class="keyword">new</span> Pearl(<span class="keyword">new</span> Lemon(<span class="keyword">new</span> Lemon(<span class="keyword">new</span> BlackTea()))));</span><br></pre></td></tr></table></figure><p>是不是很变态？</p><p>看看下图可能会清晰一些：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/decorator-2.png" alt="装饰者模式类图示例二" title="">                </div>                <div class="image-caption">装饰者模式类图示例二</div>            </figure><p>到这里，大家应该已经清楚装饰模式了吧。</p><p>下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/decorator-3.png" alt="IO流中的装饰者模式示例" title="">                </div>                <div class="image-caption">IO流中的装饰者模式示例</div>            </figure><p>我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。</p><p>FilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。</p><p>当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> LineNumberInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">""</span>)));</span><br></pre></td></tr></table></figure><p>这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。</p><p>我们应该像下面这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream is = <span class="keyword">new</span> DataInputStream(</span><br><span class="line">  <span class="keyword">new</span> BufferedInputStream(</span><br><span class="line">                              <span class="keyword">new</span> FileInputStream(<span class="string">""</span>)));</span><br></pre></td></tr></table></figure><blockquote><p>所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。</p></blockquote><h3 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h3><p>门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。</p><p>首先，我们定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义几个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Circle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">implements</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"Rectangle::draw()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 画一个圆形</span></span><br><span class="line">  Shape circle = <span class="keyword">new</span> Circle();</span><br><span class="line">  circle.draw();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 画一个长方形</span></span><br><span class="line">  Shape rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">  rectangle.draw();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。</p><p>下面，我们看看怎么用门面模式来让客户端调用更加友好一些。</p><p>我们先定义一个门面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeMaker</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Shape circle;</span><br><span class="line">   <span class="keyword">private</span> Shape rectangle;</span><br><span class="line">   <span class="keyword">private</span> Shape square;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ShapeMaker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      circle = <span class="keyword">new</span> Circle();</span><br><span class="line">      rectangle = <span class="keyword">new</span> Rectangle();</span><br><span class="line">      square = <span class="keyword">new</span> Square();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawCircle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      circle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawRectangle</span><span class="params">()</span></span>&#123;</span><br><span class="line">      rectangle.draw();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSquare</span><span class="params">()</span></span>&#123;</span><br><span class="line">      square.draw();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看现在客户端怎么调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  ShapeMaker shapeMaker = <span class="keyword">new</span> ShapeMaker();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 客户端调用现在更加清晰了</span></span><br><span class="line">  shapeMaker.drawCircle();</span><br><span class="line">  shapeMaker.drawRectangle();</span><br><span class="line">  shapeMaker.drawSquare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。</p><h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。</p><p>直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> String name;</span><br><span class="line">   <span class="keyword">private</span> String dept;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> salary;</span><br><span class="line">   <span class="keyword">private</span> List&lt;Employee&gt; subordinates; <span class="comment">// 下属</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name,String dept, <span class="keyword">int</span> sal)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.dept = dept;</span><br><span class="line">      <span class="keyword">this</span>.salary = sal;</span><br><span class="line">      subordinates = <span class="keyword">new</span> ArrayList&lt;Employee&gt;();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.add(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Employee e)</span> </span>&#123;</span><br><span class="line">      subordinates.remove(e);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getSubordinates</span><span class="params">()</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span> subordinates;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (<span class="string">"Employee :[ Name : "</span> + name + <span class="string">", dept : "</span> + dept + <span class="string">", salary :"</span> + salary+<span class="string">" ]"</span>);</span><br><span class="line">   &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。</p><p>这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。</p><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。</p><p>复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。</p><p>这种简单的代码我就不演示了。</p><h3 id="结构型模式总结"><a href="#结构型模式总结" class="headerlink" title="结构型模式总结"></a>结构型模式总结</h3><p>前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？</p><p>代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。</p><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2><p>行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。</p><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。</p><p>下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。</p><p>首先，先定义一个策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们定义具体的几个策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用红色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用绿色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"用蓝色笔画图，radius:"</span> + radius + <span class="string">", x:"</span> + x + <span class="string">", y:"</span> + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用策略的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeDraw</span><span class="params">(<span class="keyword">int</span> radius, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> strategy.draw(radius, x, y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> BluePen()); <span class="comment">// 使用绿色笔来画</span></span><br><span class="line">  context.executeDraw(<span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>放到一张图上，让大家看得清晰些：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/strategy-1.png" alt="策略模式类图示例" title="">                </div>                <div class="image-caption">策略模式类图示例</div>            </figure><p>这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/design-pattern/bridge-1.png" alt="bridge-1" title="">                </div>                <div class="image-caption">bridge-1</div>            </figure><p>要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。</p><p>首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="comment">// 数据已变更，通知观察者们</span></span><br><span class="line">        notifyAllObservers();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注册观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知观察者们</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义观察者接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Subject subject;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。</p><p>我们来定义具体的几个观察者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在构造方法中进行订阅主题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BinaryObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="comment">// 通常在构造方法中将 this 发布出去的操作一定要小心</span></span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 该方法由主题类在数据变更的时候进行调用</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toBinaryString(subject.getState());</span><br><span class="line">        System.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为二进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HexaObserver</span> <span class="keyword">extends</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HexaObserver</span><span class="params">(Subject subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">        <span class="keyword">this</span>.subject.attach(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = Integer.toHexString(subject.getState()).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">"订阅的数据发生变化，新的数据处理为十六进制值为："</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端使用也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先定义一个主题</span></span><br><span class="line">    Subject subject1 = <span class="keyword">new</span> Subject();</span><br><span class="line">    <span class="comment">// 定义观察者</span></span><br><span class="line">    <span class="keyword">new</span> BinaryObserver(subject1);</span><br><span class="line">    <span class="keyword">new</span> HexaObserver(subject1);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟数据变更，这个时候，观察者们的 update 方法将会被调用</span></span><br><span class="line">    subject.setState(<span class="number">11</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">订阅的数据发生变化，新的数据处理为二进制值为：1011</span><br><span class="line">订阅的数据发生变化，新的数据处理为十六进制值为：B</span><br></pre></td></tr></table></figure><p>当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。</p><p>实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。</p><p>还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。</p><p>有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。</p><blockquote><p>如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？</p></blockquote><p>首先，我们要定义流程上节点的基类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 后继节点</span></span><br><span class="line">    <span class="keyword">protected</span> RuleHandler successor;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span></span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(RuleHandler successor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleHandler <span class="title">getSuccessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> successor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要定义具体的每个节点了。</p><p>校验用户是否是新用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewUserRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (context.isNewUser()) &#123;</span><br><span class="line">            <span class="comment">// 如果有后继节点的话，传递下去</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"该活动仅限新用户参与"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验用户所在地区是否可以参与：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocationRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> allowed = activityService.isSupportedLocation(context.getLocation);</span><br><span class="line">        <span class="keyword">if</span> (allowed) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"非常抱歉，您所在的地区无法参与本次活动"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>校验奖品是否已领完：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitRuleHandler</span> <span class="keyword">extends</span> <span class="title">RuleHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> remainedTimes = activityService.queryRemainedTimes(context); <span class="comment">// 查询剩余奖品</span></span><br><span class="line">        <span class="keyword">if</span> (remainedTimes &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.getSuccessor() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.getSuccessor().apply(userInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"您来得太晚了，奖品被领完了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    RuleHandler newUserHandler = <span class="keyword">new</span> NewUserRuleHandler();</span><br><span class="line">    RuleHandler locationHandler = <span class="keyword">new</span> LocationRuleHandler();</span><br><span class="line">    RuleHandler limitHandler = <span class="keyword">new</span> LimitRuleHandler();</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 假设本次活动仅校验地区和奖品数量，不校验新老用户</span></span><br><span class="line">    locationHandler.setSuccessor(limitHandler);</span><br><span class="line">  </span><br><span class="line">    locationHandler.apply(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。</p><p>至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。</p><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>在含有继承结构的代码中，模板方法模式是非常常用的。</p><p>通常会有一个抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这就是模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">        apply(); <span class="comment">// 这个是重点</span></span><br><span class="line">        end(); <span class="comment">// 可以作为钩子方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"init 抽象层已经实现，子类也可以选择覆写"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 留给子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。</p><p>我们写一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplate</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类实现抽象方法 apply"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">end</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端调用演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    AbstractTemplate t = <span class="keyword">new</span> ConcreteTemplate();</span><br><span class="line">    <span class="comment">// 调用模板方法</span></span><br><span class="line">    t.templateMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。</p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>update: 2017-10-19</p><p>废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。</p><p>核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。</p><p>定义状态接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义减库存的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeductState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"商品卖出，准备减库存"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行减库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Deduct State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义补库存状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RevertState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"给此商品补库存"</span>);</span><br><span class="line">        context.setState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 执行加库存的具体操作</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Revert State"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> State state;</span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(State state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下客户端调用，大家就一清二楚了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 我们需要操作的是 iPhone X</span></span><br><span class="line">    Context context = <span class="keyword">new</span> Context(<span class="string">"iPhone X"</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 看看怎么进行补库存操作</span></span><br><span class="line">  State revertState = <span class="keyword">new</span> RevertState();</span><br><span class="line">  revertState.doAction(context);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 同样的，减库存操作也非常简单</span></span><br><span class="line">  State deductState = <span class="keyword">new</span> DeductState();</span><br><span class="line">  deductState.doAction(context);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果需要我们可以获取当前的状态</span></span><br><span class="line">    <span class="comment">// context.getState().toString();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。</p><p>不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。</p><h3 id="行为型模式总结"><a href="#行为型模式总结" class="headerlink" title="行为型模式总结"></a>行为型模式总结</h3><p>行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。</p><p>（全文完）</p><p>大佬的博客看过了,整篇还是比较清晰简洁的,我自己还看过设计模式之禅这本书,总结起来设计模式对于我们抽象代码结构,处理复杂或模式重复的编码工作时很有用,当你发现自己总是在重复拓展已有代码,总是在重构或者业务复杂时,不妨试试设计模式的应用,当然,需要特别注意的是设计模式不可为了应用而应用,过度设计造成后人维护代码,理解代码成本太高也是得不偿失的,改天有空我再将自己看设计模式之禅的读书笔记总结下吧,好在我读书喜欢勾勾画画,笔记整理起来应该是快的,就是比较懒 !:sweat_smile::sweat_smile::sweat_smile:   </p><p><strong><em>郑重声明</em></strong>  :  <strong>本文转载自我关注的一位大佬的博客,<a href="https://www.javadoop.com/post/design-pattern" target="_blank" rel="noopener">原文链接</a> 如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.</strong></p><p><strong>可在<a href="https://www.enjoyican.com/posts/design-pattern/">blog-design-pattern</a> 或CSDN留言</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明&lt;/em&gt;&lt;/strong&gt;  :  &lt;strong&gt;本文转载自我关注的一位大佬的博客,&lt;a href=&quot;https://www.javadoop.com/post/design-pattern&quot; target=&quot;_blank&quot; rel=&quot;n
      
    
    </summary>
    
    
      <category term="design pattern" scheme="https://www.enjoyican.com/categories/design-pattern/"/>
    
    
      <category term="design-pattern" scheme="https://www.enjoyican.com/tags/design-pattern/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现读书笔记-多机数据库的实现</title>
    <link href="https://www.enjoyican.com/posts/redis-three/"/>
    <id>https://www.enjoyican.com/posts/redis-three/</id>
    <published>2020-03-19T14:21:30.000Z</published>
    <updated>2020-03-19T14:21:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过前两篇读书笔记的整理对redis设计与实现这本书梳理了下,当然我的梳理稍显粗糙,因为很多内容在书上介绍的比较清楚,而这本书就在我手头上,我在笔记中就不再赘述,有资源的最好读原书,看一本好书的时候最直观的感受就是这本书看的很顺畅,津津有味,对很多之前的疑惑有解谜的作用,而不是逼着自己今天看几页,明天看几页,而这本书就是让我感觉比较舒服的一本,接下来这篇重点介绍redis的主从复制,哨兵模式和集群,这里也是很多面试爱问的点.</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>这里的复制,指的就是我们都懂的主从复制.书中讲述了redis2.8版本之前的复制原理和2.8之后的复制原理,接下来描述中旧版指的就是2.8版本之前的,新版指的就是2.8版本之后的.</p><h4 id="旧版复制功能的实现"><a href="#旧版复制功能的实现" class="headerlink" title="旧版复制功能的实现"></a>旧版复制功能的实现</h4><p>Redis的复制功能分为同步(sync)和命令传播(command propagate)两个操作:</p><ul><li>同步操作将从服务器的数据库状态更新至主服务器当前所处的数据库状态</li><li>命令传播操作用于当主服务器数据库状态被修改,导致主从不一致时,使主从数据库重新回到一致状态</li></ul><h5 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h5><p>当客户端向从服务器发送<code>SLAVEOF</code>命令要求从服务器复制主服务器的时候,从服务器首先执行的就是同步操作.</p><p>从服务器会向主服务器发送<code>SYNC</code>命令来完成同步,大致过程如下:</p><ul><li>从服务器向主服务器发送<code>SYNC</code>命令</li><li>主服务器收到命令后执行<code>BGSAVE</code>命令,在后台生成RDB文件,并使用一个缓冲区来记录从现在开始执行的所有写命令</li><li>当主服务器执行完<code>BGSAVE</code>命令之后,主服务器会将生成的RDB文件发送给从服务器,从服务接受并载入文件,使自己数据库状态更新至主服务器执行<code>BGSAVE</code>命令时的数据库状态</li><li>主服务器将记录在缓冲区里面的所有写命令发送给从服务器,从服务器收到后执行,使自己数据库状态更新至主服务器当前的数据库状态</li></ul><h5 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h5><p>当同步之后,主从服务器处于一致状态,但是当主服务器执行新的写命令之后,两者又不一致了,这时候主服务器会将刚才执行的写命令发送给从服务器让其执行,以使两者重新一致,这个过程就是命令传播</p><h4 id="旧版复制功能缺陷"><a href="#旧版复制功能缺陷" class="headerlink" title="旧版复制功能缺陷"></a>旧版复制功能缺陷</h4><p>旧版复制分为以下两种情况:</p><p><strong>初次复制</strong>:    从服务器之前没有复制过现在要复制的这台主服务器</p><p><strong>断线后重复制</strong>:    处于命令传播阶段的主从服务器因为网络原因中断复制,之后从服务器通过自动重连重新接上了主服务器,并继续复制主服务器</p><p><strong>缺陷之处</strong>:    对于初次复制,旧版复制有很好的支持,问题就在于断线后复制,在断线后复制的时候,理想的状态是将断线前从服务器目前复制到的位置之后所有的内容进行复制,但是旧版的断线复制,却是重新执行了所有的复制操作,依然是从服务器向主服务器发送<code>SYNC</code>指令,之后主服务器在后台生成对应的RDB文件……,将之前的老路重新走了一遍,这其实非常消耗性能</p><h4 id="新版复制功能的实现"><a href="#新版复制功能的实现" class="headerlink" title="新版复制功能的实现"></a>新版复制功能的实现</h4><p>为了解决旧版断线重连后复制的低效问题,新版采用了<code>PSYNC</code>命令代替<code>SYNC</code>命令来执行复制时的同步操作.</p><p><code>PSYNC</code>有<strong>完整重同步</strong>和<strong>部分重同步</strong>两种模式:</p><ul><li>完整从同步与初次复制的步骤类似</li><li>部分重同步就是主服务器只将主从服务器断开这段时间执行的指令发给从服务器执行</li></ul><p>可以看到部分重同步的开销比之前旧版的小了很多,实现部分重同步的三个部分如下:</p><ul><li>主服务器的复制偏移量(replication offset)和从服务器的复制偏移量</li><li>主服务器的复制积压缓冲区(replication backlog)</li><li>服务器的运行ID(run ID)</li></ul><h5 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h5><p>主服务器和从服务器在执行复制的过程中会分别维护一个复制偏移量:</p><p>主服务器每次向从服务器传播N个字节时,会在自己的复制偏移量上加N;而从服务器每次收到从主服务器传播来的N个字节的数据时,也会在自己的复制偏移量上加N</p><p>通过对主从复制偏移量的对比,可以判断主从服务器是否处于一致状态:如果复制偏移量相同,说明处于一致状态,否则不一致.</p><p>假设断线重连后,从服务器向主服务器发送<code>PSYNC</code>命令,同时汇报自己的复制偏移量,那么主服务器如何判断是该对从服务器进行全部重同步还是部分重同步,如果是部分重同步,又如何判断要传递的数据是哪些呢,这些都和复制积压缓冲区有关</p><h5 id="复制积压缓冲区"><a href="#复制积压缓冲区" class="headerlink" title="复制积压缓冲区"></a>复制积压缓冲区</h5><p>复制积压缓冲区是由主服务器维护的一个固定长度(fixed-size)先进先出(FIFO)队列,默认大小为1MB</p><p>当主服务器向从服务器进行命令传播时,它会同时将命令放入复制积压缓冲区,如下图所示</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-three/1.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>复制积压缓冲区会为队列中的每个字节记录相应的复制偏移量,如下表:</p><table><thead><tr><th>偏移量</th><th>10087</th><th>10088</th><th>10089</th><th>10090</th><th>10091</th><th>10092</th><th>10093</th><th>10095</th><th>10096</th><th>10096</th></tr></thead><tbody><tr><td>字节值</td><td>‘*’</td><td>3</td><td>‘\r’</td><td>‘\n’</td><td>‘$’</td><td>3</td><td>…</td><td>‘S’</td><td>‘E’</td><td>‘T’</td></tr></tbody></table><p>当主从断线重连之后,从服务器向主服务器发送<code>PSYNC</code>命令同时汇报自己的复制偏移量offset之后,主服务器会拿着这个复制偏移量去复制积压缓冲区中查看,如果从该offset开始往后的数据仍然存在,就执行部分重同步,如果已经不存在了,就执行完整重同步操作.</p><p>复制积压加缓冲区的大小可以在配置文件中配置:<code>repl-backlog-size</code></p><h5 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h5><p>除了复制偏移量和复制积压缓冲区之外,实现部分重同步还需要用到服务器运行ID</p><ul><li>每个redis服务器,不论主从都有自己的运行ID</li><li>运行ID在服务器启动时自动生成,由40个随机的16进制字符组成,如:53b9b28df….</li></ul><p>当从服务器对主服务器进行初次复制的时候,主服务器会将自己的运行ID传送给从服务器,从服务器会将这个运行ID保存起来,当断线重连后,从服务器会向主服务器发送这个运行ID,如果与当前主服务器的运行ID相同,则可以由主服务器根据情况判断是否可以执行部分重同步,如果这个ID和当前主服务器的ID不同,那么直接执行完整重同步.</p><h4 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h4><p><code>PSYNC</code>命令的调用方法有两种情况:</p><ul><li>如果从服务器之前没有复制过任何主服务器,或者之前执行过<code>SLAVEOF NO ONE</code>命令,那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC ? -1</code>命令,主动请求主服务器进行完整重同步</li><li>如果从服务器已经复制过某个主服务器,那么重连后从服务器将向主服务器发送<code>PSYNC runid offset</code>命令,runid是上次复制的主服务器运行id,offset是从服务器的复制偏移量,之后主服务器会根据收到的信息判定是进行部分重同步还是完整重同步</li></ul><p>关于复制过程的整体实现过程,可以看原书15.6节-复制的实现</p><h3 id="Sentinel哨兵模式"><a href="#Sentinel哨兵模式" class="headerlink" title="Sentinel哨兵模式"></a>Sentinel哨兵模式</h3><p>哨兵模式是redis为保证高可用所提供的解决方案,由一个或多个哨兵组成的哨兵系统,监控系统中任意多个主服务器以及这些主服务器下的所有从服务器,当发生故障的时候,比如主服务器挂了,哨兵可以通过选举机制产生新的主服务器并进行故障转移,从而保证可用性</p><h4 id="启动并初始化sentinel"><a href="#启动并初始化sentinel" class="headerlink" title="启动并初始化sentinel"></a>启动并初始化sentinel</h4><p>启动一个sentinel可以使用命令:</p><p><code>redis-sentinel  /path/to/your/sentinel.conf</code>或者命令<code>redis-server /path/to/your/sentinel.conf --sentinel</code></p><p>当一个sentinel启动时,需要执行以下步骤:</p><ol><li>初始化服务器</li><li>将普通redis服务器使用的代码替换成sentinel专用代码</li><li>初始化sentinel状态</li><li>根据指定的配置文件,初始化sentinel监视的主服务器列表</li><li>创建连向主服务器的网络连接</li></ol><h5 id="初始化服务器"><a href="#初始化服务器" class="headerlink" title="初始化服务器"></a>初始化服务器</h5><p>sentinel本质上只是一个运行在特殊模式下的redis服务器,因为sentinel并不使用数据库,所以初始化sentinel的时候就不会载入RDB文件或者AOF文件</p><h5 id="使用sentinel专用代码"><a href="#使用sentinel专用代码" class="headerlink" title="使用sentinel专用代码"></a>使用sentinel专用代码</h5><p>该步骤中将一部分普通redis使用的代码替换成sentinel专用代码,特别指出<code>PING SENTINEL INFO SUBSCRIBE UNSUBSCRIBE PSUBSCRIBE 和 PUNSUBSCRIBE</code>这七个命令是客户端可以对sentinel执行的全部命令</p><h5 id="初始化sentinel状态"><a href="#初始化sentinel状态" class="headerlink" title="初始化sentinel状态"></a>初始化sentinel状态</h5><p>在应用了sentinel专用代码之后,服务器会初始化一个sentinel.c/sentinelState结构(sentinel状态),这个结构保存了服务器所有与sentinel功能有关的状态(服务器的一般状态仍然由redis.h/redisServer结构保存):</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">snetinelState</span>&#123;</span></span><br><span class="line">    <span class="comment">//当前纪元,用于实现故障转移(选举机制会用到)</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch;</span><br><span class="line">    <span class="comment">//保存了所有被这个sentinel监视的主服务器</span></span><br><span class="line">    <span class="comment">//字典的键是主服务器的名字,值是一个指向sentinelRedisInstance结构的指针</span></span><br><span class="line">    dict *masters;</span><br><span class="line">    <span class="comment">//是否进入了TILT模式;</span></span><br><span class="line">    <span class="keyword">int</span> tilt;</span><br><span class="line">    <span class="comment">//目前正在执行的脚本的数量</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;</span><br><span class="line">    <span class="comment">//进入TITL模式的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> titl_start_time;</span><br><span class="line">    <span class="comment">//最后一次执行时间处理器的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;</span><br><span class="line">    <span class="comment">//一个FIFO队列,包含了所有需要执行的用户脚本</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;   </span><br><span class="line">&#125;sentinel</span><br></pre></td></tr></table></figure><h5 id="初始化sentinel状态的masters属性"><a href="#初始化sentinel状态的masters属性" class="headerlink" title="初始化sentinel状态的masters属性"></a>初始化sentinel状态的masters属性</h5><p>每个sentinelRedisInstance(实例结构)结构代表一个被sentinel监视的redis服务器实例,这个实例可以是主服务器,从服务器或者另外一个sentinel.实例结构包含的属性较多,下面代码展示了作为主服务器使用时用到的一部分属性:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span>&#123;</span></span><br><span class="line">    <span class="comment">//标识值,记录了实例的类型以及该实例的当前状态</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="comment">//实例的名字,主服务的名字由用户在配置文件中配置,从服务器以及sentinel的名字由sentinel自动设置</span></span><br><span class="line">    <span class="comment">//格式为ip:port,比如"127.0.0.1:26379"</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">//实例的运行id</span></span><br><span class="line">    <span class="keyword">char</span> *runid;</span><br><span class="line">    <span class="comment">//配置纪元,用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;</span><br><span class="line">    <span class="comment">//实例的地址</span></span><br><span class="line">    sentinelAddr *addr;</span><br><span class="line">    <span class="comment">//SENTINEL down-after-milliseconds选项设定的值</span></span><br><span class="line">    <span class="comment">//实例无响应多少毫秒之后才会被判断为主观下线(subjectively down)</span></span><br><span class="line">    <span class="keyword">mstime_t</span> down_after_period;</span><br><span class="line">    <span class="comment">//SENTINEL monitor &lt;master-name&gt;  &lt;IP&gt; &lt;port&gt; &lt;quorum&gt;选项中的quorum参数</span></span><br><span class="line">    <span class="comment">//判断这个实例为客观下线(objectively down)所需的支持投票数量</span></span><br><span class="line">    <span class="keyword">int</span> quorum;</span><br><span class="line">    <span class="comment">//SENTINEL parallel-syncs &lt;master-name&gt; &lt;number&gt;选项的值</span></span><br><span class="line">    <span class="comment">//在执行故障转移时,可以同时对新的主服务器执行同步的从服务器数量</span></span><br><span class="line">    <span class="keyword">int</span> parallel_syncs;</span><br><span class="line">    <span class="comment">//SENTINEL failover-timeout&lt;master-name&gt; &lt;ms&gt; 选项的值</span></span><br><span class="line">    <span class="comment">//刷新故障迁移状态的最大时限</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_timeout;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;sentinelRedisInstance</span><br></pre></td></tr></table></figure><p>sentinelRedisInstance.addr属性是一个指向sentinel.c/sentinelAddr结构的指针,这个结构保存着实例的IP地址和端口号:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelAddr</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> *ip;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">&#125;sentinelAddr</span><br></pre></td></tr></table></figure><p>对sentinel状态的初始化将引发对master字典的初始化,masters字典的初始化时根据被载入的sentinel配置文件来进行的.</p><h5 id="创建连向主服务器的网络连接"><a href="#创建连向主服务器的网络连接" class="headerlink" title="创建连向主服务器的网络连接"></a>创建连向主服务器的网络连接</h5><p>初始化sentinel的最后一步是创建连向被监视主服务器的网络连接,sentinel将成为主服务器的客户端,它可以向主服务器发送命令,并从命令回复中获取相关信息.</p><p>对于每个被sentinel监视的主服务器来说,sentinel会创建两个连向主服务器的异步网络连接:</p><ul><li>一个是命令连接,这个连接专门用于向主服务器发送命令,并接受命令回复</li><li>另一个是订阅连接,这个连接专门用于订阅主服务器的_sentinel_:hello频道</li></ul><h4 id="获取主服务器信息"><a href="#获取主服务器信息" class="headerlink" title="获取主服务器信息"></a>获取主服务器信息</h4><p>sentinel会默认以每十秒一次的频率,通过命令连接向被监视的主服务器发送<code>INFO</code>命令,并通过分析命令回复来获取主服务器当前的信息,包括:</p><ul><li>主服务器本身的信息:runid,role(服务器角色)</li><li>主服务器下所有从服务器信息,sentinel无须用户提供从服务器的地址,可以自动根据主服务器的回复获取</li></ul><h4 id="获取从服务器信息"><a href="#获取从服务器信息" class="headerlink" title="获取从服务器信息"></a>获取从服务器信息</h4><p>同样的,sentinel会默认以每十秒一次的频率,通过命令连接向从服务器发送<code>INFO</code>命令,并通过分析命令回复来获取从服务器当前的信息,包括:</p><ul><li><p>从服务器的运行ID run_id</p></li><li><p>从服务器的角色role</p></li><li><p>主服务器的ip地址master_host,以及主服务区的端口号master_port</p></li><li><p>主从服务器的连接状态master_link_status</p></li><li><p>从服务器的优先级slave_priority</p></li><li><p>从服务器的复制偏移量slave_repl_offeset(<strong>这个在主服务器挂了,重新选主的时候有用)</strong></p><h4 id="向主服务器和从服务器发送信息"><a href="#向主服务器和从服务器发送信息" class="headerlink" title="向主服务器和从服务器发送信息"></a>向主服务器和从服务器发送信息</h4></li></ul><p>默认情况下,sentinel会以每两秒一次的频率,通过命令连接向所有被监视的主服务器和从服务器发送以下格式的命令:</p><p>PUBLISH   _sentinel_:hello  “&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;&quot;</p><p>该命令向服务器的_sentinel_:hello频道发送了一条信息,参数中以s_开头的是 sentinel本身的信息,m_开头的记录的是主服务器的信息,如果此时监控的是主服务器,就是主服务器自己的信息,如果监控的是从服务器,也是从服务器对应主服务器的信息</p><h4 id="接收来自主服务器和从服务器的频道信息"><a href="#接收来自主服务器和从服务器的频道信息" class="headerlink" title="接收来自主服务器和从服务器的频道信息"></a>接收来自主服务器和从服务器的频道信息</h4><p>当sentinel与一个主服务器或者从服务器建立起连接之后,sentinel就会通过订阅连接,向服务器发送以下命令:</p><p>SUBSCRIBE _sentinel_:hello</p><p>sentinel对 _sentinel_:hello频道的订阅会一直持续到sentinel与服务器断开为止,也就是说对于每个与sentinel连接的服务器,sentinel既通过命令连接向服务器的_sentinel_:hello 频道发送信息,又通过订阅连接从服务器的该频道接收信息.</p><p><strong>用户在使用sentinel的时候不需要提供各个sentinel的地址信息,监视同一个主服务器的多个sentinel可以自动发现对方.</strong>     </p><p><strong>sentinel在连接主服务器或者从服务器的时候会同时创建命令连接和订阅连接,但是在连接其他sentinel的时候只会创建命令连接而不创建订阅连接.</strong>   </p><h4 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h4><p> 所谓主观下线（Subjectively Down， 简称 SDOWN）指的是单个Sentinel实例对服务器做出的下线判断，即单个sentinel认为某个服务下线（有可能是接收不到订阅，之间的网络不通等等原因）。</p><p>主观下线就是说如果服务器在<code>down-after-milliseconds</code>给定的毫秒数之内， 没有返回 Sentinel 发送的 <code>PING</code> 命令的回复， 或者返回一个错误， 那么 Sentinel 将这个服务器标记为主观下线（SDOWN ）。</p><p>sentinel会以每秒一次的频率向所有与其建立了命令连接的实例（<strong>master，从服务，其他sentinel</strong>）发ping命令，通过判断ping回复是有效回复，还是无效回复来判断实例时候在线（对该sentinel来说是“主观在线”）。<br>sentinel配置文件中的<code>down-after-milliseconds</code>设置了判断主观下线的时间长度，如果实例在down-after-milliseconds毫秒内，返回的都是无效回复，那么sentinel回认为该实例已<strong>（主观）下线</strong>，<strong>修改其flags状态为</strong><code>SRI_S_DOWN</code>。如果多个sentinel监视一个服务，有可能存在多个sentinel的down-after-milliseconds配置不同，这个在实际生产中要注意。 </p><h4 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h4><p>客观下线（Objectively Down， 简称 ODOWN）指的是多个 Sentinel 实例在对同一个服务器做出 SDOWN 判断， 并且通过 SENTINEL is-master-down-by-addr 命令互相交流之后， 得出的服务器下线判断，然后开启failover。</p><p>客观下线就是说只有在足够数量的 Sentinel 都将一个服务器标记为主观下线之后， 服务器才会被标记为客观下线（ODOWN）。</p><p>只有当master被认定为客观下线时，才会发生故障迁移。</p><p>当sentinel监视的某个服务主观下线后，sentinel会询问其它监视该服务的sentinel，看它们是否也认为该服务主观下线，接收到足够数量（这个值可以配置）的sentinel判断为主观下线，既认为该服务客观下线，并对其做故障转移操作。</p><p>sentinel通过发送 <code>SENTINEL is-master-down-by-addr ip port current_epoch runid</code>，（<code>ip</code>：主观下线的服务ip，<code>port</code>：主观下线的服务端口，<code>current_epoch</code>：sentinel的纪元，<code>runid</code>：*表示检测服务下线状态，如果是sentinel 运行id，表示用来选举领头sentinel）来询问其它sentinel是否同意服务下线。</p><p>一个sentinel接收另一个sentinel发来的<code>is-master-down-by-addr</code>后，提取参数，根据ip和端口，检测该服务是否在该sentinel主观下线，并且回复<code>is-master-down-by-addr</code>，回复包含三个参数：<code>down_state</code>（1表示已下线，0表示未下线），<code>leader_runid</code>（领头sentinal id），<code>leader_epoch</code>（领头sentinel纪元）。</p><p>sentinel接收到回复后，根据配置设置的下线最小数量，达到这个值，既认为该服务客观下线。</p><p><strong>客观下线条件只适用于主服务器</strong>： 对于任何其他类型的 Redis 实例， Sentinel 在将它们判断为下线前不需要进行协商， 所以从服务器或者其他 Sentinel 永远不会达到客观下线条件。只要一个 Sentinel 发现某个主服务器进入了客观下线状态， 这个 Sentinel 就可能会被其他 Sentinel 推选出， 并对失效的主服务器执行自动故障迁移操作。</p><p>在redis-sentinel的conf文件里有这么两个配置：<br><strong>1）sentinel monitor  &lt;masterName&gt;  &lt;ip&gt;   &lt;port&gt;   &lt;quorum&gt;</strong></p><p>四个参数含义：<br><code>masterName</code>这个是对某个master+slave组合的一个区分标识（一套sentinel是可以监听多套master+slave这样的组合的）。<br>ip 和 port 就是master节点的 ip 和 端口号。<br><code>quorum</code>这个参数是进行<strong>客观下线的一个依据</strong>，意思是至少有 quorum 个sentinel主观的认为这个master有故障，才会对这个master进行下线以及故障转移。因为有的时候，某个sentinel节点可能因为自身网络原因，导致无法连接master，而此时master并没有出现故障，所以这就需要多个sentinel都一致认为该master有问题，才可以进行下一步操作，这就保证了公平性和高可用。</p><p><strong>2）sentinel down-after-milliseconds  ** &lt; **masterName</strong> &gt;   &lt;<strong>timeout</strong>&gt;<br>这个配置其实就是进行<strong>主观下线的一个依据</strong>，masterName这个参数不用说了，timeout是一个毫秒值，表示：如果这台sentinel超过timeout这个时间都无法连通master包括slave（slave不需要客观下线，因为不需要故障转移）的话，就会主观认为该master已经下线（实际下线需要客观下线的判断通过才会下线）</p><p>那么，多个sentinel之间是如何达到共识的呢？<br>某个sentinel先将master节点进行主观下线，然后会将这个判定通过<code>sentinel is-master-down-by-addr</code>这个命令问对应的节点是否也同样认为该addr的master节点要做客观下线。最后当达成这一共识的sentinel个数达到前面说的<code>quorum</code>设置的这个值时，就会对该master节点下线进行故障转移。<strong>quorum的值一般设置为sentinel个数的二分之一加1，例如3个sentinel就设置2。</strong></p><h4 id="选举领头sentinel"><a href="#选举领头sentinel" class="headerlink" title="选举领头sentinel"></a>选举领头sentinel</h4><p> 一个redis服务被判断为客观下线时，多个监视该服务的sentinel协商，选举一个领头sentinel，对该redis服务进行故障转移操作。<strong>选举领头sentinel遵循以下规则：</strong></p><p>1）所有的sentinel都有公平被选举成领头的资格。<br>2）所有的sentinel都有且只有一次将某个sentinel选举成领头的机会（在一轮选举中），一旦选举某个sentinel为领头，不能更改。<br>3）sentinel设置领头sentinel是先到先得，一旦当前sentinel设置了领头sentinel，以后要求设置其他sentinel为领头请求都会被拒绝。<br>4）每个发现服务客观下线的sentinel，都会要求其他sentinel将自己设置成领头。<br>5）当一个sentinel（源sentinel）向另一个sentinel（目标sentinel）发送<code>is-master-down-by-addr ip port current_epoch runid</code>命令的时候，runid参数不是*，而是sentinel运行id，就表示源sentinel要求目标sentinel选举其为领头。<br>6）源sentinel会检查目标sentinel对其要求设置成领头的回复，如果回复的leader_runid和leader_epoch为源sentinel，表示目标sentinel同意将源sentinel设置成领头。<br>7）如果某个sentinel被半数以上的sentinel设置成领头，那么该sentinel既为领头。<br>8）如果在限定时间内，没有选举出领头sentinel，暂定一段时间，再选举。 </p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>所谓故障转移就是当master宕机，选一个合适的slave来晋升为master的操作，redis-sentinel会自动完成这个，不需要我们手动来实现。</p><p><strong>一次故障转移操作大致分为以下流程：</strong><br>发现主服务器已经进入客观下线状态。<br>对我们的当前集群进行自增， 并尝试在这个集群中当选。<br>如果当选失败， 那么在设定的故障迁移超时时间的两倍之后， 重新尝试当选。 如果当选成功， 那么执行以下步骤：</p><p><strong>选出一个从服务器，并将它升级为主服务器</strong>。<br><strong>向被选中的从服务器发送 SLAVEOF NO ONE 命令，让它转变为主服务器。</strong><br>通过发布与订阅功能， 将更新后的配置传播给所有其他 Sentinel ， 其他 Sentinel 对它们自己的配置进行更新。<br>向已下线主服务器的从服务器发送 SLAVEOF 命令， 让它们去复制新的主服务器。<br>当所有从服务器都已经开始复制新的主服务器时， 领头 Sentinel 终止这次故障迁移操作。<br>每当一个 Redis 实例被重新配置（reconfigured） —— 无论是被设置成主服务器、从服务器、又或者被设置成其他主服务器的从服务器 —— Sentinel 都会向被重新配置的实例发送一个 CONFIG REWRITE 命令， 从而确保这些配置会持久化在硬盘里。</p><p><strong>Sentinel 使用以下规则来选择新的主服务器：</strong></p><ul><li>在失效主服务器属下的从服务器当中， 那些被标记为主观下线、已断线、或者最后一次回复 PING 命令的时间大于五秒钟的从服务器都会被淘汰。</li><li>在失效主服务器属下的从服务器当中， 那些与失效主服务器连接断开的时长超过 down-after 选项指定的时长十倍的从服务器都会被淘汰。</li><li>在经历了以上两轮淘汰之后剩下来的从服务器中， 我们选出<strong>复制偏移量（replication offset）最大</strong>的那个从服务器作为新的主服务器； 如果复制偏移量不可用， 或者从服务器的复制偏移量相同， 那么<strong>带有最小运行 ID 的那个从服务器</strong>成为新的主服务器。</li></ul><p><strong>Sentinel 自动故障迁移的一致性特质</strong></p><p>Sentinel 自动故障迁移使用 Raft 算法来选举领头（leader） Sentinel ， 从而确保在一个给定的纪元（epoch）里， 只有一个领头产生。</p><p>这表示在同一个纪元中， 不会有两个 Sentinel 同时被选中为领头， 并且各个 Sentinel 在同一个纪元中只会对一个领头进行投票。</p><p>更高的配置纪元总是优于较低的纪元， 因此每个 Sentinel 都会主动使用更新的纪元来代替自己的配置。</p><p>简单来说， 可以将 Sentinel 配置看作是一个带有版本号的状态。 一个状态会以最后写入者胜出（last-write-wins）的方式（也即是，最新的配置总是胜出）传播至所有其他 Sentinel 。</p><p>举个例子， 当出现网络分割（network partitions）时， 一个 Sentinel 可能会包含了较旧的配置， 而当这个 Sentinel 接到其他 Sentinel 发来的版本更新的配置时， Sentinel 就会对自己的配置进行更新。</p><p>如果要在网络分割出现的情况下仍然保持一致性， 那么应该使用 min-slaves-to-write 选项， 让主服务器在连接的从实例少于给定数量时停止执行写操作， 与此同时， 应该在每个运行 Redis 主服务器或从服务器的机器上运行 Redis Sentinel 进程。</p><p><strong>Sentinel 状态的持久化</strong></p><p>Sentinel 的状态会被持久化在 Sentinel 配置文件里面。每当 Sentinel 接收到一个新的配置， 或者当领头 Sentinel 为主服务器创建一个新的配置时， 这个配置会与配置纪元一起被保存到磁盘里面。这意味着停止和重启 Sentinel 进程都是安全的。</p><p>Sentinel 在非故障迁移的情况下对实例进行重新配置<br>即使没有自动故障迁移操作在进行， Sentinel 总会尝试将当前的配置设置到被监视的实例上面。 特别是：</p><p>根据当前的配置， 如果一个从服务器被宣告为主服务器， 那么它会代替原有的主服务器， 成为新的主服务器， 并且成为原有主服务器的所有从服务器的复制对象。<br>那些连接了错误主服务器的从服务器会被重新配置， 使得这些从服务器会去复制正确的主服务器。</p><p>不过， 在以上这些条件满足之后， Sentinel 在对实例进行重新配置之前仍然会等待一段足够长的时间， 确保可以接收到其他 Sentinel 发来的配置更新， 从而避免自身因为保存了过期的配置而对实例进行了不必要的重新配置。</p><p><strong>总结来说，故障转移分为三个步骤：</strong></p><p><strong>1）从下线的主服务的所有从服务里面挑选一个从服务，将其转成主服务</strong><br>sentinel状态数据结构中保存了主服务的所有从服务信息，领头sentinel按照如下的规则从从服务列表中挑选出新的主服务；<br>删除列表中处于下线状态的从服务；<br>删除最近5秒没有回复过领头sentinel info信息的从服务；<br>删除与已下线的主服务断开连接时间超过 down-after-milliseconds*10毫秒的从服务，这样就能保留从的数据比较新（没有过早的与主断开连接）；<br>领头sentinel从剩下的从列表中选择优先级高的，如果优先级一样，选择偏移量最大的（偏移量大说明复制的数据比较新），如果偏移量一样，选择运行id最小的从服务。</p><p><strong>2）已下线主服务的所有从服务改为复制新的主服务</strong><br>挑选出新的主服务之后，领头sentinel 向原主服务的从服务发送 slaveof 新主服务 的命令，复制新master。</p><p><strong>3）将已下线的主服务设置成新的主服务的从服务，当其回复正常时，复制新的主服务，变成新的主服务的从服务</strong><br><strong>同理，当已下线的服务重新上线时，sentinel会向其发送slaveof命令，让其成为新主的从。</strong></p><p>温馨提示：<strong>还可以向任意sentinel发生sentinel failover  进行手动故障转移，这样就不需要经过上述主客观和选举的过程。</strong></p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p> Redis Cluster实现在多个节点之间进行数据共享，即使部分节点失效或者无法进行通讯时，Cluster仍然可以继续处理请求。若每个主节点都有一个从节点支持，在主节点下线或者无法与集群的大多数节点进行通讯的情况下， 从节点提升为主节点，并提供服务，保证Cluster正常运行，Redis Cluster的节点分片是通过哈希槽（hash slot）实现的，每个键都属于这 16384（0～16383） 个哈希槽的其中一个，每个节点负责处理一部分哈希槽。</p><h4 id="数据sharding"><a href="#数据sharding" class="headerlink" title="数据sharding"></a>数据sharding</h4><p>Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现： 一个 Redis 集群包含 16384 个哈希槽（hash slot）， 数据库中的每个键都属于这 16384 个哈希槽的其中一个， 集群使用公式 CRC16(key) % 16384 来计算键 key 属于哪个槽， 其中 CRC16(key) 语句用于计算键 key 的 CRC16 校验和 。集群中的每个节点负责处理一部分哈希槽。 举个例子， 一个集群可以有三个节点， 其中：</p><ul><li>节点 A 负责处理 0 号至 5500 号哈希槽。</li><li>节点 B 负责处理 5501 号至 11000 号哈希槽。</li><li>节点 C 负责处理 11001 号至 16384 号哈希槽。</li></ul><p>这种将哈希槽分布到不同节点的做法使得用户可以很容易地向集群中添加或者删除节点。 比如说：</p><ul><li>如果用户将新节点 D 添加到集群中， 那么集群只需要将节点 A 、B 、 C 中的某些槽移动到节点 D 就可以了。</li><li>如果用户要从集群中移除节点 A ， 那么集群只需要将节点 A 中的所有哈希槽移动到节点 B 和节点 C ， 然后再移除空白（不包含任何哈希槽）的节点 A 就可以了。</li></ul><p>因为将一个哈希槽从一个节点移动到另一个节点不会造成节点阻塞， 所以无论是添加新节点还是移除已存在节点， 又或者改变某个节点包含的哈希槽数量， 都不会造成集群下线 </p><h4 id="集群内部数据结构"><a href="#集群内部数据结构" class="headerlink" title="集群内部数据结构"></a>集群内部数据结构</h4><p>Redis Cluster功能涉及三个核心的数据结构clusterState、clusterNode、clusterLink都在cluster.h中定义。这三个数据结构中最重要的属性就是：clusterState.slots、clusterState.slots_to_keys和clusterNode.slots了，它们保存了三种映射关系：</p><ul><li>clusterState：集群状态</li><li>nodes：所有结点</li><li>migrating_slots_to：迁出中的槽</li><li>importing_slots_from：导入中的槽</li><li>slots_to_keys：槽中包含的所有Key，用于迁移Slot时获得其包含的Key</li><li>slots：Slot所属的结点，用于处理请求时判断Key所在Slot是否自己负责</li><li>clusterNode：结点信息</li><li>slots：结点负责的所有Slot，用于发送Gossip消息通知其他结点自己负责的Slot。通过位图方式保存节省空间，16384/8恰好是2048字节，所以槽总数16384不能随意定！</li><li>clusterLink：与其他结点通信的连接</li></ul><p>集群状态，每个节点都保存着一个这样的状态，记录了它们眼中的集群的样子。另外，虽然这个结构主要用于记录集群的属性，但是为了节约资源，有些与节点有关的属性，比如 slots_to_keys 、 failover_auth_count 也被放到了这个结构里面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;  <span class="comment">/* This node */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群当前的状态：是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;            <span class="comment">/* REDIS_CLUSTER_OK, REDIS_CLUSTER_FAIL, ... */</span></span><br><span class="line">    <span class="comment">//集群当前的配置纪元,用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//集群节点名单（包括 myself 节点）</span></span><br><span class="line">    <span class="comment">//字典的键为节点的名字，字典的值为 clusterNode 结构</span></span><br><span class="line">    dict *nodes;          <span class="comment">/* Hash table of name -&gt; clusterNode structures */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//记录要从当前节点迁移到目标节点的槽，以及迁移的目标节点</span></span><br><span class="line">    <span class="comment">//migrating_slots_to[i] = NULL 表示槽 i 未被迁移</span></span><br><span class="line">    <span class="comment">//migrating_slots_to[i] = clusterNode_A 表示槽 i 要从本节点迁移至节点 A</span></span><br><span class="line">    clusterNode *migrating_slots_to[REDIS_CLUSTER_SLOTS];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//记录要从源节点迁移到本节点的槽，以及进行迁移的源节点</span></span><br><span class="line">    <span class="comment">//importing_slots_from[i] = NULL 表示槽 i 未进行导入</span></span><br><span class="line">    <span class="comment">//importing_slots_from[i] = clusterNode_A 表示正从节点 A 中导入槽 i</span></span><br><span class="line">    clusterNode *importing_slots_from[REDIS_CLUSTER_SLOTS];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//负责处理各个槽的节点</span></span><br><span class="line">    <span class="comment">//例如 slots[i] = clusterNode_A 表示槽 i 由节点 A 处理</span></span><br><span class="line">    clusterNode *slots[REDIS_CLUSTER_SLOTS];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//跳跃表，表中以槽作为分值，键作为成员，对槽进行有序排序</span></span><br><span class="line">    <span class="comment">//当需要对某些槽进行区间（range）操作时，这个跳跃表可以提供方便</span></span><br><span class="line">    <span class="comment">//具体操作定义在 db.c 里面</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    ...</span><br><span class="line">&#125; clusterState;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//节点状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line">    <span class="comment">//从节点的名字,由40个十六进制字符组成</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line">    <span class="comment">//节点标识</span></span><br><span class="line">    <span class="comment">//使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">//以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* REDIS_NODE_... */</span></span><br><span class="line">    <span class="comment">//节点当前的配置纪元,用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line">    <span class="comment">//节点的ip地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN]</span><br><span class="line">    <span class="comment">//节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="comment">//由这个节点负责处理的槽</span></span><br><span class="line">    <span class="comment">//一共有 REDIS_CLUSTER_SLOTS / 8 个字节长</span></span><br><span class="line">    <span class="comment">//每个字节的每个位记录了一个槽的保存状态</span></span><br><span class="line">    <span class="comment">//位的值为 1 表示槽正由本节点处理，值为 0 则表示槽并非本节点处理</span></span><br><span class="line">    <span class="comment">//比如 slots[0] 的第一个位保存了槽 0 的保存情况</span></span><br><span class="line">    <span class="comment">//slots[0] 的第二个位保存了槽 1 的保存情况，以此类推</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[REDIS_CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* slots handled by this node */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//指针数组，指向各个从节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> <span class="comment">/* pointers to slave nodes */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">//如果这是一个从节点，那么指向主节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span> <span class="comment">/* pointer to the master node */</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//保存连接点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* clusterLink encapsulates everything needed to talk with a remote node. */</span></span><br><span class="line"><span class="comment">//clusterLink 包含了与其他节点进行通讯所需的全部信息</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;                     <span class="comment">/* TCP socket file descriptor */</span></span><br><span class="line">    <span class="comment">//输出缓冲区,保存着等待发送给其他节点的消息(message)</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line">    <span class="comment">//输入缓冲区,保存着从其他节点收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>   <span class="comment">/* Node related to this link if any, or NULL */</span></span><br><span class="line">    ...</span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure><h4 id="Redis-Cluster集群的处理流程"><a href="#Redis-Cluster集群的处理流程" class="headerlink" title="Redis Cluster集群的处理流程"></a><strong>Redis Cluster集群的处理流程</strong></h4><p>在单机模式下，Redis对请求的处理很简单。Key存在的话，就执行请求中的操作；Key不存在的话，就告诉客户端Key不存在。然而在集群模式下，因为涉及到请求重定向和Slot迁移，所以对请求的处理变得很复杂，流程如下：</p><ul><li>检查Key所在Slot是否属于当前Node？</li><li>计算crc16(key) % 16384得到Slot</li><li>查询clusterState.slots负责Slot的结点指针</li><li>与myself指针比较</li><li>若不属于，则响应MOVED错误重定向客户端</li><li>若属于且Key存在，则直接操作，返回结果给客户端</li><li>若Key不存在，检查该Slot是否迁出中？(clusterState.migrating_slots_to)</li><li>若Slot迁出中，返回ASK错误重定向客户端到迁移的目的服务器上</li><li>若Slot未迁出，检查Slot是否导入中？(clusterState.importing_slots_from)</li><li>若Slot导入中且有ASKING标记，则直接操作</li><li>否则响应MOVED错误重定向客户端</li></ul><h4 id="Redis-Cluster容错机制"><a href="#Redis-Cluster容错机制" class="headerlink" title="Redis Cluster容错机制"></a><strong>Redis Cluster容错机制</strong></h4><p>failover是redis cluster的容错机制，是redis cluster最核心功能之一；它允许在某些节点失效情况下，集群还能正常提供服务。</p><p>redis cluster采用主从架构，任何时候只有主节点提供服务，从节点进行热备份，故其容错机制是主从切换机制，即主节点失效后，选取一个从节点作为新的主节点。在实现上也复用了旧版本的主从同步机制。</p><p>从纵向看，redis cluster是一层架构，节点分为主节点和从节点。从节点挂掉或失效，不需要进行failover，redis cluster能正常提供服务；主节点挂掉或失效需要进行failover。另外，redis cluster还支持manual failover，即人工进行failover，将从节点变为主节点，即使主节点还活着。下面将介绍这两种类型的failover。</p><p><strong>1）主节点失效产生的failover</strong></p><ul><li><p>（主）节点失效检测<br>一般地，集群中的节点会向其他节点发送PING数据包，同时也总是应答（accept）来自集群连接端口的连接请求，并对接收到的PING数据包进行回复。当一个节点向另一个节点发PING命令，但是目标节点未能在给定的时限（node timeout）内回复时，那么发送命令的节点会将目标节点标记为PFAIL（possible failure）。</p><p>由于节点间的交互总是伴随着信息传播的功能，此时每次当节点对其他节点发送 PING 命令的时候，就会告知目标节点此时集群中已经被标记为PFAIL或者FAIL标记的节点。相应的，当节点接收到其他节点发来的信息时， 它会记下那些被其他节点标记为失效的节点。 这称为失效报告（failure report）。</p><p>如果节点已经将某个节点标记为PFAIL，并且根据节点所收到的失效报告显式，集群中的大部分其他主节点（n/2+1）也认为那个节点进入了失效状态，那么节点会将那个PFAIL节点的状态标记为FAIL。</p><p>一旦某个节点被标记为FAIL，关于这个节点已失效的信息就会被广播到整个集群，所有接收到这条信息的节点都会将失效节点标记为FAIL。</p></li><li><p>选举主节点<br>一旦某个主节点进入 FAIL 状态， 集群变为FAIL状态，同时会触发failover。failover的目的是从从节点中选举出新的主节点，使得集群恢复正常继续提供服务。<br><strong>整个主节点选举的过程可分为申请、授权、升级、同步四个阶段：</strong></p><ul><li><p><strong>申请</strong><br>新的主节点由原已失效的主节点属下的所有从节点中自行选举产生，从节点的选举遵循以下条件：<br>a、这个节点是已下线主节点的从节点；<br>b、已下线主节点负责处理的哈希槽数量非空；<br>c、主从节点之间的复制连接的断线时长有限，不超过 ( (node-timeout * slave-validity-factor) + repl-ping-slave-period ）。</p><p>如果一个从节点满足了以上的所有条件，那么这个从节点将向集群中的其他主节点发送授权请求，询问它们是否允许自己升级为新的主节点。<br>从节点发送授权请求的时机会根据各从节点与主节点的数据偏差来进行排序，让偏差小的从节点优先发起授权请求。</p></li><li><p><strong>授权</strong><br>其他主节点会遵信以下三点标准来进行判断：<br>a、 发送授权请求的是从节点，而且它所属的主节点处于FAIL状态 ；<br>b、 从节点的currentEpoch〉自身的currentEpoch，从节点的configEpoch&gt;=自身保存的该从节点的configEpoch；<br>c、 这个从节点处于正常的运行状态，没有被标记为FAIL或PFAIL状态；</p></li></ul><p>​       如果发送授权请求的从节点满足以上标准，那么主节点将同意从节点的升级要求，向从节点返回             <code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>授权。</p><ul><li><strong>升级</strong><br>一旦某个从节点在给定的时限内得到大部分主节点（n/2+1）的授权，它就会接管所有由已下线主节点负责处理的哈希槽，并主动向其他节点发送一个PONG数据包，包含以下内容：<br>a、 告知其他节点自己现在是主节点了<br>b、 告知其他节点自己是一个ROMOTED SLAVE，即已升级的从节点；<br>c、告知其他节点都根据自己新的节点属性信息对配置进行相应的更新</li><li><strong>同步</strong><br>其他节点在接收到ROMOTED SLAVE的告知后，会根据新的主节点对配置进行相应的更新。特别地，其他从节点会将新的主节点设为自己的主节点，从而与新的主节点进行数据同步。<br>至此，failover结束，集群恢复正常状态。</li></ul></li></ul><p><strong>此时，如果原主节点恢复正常，但由于其的configEpoch小于其他节点保存的configEpoch（failover了产生较大的configEpoch），故其配置会被更新为最新配置，并将自己设新主节点的从节点。</strong></p><p>另外，在failover过程中，如果原主节点恢复正常，failover中止，不会产生新的主节点。</p><p><strong>2）Manual Failover</strong><br>Manual Failover是一种运维功能，允许手动设置从节点为新的主节点，即使主节点还活着。<br>Manual Failover与上面介绍的Failover流程大都相同，除了下面两点不同：<br>a）触发机制不同，Manual Failover是通过客户端发送cluster failover触发，而且发送对象只能是从节点；<br>b）申请条件不同，Manual Failover不需要主节点失效，failover有效时长固定为5秒，而且只有收到命令的从节点才会发起申请。</p><p>另外，Manual Failover分force和非force，区别在于：非force需要等从节点完全同步完主节点的数据后才进行failover，保证不丢失数据，在这过程中，原主节点停止写操作；而force不进行进行数据完整同步，直接进行failover。</p><p><strong>3）集群状态检测</strong><br>集群有OK和FAIL两种状态，可以通过CLUSTER INFO命令查看。当集群发生配置变化时， 集群中的每个节点都会对它所知道的节点进行扫描，只要集群中至少有一个哈希槽不可用（即负责该哈希槽的主节点失效），集群就会进入FAIL状态，停止处理任何命令。<br>另外，当大部分主节点都进入PFAIL状态时，集群也会进入FAIL状态。这是因为要将一个节点从PFAIL状态改变为FAIL状态，必须要有大部分主节点（n/2+1）认可，当集群中的大部分主节点都进入PFAIL时，单凭少数节点是没有办法将一个节点标记为FAIL状态的。 然而集群中的大部分主节点(n/2+1)进入了下线状态，让集群变为FAIL，是为了防止少数存着主节点继续处理用户请求，这解决了出现网络分区时，一个可能被两个主节点负责的哈希槽，同时被用户进行读写操作（通过禁掉其中少数派读写操作，证保只有一个读写操作），造成数据丢失数据问题。<br>说明：上面n/2+1的n是指集群里有负责哈希槽的主节点个数。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://www.cnblogs.com/kevingrace/p/7955725.html" target="_blank" rel="noopener">Redis Cluster集群知识学习总结</a></p><p><a href="https://segmentfault.com/a/1190000015975330" target="_blank" rel="noopener">redis系列：集群</a></p><p><a href="https://www.cnblogs.com/williamjie/p/11132211.html" target="_blank" rel="noopener">高可用Redis：Redis Cluster</a></p><p><a href="https://blog.csdn.net/liuxiao723846/article/details/86715614" target="_blank" rel="noopener">redis cluster介绍</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/9004460.html" target="_blank" rel="noopener">Redis哨兵模式（sentinel）学习总结及部署记录（主从复制、读写分离、主从切换)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经过前两篇读书笔记的整理对redis设计与实现这本书梳理了下,当然我的梳理稍显粗糙,因为很多内容在书上介绍的比较清楚,而这本书就在我手头上,
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://www.enjoyican.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现读书笔记-单机数据库的实现</title>
    <link href="https://www.enjoyican.com/posts/redis-two/"/>
    <id>https://www.enjoyican.com/posts/redis-two/</id>
    <published>2020-03-18T14:52:30.000Z</published>
    <updated>2020-03-18T14:52:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库"><a href="#1-数据库" class="headerlink" title="1.  数据库"></a>1.  数据库</h3><p>redis数据库的很多操作都是通过对键空间进行操作来实现的,比如添加,删除,更新,取值操作,比如用于清空整个数据库的<code>FLUSHDB</code>命令,用于返回数据库中随机键的<code>RANDOMKEY</code>,类似的命令还有<code>EXISTS</code>,<code>RENAME</code>,<code>KEYS</code>等.</p><p>当使用redis命令对数据库进行读写时,服务器不仅对键空间执行指定的读写操作,还会执行一些额外的维护操作,包括:</p><ul><li>读取一个键后(包括读操作和写操作)更新键的命中(hit)或不命中(miss)的次数,这两个值可以在<code>INFO stats</code>命令的<code>keyspace_hits</code>属性和<code>keyspace_misses</code>属性中查看.</li><li>更新键的LRU(最后一次使用)时间,这个值可以用来计算键的闲置时间(为将来键删除算法做准备)</li><li>读取时如果发现键已经过期,就删除该键之后再执行剩下的操作</li><li>如果有客户端使用<code>WATCH</code>命令监视了某个键,那么服务器在对被监视的键进行修改之后,会将这个键标记为脏(dirty)</li><li>服务器每次修改一个键之后,都会对脏(dirty)键计数器的值增1,这个计数器会触发服务器的持久化和复制操作</li></ul><h4 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h4><p>redis有四个命令用来设置键的过期时间:</p><p><code>EXPIRE &lt;key&gt; &lt;ttl&gt;</code> 将键的生存时间设置为ttl<strong>秒</strong></p><p><code>PEXPIRE &lt;key&gt; &lt;ttl&gt;</code>将键的生存时间设置为ttl<strong>毫秒</strong></p><p><code>EXPIRE &lt;key&gt; &lt;timestamp&gt;</code> 将键的生存时间设置为timestamp所指定的<strong>秒数时间戳</strong></p><p><code>PEXPIRE &lt;key&gt; &lt;timestamp&gt;</code>将键的生存时间设置为timestamp所指定的<strong>毫秒数时间戳</strong></p><p><strong>以上四个命令,最终执行都是转换为第四个命令的执行方式执行的.</strong></p><h4 id="保存过期时间"><a href="#保存过期时间" class="headerlink" title="保存过期时间"></a>保存过期时间</h4><p>redisDb结构的expires字典保存了数据库中所有键的过期时间,这个字典叫做过期字典:过期字典是一个long long类型的整数,这个整数保存了键所指向的数据库键的过期时间(毫秒精度的UNIX时间戳)</p><h4 id="移除过期时间"><a href="#移除过期时间" class="headerlink" title="移除过期时间"></a>移除过期时间</h4><p><code>PERSIST</code>命令可以移除一个键的过期时间,用法 <code>PERSIST</code> key</p><h4 id="计算并返回剩余生存时间"><a href="#计算并返回剩余生存时间" class="headerlink" title="计算并返回剩余生存时间"></a>计算并返回剩余生存时间</h4><p>TTL命令以秒为单位返回键的剩余生存时间,而PTTL命令则以毫秒为单位返回键的剩余生存时间,这两个命令都是通过计算键的过期时间和当前时间之间的差来实现的</p><h4 id="过期键删除策略"><a href="#过期键删除策略" class="headerlink" title="过期键删除策略"></a>过期键删除策略</h4><ul><li><p><strong>定时删除</strong>: 在设置键的过期时间的同时,创建一个定时器(timer),让定时器在键的过期时间来临时,立即执行键删除操作</p><p><strong>优点:</strong>  对内存友好,通过使用定时器保证过期键会尽快删除,并释放掉占用的内存</p><p><strong>缺点:</strong>   对CPU时间不友好,比如某一时刻过期键比较多,那就会占用比较多的CPU时间来删除</p></li><li><p><strong>惰性删除</strong>: 平时不对键进行操作,当从键空间获取键的时候,检查键是否过期,过期的话就删除该键,没过期就返回</p><p><strong>优点:</strong>   对CPU时间友好</p><p><strong>缺点:</strong>   对内存不友好,比如一个键已经过期,但是没有及时删除,就会一直占用内存</p></li><li><p><strong>定期删除</strong>:  每个一段时间对数据库进行检查,删除里面的过期键,至于删除多少,检查多少个数据库,由具体算法确定</p><p>定期删除是以上两种方案优缺点的折中,但是需要合理设定删除操作的执行时长和频率</p></li></ul><p><strong>redis实际采取的是惰性删除和定期删除两种策略</strong></p><p>惰性删除策略由db.c/expireIfNeeded函数实现,所有读写数据库的命令(如<code>SET  LRANGE  SADD  HGET  KEYS等</code>)在执行之前都会调用该函数对键进行检查:如果已经过期该函数会将该键删除,否则不做操作.</p><p>定期删除策略由redis.c/activeExpireCycle函数实现,每当redis的服务器周期性操作redis.c/serverCron函数执行时,activeExpireCycle函数就会被调用.</p><h4 id="AOF-RDB和复制功能对过期键的处理"><a href="#AOF-RDB和复制功能对过期键的处理" class="headerlink" title="AOF/RDB和复制功能对过期键的处理"></a>AOF/RDB和复制功能对过期键的处理</h4><p><strong>生成RDB文件</strong>: 当执行<code>SAVE</code>或者<code>BGSAVE</code>命令创建新的RDB文件时,已过期的键不会被保存到新建的RDB文件中</p><p><strong>载入RDB文件:</strong> 启动redis服务器时,如果服务器开启了RDB功能,那么服务器将对RDB文件进行载入.<strong>如果服务器以主服务器模式运行,载入RDB文件时,会对文件中保存的键进行检查,过期的键不会被载入;如果服务器以从服务器的模式运行,不论键是否过期,都会载入到数据库,但是由于主从服务器进行数据同步的时候从服务器的数据库就会清空,所以不会有什么影响.</strong></p><p><strong>AOF文件写入:</strong>  当过期键被惰性删除或者定期删除之后,程序会向AOF文件追加一条DEL命令,来显式的记录该键已被删除</p><p><strong>AOF重写:</strong>  在执行AOF重写的过程中会对数据库中的键进行检查,如果已经过期了的不会被保存到重写后的AOF文件</p><p><strong>复制:</strong>   当服务器运行在复制模式下时,从服务器的过期键删除动作由主服务器控制:</p><ul><li>主服务器删除一个键之后会显式的向所有从服务器发送一个DEL命令,告知从服务器删除这个过期键</li><li>从服务器只有在接到主服务器发来的DEL命令之后,才会删除过期键</li><li>从服务器接到客户端发送的读命令时,即使碰到过期键也不会处理,还是会按照正常情况返回值</li></ul><h4 id="数据库通知"><a href="#数据库通知" class="headerlink" title="数据库通知"></a>数据库通知</h4><p>数据库通知功能可以让客户端通过订阅给定的频道或模式,来获知数据库中键的变化,以及数据库中命令的执行情况,这类通知可以分为两类:</p><p><strong>键空间通知(key-space notification):</strong>  关注某个键执行了什么命令,比如针对某个key执行了expire,set,del等</p><p><strong>键事件通知(key-event notification)</strong>:  关注某个命令被什么键执行了,比如del命令执行在哪些键上了</p><p>服务器配置的<code>notify-keyspace-events</code>选项决定了服务器所发送通知的类型:</p><p><code>AKE</code> :  发送所有类型的键空间和键事件通知</p><p><code>AK</code>   :  发送所有类型的键空间通知</p><p><code>AE</code>   :  发送所以类型的键事件通知</p><p><code>K$</code>   :  只发送和字符串键有关的键空间通知</p><p><code>El</code>   :  只发送和list键有关的键事件通知</p><h3 id="2-RDB持久化"><a href="#2-RDB持久化" class="headerlink" title="2.  RDB持久化"></a>2.  RDB持久化</h3><p>RDB持久化功能所生成的RDB文件是一个经过压缩的二进制文件,通过该文件可以还原生成RDB文件时的数据库状态.</p><h4 id="RDB文件的创建与载入"><a href="#RDB文件的创建与载入" class="headerlink" title="RDB文件的创建与载入"></a>RDB文件的创建与载入</h4><p>有两个Redis命令可以用于生成RDB文件,一个是<code>SAVE</code>,另一个是<code>BGSAVE</code>,<code>SAVE</code> 命令会阻塞服务器进程,<code>BGSAVE</code>命令会派生出一个子进程,然后由子进程负责创建RDB文件.</p><p>Redis并没有专门用于载入RDB文件的命令,只要服务器启动之后检测到RDB文件就会自动载入,由于AOF文件的更新频率通常比RDB文件的更新频率高,所以:</p><ul><li><strong>如果服务器开启了AOF持久化功能,则优先使用AOF文件来还原数据库状态</strong></li><li>AOF持久化功能关闭时,会采用RDB文件来还原数据</li></ul><p>服务器在载入RDB文件期间,会一直处于阻塞状态,直到载入工作完成为止,BGSAVE命令可以在配置文件中配置每个一段时间自动执行,详见<code>save 900 1...</code>这一组配置</p><p>具体RDB文件保存的格式和内容建议直接看原书第10章内容</p><h3 id="3-AOF持久化"><a href="#3-AOF持久化" class="headerlink" title="3.AOF持久化"></a>3.AOF持久化</h3><p>与RDB持久化通过保存数据库中的键值对来记录数据库状态不同,AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库的状态的,AOF持久化功能的实现分为命令追加(append),文件写入,文件同步(sync)三个步骤</p><h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当AOF持久化功能处于打开状态时,服务器在执行完一个写命令之后,会以协议格式将被执行的写命令追加到服务器状态的<strong>aof_buf缓冲区</strong>的末尾:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如:当客户端向服务器发送如下命令:</p><p>redis &gt; SET KEY VALUE</p><p>OK</p><p>服务器在执行完命令之后,会将以下协议内容追加到aof_buf缓冲区的末尾:</p><p><code>*3\r\n$3\r\nSET\r\nKEY\r\n$5\r\nVALUE\r\n</code></p><h4 id="文件的写入与同步"><a href="#文件的写入与同步" class="headerlink" title="文件的写入与同步"></a>文件的写入与同步</h4><p> redis服务器进程就是一个事件循环(loop).这个循环中的文件事件负责接收客户端的命令请求,以及向客户端发送命令回复,而时间事件则负责执行像serverCron函数这样需要定时运行的函数.</p><p>由于服务器在处理文件事件时可能会执行写命令.在此期间一些内容被追加到aof_buf缓冲区中,所以在服务器每次结束一个事件循环之前,都会调用一个flushAppendOnlyFile函数,考虑是否将aof_buf缓冲区中内容写入和保存进AOF文件中,该函数的行为有服务器配置文件中的<code>appendfsync</code>选项中的值来决定,各个值的含义如下:</p><table><thead><tr><th align="center"><code>appendfsync</code>选项的值</th><th>flushAppendOnlyFile函数的行为</th></tr></thead><tbody><tr><td align="center">always</td><td>将缓冲区中的所有内容写入并同步到AOF文件</td></tr><tr><td align="center">everysec  (默认)</td><td>将缓冲区中的所有内容写入到AOF文件,如果上次同步距离现在时间超过1秒,<br>那么再次对AOF文件进行同步,该同步行为有一个专门负责的线程</td></tr><tr><td align="center">no</td><td>将缓冲区中的所有内容写入到AOF文件,但并不进行同步,何时同步由操作系统决定</td></tr></tbody></table><h4 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h4><p>因为AOF文件中记录了重建数据库所需要的所有写命令,所以服务器只要读入并重新执行一遍AOF文件中保存的写命令,就可以还原服务器关闭之前的数据库状态.</p><h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>随着AOF文件中保存的指令越来越多,文件体积越来越大,这个时候需要对文件进行重写来缩小文件所占存储空间.</p><p>AOF文件重写并不需要对现有AOF文件进行读取或者分析,是直接通过读取服务器当前的数据库状态实现的,比如当前数据库存在一个键值对,老的AOF文件中可能存储了对这个键值对的各种历史操作命令,重写的时候只要读取该键值对最新的状态将之前的多个指令合并成最后的一条指令保存即可,这就是<strong>AOF重写的原理</strong></p><p>有个特殊的点是对于除了字符串之外的另外四种数据类型,如果一个键对应的元素个数很多,超过某个配置的值,会使用多条记录保存命令,而不只是一条.</p><p>AOF文件的重写是通过一个子进程来执行的,使用子进程而不是线程,主要是为了在避免使用锁的情况下还能保证数据安全性.由于在子进程执行重写任务的过程中,可能主进程依然会执行新的命令.Redis设置了一个AOF重写缓冲区来存储在这段时间中主进程执行的新的指令.该缓冲区当子进程建立的时候开始使用</p><p>因此在子进程进行重写的过程中,如果主线程接收到新的命令,会将其同时保存在aof_buf缓冲区及AOF重写缓冲区中;而子进程在完成AOF重写工作后会给主进程发送一个信号,之后主进程收到信号并调用一个函数,执行以下工作:</p><ul><li>将AOF重写缓冲区中的所有内容写入到新的AOF文件中,这时新的AOF文件所保存的数据库状态将和当前服务器的状态一致.</li><li>对新的AOF文件进行改名,原子地覆盖现有的AOF文件,完成新旧文件的替换</li></ul><p>这两个动作完成之后,主线程就可以继续接受新的指令了.</p><p>在整个AOF后台重写的过程中,只有该过程会对主进程造成阻塞,其他时间都是在后台进行,不影响主进程执行任务.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-数据库&quot;&gt;&lt;a href=&quot;#1-数据库&quot; class=&quot;headerlink&quot; title=&quot;1.  数据库&quot;&gt;&lt;/a&gt;1.  数据库&lt;/h3&gt;&lt;p&gt;redis数据库的很多操作都是通过对键空间进行操作来实现的,比如添加,删除,更新,取值操作,比如用于清空整个
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://www.enjoyican.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>redis设计与实现读书笔记-数据结构与实现</title>
    <link href="https://www.enjoyican.com/posts/redis-one/"/>
    <id>https://www.enjoyican.com/posts/redis-one/</id>
    <published>2020-03-17T13:19:30.000Z</published>
    <updated>2020-03-17T13:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-简单动态字符串"><a href="#1-简单动态字符串" class="headerlink" title="1.  简单动态字符串"></a>1.  简单动态字符串</h3><p>简单动态字符串<code>(simple dynamic string,SDS)</code>是redis的默认字符串表示,除此之外,SDS还被用做缓冲区(AOF模块中的AOF缓冲区和客户端状态中的输入缓冲区),AOF模块缓冲区指的是在做AOF备份的时候新增加的指令会缓冲到缓冲区,之后再发起部分同步到磁盘;客户端状态的输入缓冲区是指在服务端保存着客户端输入指令的一个缓冲区.</p><p>SDS的表示结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span>&#123;</span></span><br><span class="line">    <span class="comment">//记录buf数组中已使用的字节的数量,等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">//保存buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">//字节数组,用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>以上两图为SDS存储示例.图1中free为0,表示该SDS没有分配任何未使用空间,len=5表示存储的字符串字节长度,buf指向保存数据的数组,结尾保存空字符串’\0’,这是为了遵循C的保存习惯,以便可以使用部分C的函数,但不计入len的统计中.图二中free=5表示除了保存的redis字符串之外,还分配了5字节未使用的空间.</p><p>因为保存了字符串的长度,所以redis获取字符串的长度时间复杂度为O(1),同时可以杜绝缓冲区溢出,当需要修改SDS时,会先检查空间是否足够,不够的话会先扩展空间再保存新的数据.</p><p>通过buf中的free表示的未使用空间,SDS实现了<strong>空间预分配和惰性空间释放</strong>两种优化策略.</p><h4 id="1-1-空间预分配"><a href="#1-1-空间预分配" class="headerlink" title="1.1 空间预分配"></a>1.1 空间预分配</h4><p>当进行字符串增长操作,需要对SDS进行空间扩展时,程序会在分配修改所需的必要空间之外,再分配额外的未使用空间,分配策略如下:</p><p>如果修改之后SDS的长度小于1MB,那么程序将分配和修改之后len长度同样大小的未使用空间;如果修改之后的SDS长度大于1MB,那么程序将分配1MB的未使用空间.</p><h4 id="1-2-惰性空间释放"><a href="#1-2-惰性空间释放" class="headerlink" title="1.2 惰性空间释放"></a>1.2 惰性空间释放</h4><p>当进行字符串缩短操作时,修改后空余出来的空间并不会被立即释放,而是记录在free中,当下次进行字符串的扩展时,如果字符串长度小于free的值,就不需要进行空间扩展操作,通过这个策略避免了既避免了缩短字符串之后的内存重分配操作,又为将来的拓展留出空间,同时SDS提供了专门释放空间的api,不需要担心free空间太大造成的内存浪费.</p><p>以下是SDS字符串与C字符串的区别:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.  链表"></a>2.  链表</h3><p>链表在redis中的应用比较广泛,list类型的值对象底层实现之一就是链表,当列表键中包含了数量比较多的元素,或者包含的元素都是比较长的字符串时,就会使用链表(后面笔记中记录),除此之外发布与订阅,慢查询,监视器等功能也用到了链表,Redis服务器本身还用链表来保存多个客户端的状态信息以及构建客户端输出缓冲区.</p><p>redis的链表实现是双端无环链表,其结构与示意图如下:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/4.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p> 此外还通过list结构对链表进行持有,示意图及结构如下: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span>&#123;</span></span><br><span class="line">    <span class="comment">//表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">//表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">//链表所包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>) (<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;<span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/6.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="3-字典"><a href="#3-字典" class="headerlink" title="3.  字典"></a>3.  字典</h3><p>字典中一个key对应一个value,每个key是唯一的,redis数据库底层就是使用字典实现,增删改查操作也是建立在对字典的操作之上.除此之外,字典还是值对象类型为hash时的底层实现,当一个hash值对象包含的数据比较多或者包含的数据的长度都比较长的时候,redis会使用字典作为其底层实现,而字典的底层又是使用哈希表实现,每个哈希表包含多个哈希节点每个哈希节点保存了字典中的一个键值对redis哈希表使用链地址法解决哈希冲突,多个冲突的节点通过next指针相链接,当有冲突时,新的节点放在其他节点的前面.当hash表中数据过多或者过少时,会通过rehash来重新分配空间(将原来小空间哈希表上的节点rehash保存到另外一个大空间哈希表上的,之后将原来的小表置空).</p><h4 id="3-1-哈希表的扩展与收缩"><a href="#3-1-哈希表的扩展与收缩" class="headerlink" title="3.1  哈希表的扩展与收缩"></a>3.1  哈希表的扩展与收缩</h4><p>当以下条件中的任意一个满足时,程序会自动开始对hash表进行扩展操作:</p><p>1)服务器目前没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令,且哈希表的负载因子大于等于1(负载因子=已保存的节点数量/哈希表大小)</p><p>2)服务器正在执行以上两个命令中的一个,但是负载因子大于等于5</p><p>当哈希表负载因子小于0.1,程序自动开始对哈希表执行收缩操作.</p><h4 id="3-2-渐进式rehash"><a href="#3-2-渐进式rehash" class="headerlink" title="3.2  渐进式rehash"></a>3.2  渐进式rehash</h4><p>当扩展或收缩哈希表的时候,需要对其中保存的键值对进行rehash,但是为了避免对服务器性能造成影响,并不是一次性rehash全部键值对而是分多次渐进式分配.<strong>渐进式rehash期间新增的键值对不会保存到老的哈希表中,会直接进入新hash表</strong>.</p><h3 id="4-跳表"><a href="#4-跳表" class="headerlink" title="4.  跳表"></a>4.  跳表</h3><p>redis使用跳表(skiplist)作为zset对象类型的底层实现之一:当一个zset包含的元素数量比较多或者包含的成员都是比较长的字符串时redis中只在两个地方使用了跳表,一个是实现zset数据类型,另外一个是在集群节点中用作内部数据结构.同一个跳跃表中,各个节点保存的成员对象必须是唯一的,但是分值可以相同,分值相同时按照字典排序小的在前大的在后.</p><h3 id="5-整数集合"><a href="#5-整数集合" class="headerlink" title="5.  整数集合"></a>5.  整数集合</h3><p>整数集合(intset)值对象为set数据类型的底层实现之一,当一个集合只包含整数值元素,并且集合的元素数量不多时.</p><p>intset是redis用来保存整数值的集合抽象数据结构,可以保存类型为<code>int16_t</code>,<code>int32_t</code>或者<code>int64_t</code>的整数值,并且保证</p><p>不会出现重复:</p><p>整数集合数据结构如下:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="comment">//编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">//集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">//保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125;intset</span><br></pre></td></tr></table></figure><p>contents[]用于保存集合中的元素(按照值的大小从小到大,不重复)</p><p>encoding中保存的编码方式决定了contents[]中保存的值类型,有三种对应关系,<code>encoding(content)-&gt;INTSET_ENC_INT16(int16_t):可保存-32768~32767;INTSET_ENC_INT32(int32_t)可保存-2147483648~2147283647,INTSET_ENC_INT64(int64_t)可保存-9223372036854775808~9223372036854775807</code></p><h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><p>当要将一个新元素添加到整数集合里时,如果新元素的类型比整数集合现有的所有元素的类型都长,整数集合会先进行升级,然后才将新元素添加进去,比如现有三个是<code>int16_t</code>,现在要添加一个<code>int32_t</code>会先将之前的三个转换为<code>int32_t</code>,然后再加入新元素.升级的好处一是提升整数集合的灵活性,另外能够节约内存空间,<strong>目前暂不支持降级</strong></p><h3 id="6-压缩列表"><a href="#6-压缩列表" class="headerlink" title="6.  压缩列表"></a>6.  压缩列表</h3><p>压缩列表(ziplist)是list和hash值对象的底层实现之一,当一个list只包含少数元素,并且每个元素要么是小整数值要么是长度比较短的字符串,或者一个hash键的值包含少量的键值对,并且每个键值对要么要么是小整数值要么是长度比较短的字符串.</p><p>压缩列表是redis为了节约内存而开发的,是由一系列特殊编码的连续内存块组成的顺序型数据结构,一个压缩列表可以包含任意多个节点(entry),每个节点可以保存一个字节数组或者一个整数值.</p><h3 id="7-对象"><a href="#7-对象" class="headerlink" title="7.  对象"></a>7.  对象</h3><h4 id="7-1-对象类型与编码"><a href="#7-1-对象类型与编码" class="headerlink" title="7.1  对象类型与编码"></a>7.1  对象类型与编码</h4><p>Redis使用对象来保存数据库中的键和值,分别为键对象和值对象.每个对象由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type,encoding和ptr:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span>&#123;</span></span><br><span class="line">    <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">//指向底层实现数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于redis数据库保存的键值对来说,键总是一个字符串对象,值可以是字符串对象,list对象,hash对象,set对象和zset对象.可以使用type命令查看值对象的类型,命令格式为type key.</strong></p><p>对象的ptr指针指向对象的底层实现数据结构,由对象的encoding属性决定,encoding属性记录了对象的底层实现,这个属性的值可以是下表中列出的常量中的一个:</p><table><thead><tr><th align="center">编码常量</th><th align="center">编码所对应的底层数据结构</th></tr></thead><tbody><tr><td align="center">REDIS_ENCODING_INT</td><td align="center">long类型的整数</td></tr><tr><td align="center">REDIS_ENCODING_EMBSTR</td><td align="center">embstr编码的简单动态字符串</td></tr><tr><td align="center">REDIS_ENCODING_RAW</td><td align="center">简单动态字符串</td></tr><tr><td align="center">REDIS_ENCODING_HT</td><td align="center">字典</td></tr><tr><td align="center">REDIS_ENCODING_LINKEDLIST</td><td align="center">双端链表</td></tr><tr><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">压缩列表</td></tr><tr><td align="center">REDIS_ENCODING_INTSET</td><td align="center">整数集合</td></tr><tr><td align="center">REDIS_ENCODING_SKIPLIST</td><td align="center">跳跃表和字典</td></tr></tbody></table><p> 每种类型的对象都至少使用了两种类型的编码,如下表所示: </p><table><thead><tr><th align="center">类型</th><th align="center">编码</th><th align="center">对象</th></tr></thead><tbody><tr><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_INT</td><td align="center">使用整数值实现的字符对象</td></tr><tr><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_EMBSTR</td><td align="center">使用embstr编码的简单动态字符串实现的字符串对象</td></tr><tr><td align="center">REDIS_STRING</td><td align="center">REDIS_ENCODING_RAW</td><td align="center">使用简单动态字符串实现的字符串对象</td></tr><tr><td align="center">REDIS_LIST</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的list对象</td></tr><tr><td align="center">REDIS_LIST</td><td align="center">REDIS_ENCODING_LINKEDLIST</td><td align="center">使用双端链表实现的list对象</td></tr><tr><td align="center">REDIS_HASH</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的hash对象</td></tr><tr><td align="center">REDIS_HASH</td><td align="center">REDIS_ENCODING_HT</td><td align="center">使用字典实现的hash对象</td></tr><tr><td align="center">REDIS_SET</td><td align="center">REDIS_ENCODING_INTSET</td><td align="center">使用整数集合实现的set对象</td></tr><tr><td align="center">REDIS_SET</td><td align="center">REDIS_ENCODING_HT</td><td align="center">使用字典实现的set对象</td></tr><tr><td align="center">REDIS_ZET</td><td align="center">REDIS_ENCODING_ZIPLIST</td><td align="center">使用压缩列表实现的zset对象</td></tr><tr><td align="center">REDIS_ZET</td><td align="center">REDIS_ENCODING_SKIPLIST</td><td align="center">使用跳跃表和字典实现的zset对象</td></tr></tbody></table><p>使用object encoding key命令可以查看对应键的值对象的编码,每种值对象至少使用两种编码可以方便redis在不同的场景下选择合适的数据实现,提高效率.</p><h4 id="7-2-字符串对象"><a href="#7-2-字符串对象" class="headerlink" title="7.2  字符串对象"></a>7.2  字符串对象</h4><p>字符串对象的编码可以是<code>int,raw或者embstr</code>,各自使用场景如下:</p><p><strong><code>int</code></strong>:  当字符串对象保存的是整数值,并且该整数值可以用<code>long</code>类型表示</p><p><strong><code>raw</code></strong>: 当保存的是字符串并且该字符串长度大于39字节,使用一个<code>SDS</code>来保存值,并将编码设置为<code>raw</code></p><p><strong><code>embstr</code></strong>:  当保存的是字符串并且该字符串长度小于39字节,将编码设置为<code>embstr</code></p><p><code>embstr</code>编码是专门用于保存短字符串的一种优化编码放是,其和<code>raw</code>编码一样,都是用<code>redisObject</code>结构和<code>sdshdr</code>结构来表示字符串对象,但<code>raw</code>编码需要调用两次内存分配函数来创建<code>redisObject</code>结构和<code>sdshdr</code>结构,而<code>embstr</code>通过调用一次内存分配函数来分配一块连续的空间,空间中依次包含<code>redisObject</code>结构和<code>sdshdr</code>结构:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/7.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p><strong><em>使用embstr编码好处是:1.降低内存分配次数(从两次降低为一次)2.释放字符串对象时,raw需要调用两次内存释放函数,embstr只需要一次3.因为embstr编码对象保存在连续空间中,能更好利用缓存带来的优势</em></strong></p><p>可以用long double类型表示的浮点数在redis中也是作为字符串保存的.编码对象可以相互转换,其中embstr编码没有任何修改程序,因此是只读的.下表是常见字符串命令的实现:</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/redis-one/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h4 id="7-3-list对象"><a href="#7-3-list对象" class="headerlink" title="7.3   list对象"></a>7.3   list对象</h4><p>list对象的编码可以是ziplist或者linkedlist,当list对象同时满足以下两个条件时,使用ziplist编码,否则使用linkedlist</p><p>1.list对象保存的所有字符串元素的长度都小于64字节;</p><p>2.元素数量小于512个</p><p>以上两个数值在配置文件中可以修改,对应的是<code>list-max-ziplist-value</code>选项和<code>list-max-ziplist-entries</code></p><h4 id="7-4-hash对象"><a href="#7-4-hash对象" class="headerlink" title="7.4   hash对象"></a>7.4   hash对象</h4><p>hash对象的编码可以是ziplist或者hashtable,当使用ziplist压缩列表编码时,一个键值对分别保存在一个节点上,一前一后紧挨在一起.先添加的键值对在表头方向,后添加的在表尾方向;当使用hashtable编码时,底层使用字典作为实现,键值对都是字符串对象.</p><p>hash对象同时满足以下两个条件时使用ziplist编码,否则使用hashtable编码:</p><p>1.键值对的键和值字符串长度都小于64字节;</p><p>2.键值对个数小于512个</p><p>以上两个数值在配置文件中可以修改,对应的是<code>hash-max-ziplist-value</code>选项和<code>hash-max-ziplist-entries</code></p><h4 id="7-5-set对象"><a href="#7-5-set对象" class="headerlink" title="7.5  set对象"></a>7.5  set对象</h4><p>set对象的编码可以是intset或者hashtable,当对象同时满足以下两个条件是,使用intset编码,否则使用hashtable编码:</p><p>1.保存的所有元素都是整数值</p><p>2.元素的数量不超过512个</p><p>第二个数值在配置文件中可以修改,对应的是<code>set-max-intset-entries</code></p><h4 id="7-6-zset对象"><a href="#7-6-zset对象" class="headerlink" title="7.6  zset对象"></a>7.6  zset对象</h4><p>zset对象的编码可以是ziplist或者skiplist.当使用ziplist编码时,每个元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员(member),第二个节点保存元素的分值(score),列表内按照分值从小到大排序,分值小的在表头方向,分值大的在表尾方向,skiplist编码看p78.</p><p>当同时满足以下两个条件时,使用ziplist编码,否则使用ziplist编码:</p><p>1.元素数量个数少于128个</p><p>2.所有元素成员的长度都小于64字节</p><p> 以上两个数值在配置文件中可以修改,对应的是<code>zset-max-ziplist-entries</code>选项和<code>zset-max-ziplist-value</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-简单动态字符串&quot;&gt;&lt;a href=&quot;#1-简单动态字符串&quot; class=&quot;headerlink&quot; title=&quot;1.  简单动态字符串&quot;&gt;&lt;/a&gt;1.  简单动态字符串&lt;/h3&gt;&lt;p&gt;简单动态字符串&lt;code&gt;(simple dynamic string,SD
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://www.enjoyican.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Redis" scheme="https://www.enjoyican.com/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>转载-AspectJ 使用介绍</title>
    <link href="https://www.enjoyican.com/posts/spring-aop-aspectj/"/>
    <id>https://www.enjoyican.com/posts/spring-aop-aspectj/</id>
    <published>2020-03-16T15:39:25.000Z</published>
    <updated>2020-03-16T15:39:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>上一篇文章，我们介绍了 Spring  AOP 的各种用法，包括随着 Spring 的演进而发展出来的几种配置方式。</p><p>但是我们始终没有使用到 AspectJ，即使是在基于注解的 @AspectJ 的配置方式中，Spring 也仅仅是使用了 AspectJ 包中的一些注解而已，并没有依赖于 AspectJ 实现具体的功能。</p><p>本文将介绍使用 AspectJ，介绍它的 3 种织入方式。</p><p>本文使用的测试源码已上传到 Github: <a href="https://github.com/hongjiev/aspectj-learning" target="_blank" rel="noopener">hongjiev/aspectj-learning</a>，如果你在使用过程中碰到麻烦，请在评论区留言。</p><p><strong>目录：</strong></p><!-- toc --><h2 id="AspectJ-使用介绍"><a href="#AspectJ-使用介绍" class="headerlink" title="AspectJ 使用介绍"></a>AspectJ 使用介绍</h2><p><a href="https://www.eclipse.org/aspectj/" target="_blank" rel="noopener">AspectJ</a> 作为 AOP 编程的完全解决方案，提供了三种织入时机，分别为</p><ol><li>compile-time：编译期织入，在编译的时候一步到位，直接编译出包含织入代码的 .class 文件</li><li>post-compile：编译后织入，增强已经编译出来的类，如我们要增强依赖的 jar 包中的某个类的某个方法</li><li>load-time：在 JVM 进行类加载的时候进行织入</li></ol><p>本节中的内容参考了《<a href="http://www.baeldung.com/aspectj" target="_blank" rel="noopener">Intro to AspectJ</a>》，Baeldung 真的是挺不错的一个 Java 博客。</p><p>首先，先把下面两个依赖加进来：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjrt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们后面需要用到下面这个类，假设账户初始有 20 块钱，之后会调 <code>account.pay(amount)</code> 进行付款：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> balance = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">pay</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balance &lt; amount) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        balance -= amount;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们定义两个 Aspect 来进行演示：</p><ul><li>AccountAspect：用 AspectJ 的语法来写，对交易进行拦截，如此次交易超过余额，直接拒绝。</li><li>ProfilingAspect：用 Java 来写，用于记录方法的执行时间</li></ul><p>AccountAspect 需要以 .aj 结尾，如我们在 com.javadoop.aspectjlearning.aspectj 的 package 下新建文件 <strong>AccountAspect.aj</strong>，内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aspectjlearning.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.javadoop.aspectjlearning.model.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> aspect AccountAspect &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointcut <span class="title">callPay</span><span class="params">(<span class="keyword">int</span> amount, Account account)</span>:</span></span><br><span class="line"><span class="function">            <span class="title">call</span><span class="params">(<span class="keyword">boolean</span> com.javadoop.aspectjlearning.model.Account.pay(<span class="keyword">int</span>)</span>) &amp;&amp; <span class="title">args</span><span class="params">(amount)</span> &amp;&amp; <span class="title">target</span><span class="params">(account)</span></span>;</span><br><span class="line"></span><br><span class="line">    before(<span class="keyword">int</span> amount, Account account): callPay(amount, account) &#123;</span><br><span class="line">        System.out.println(<span class="string">"[AccountAspect]付款前总金额: "</span> + account.balance);</span><br><span class="line">        System.out.println(<span class="string">"[AccountAspect]需要付款: "</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">around</span><span class="params">(<span class="keyword">int</span> amount, Account account)</span>: <span class="title">callPay</span><span class="params">(amount, account)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (account.balance &lt; amount) &#123;</span><br><span class="line">            System.out.println(<span class="string">"[AccountAspect]拒绝付款!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> proceed(amount, account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    after(<span class="keyword">int</span> amount, Account balance): callPay(amount, balance) &#123;</span><br><span class="line">        System.out.println(<span class="string">"[AccountAspect]付款后，剩余："</span> + balance.balance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面 .aj 的语法我们可能不熟悉，但是看上去还是简单的，分别处理了 before、around 和 after 的场景。</p></blockquote><p>我们再来看用 Java 写的 <strong>ProfilingAspect.java</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.javadoop.aspectjlearning.aspect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Around;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Pointcut;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfilingAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javadoop.aspectjlearning.model.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modelLayer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"modelLayer()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">logProfile</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Object result = joinPoint.proceed();</span><br><span class="line">        System.out.println(<span class="string">"[ProfilingAspect]方法: 【"</span> + joinPoint.getSignature() + <span class="string">"】结束，用时: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们讨论怎么样将定义好的两个 Aspects 织入到我们的 Account 的付款方法 pay(amount) 中，也就是三种织入时机分别是怎么实现的。</p><h2 id="Compile-Time-Weaving"><a href="#Compile-Time-Weaving" class="headerlink" title="Compile-Time Weaving"></a>Compile-Time Weaving</h2><p>这是最简单的使用方式，在编译期的时候进行织入，这样编译出来的 .class 文件已经织入了我们的代码，在 JVM 运行的时候其实就是加载了一个普通的被织入了代码的类。</p><p>如果你是采用 maven 进行管理，可以在 <code>&lt;build&gt;</code> 中加入以下的插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 编译期织入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">showWeaveInfo</span>&gt;</span>true<span class="tag">&lt;/<span class="name">showWeaveInfo</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">verbose</span>&gt;</span>true<span class="tag">&lt;/<span class="name">verbose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Xlint</span>&gt;</span>ignore<span class="tag">&lt;/<span class="name">Xlint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">goal</span>&gt;</span>test-compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>AccountAspect.aj 文件 javac 是没法编译的，所以上面这个插件其实充当了编译的功能。</p></blockquote><p>然后，我们就可以运行了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testCompileTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testCompileTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        account.pay(<span class="number">10</span>);</span><br><span class="line">        account.pay(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[AccountAspect]付款前总金额: 20</span><br><span class="line">[AccountAspect]需要付款: 10</span><br><span class="line">[ProfilingAspect]方法: 【boolean com.javadoop.aspectjlearning.model.Account.pay(int)】结束，用时: 1</span><br><span class="line">[AccountAspect]付款后，剩余：10</span><br><span class="line">[AccountAspect]付款前总金额: 10</span><br><span class="line">[AccountAspect]需要付款: 50</span><br><span class="line">[AccountAspect]拒绝付款!</span><br><span class="line">[AccountAspect]付款后，剩余：10</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>结果看上去就很神奇（我们知道是 aop 搞的鬼当然会觉得不神奇），其实奥秘就在于 main 函数中的代码被改变了，不再是上面几行简单的代码了，而是进行了织入：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop-aspectj/1.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>我们的 Account 类也不再像原来定义的那样了：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop-aspectj/2.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><p>编译期织入理解起来应该还是比较简单，就是在编译的时候先修改了代码再进行编译。</p><h2 id="Post-Compile-Weaving"><a href="#Post-Compile-Weaving" class="headerlink" title="Post-Compile Weaving"></a>Post-Compile Weaving</h2><p>Post-Compile Weaving 和 Compile-Time Weaving 非常类似，我们也是直接用场景来说。</p><p>我们假设上面的 Account 类在 aspectj-learning-share.jar 包中，我们的工程 aspectj-learning 依赖了这个 jar 包。</p><p>由于 Account 这个类已经被编译出来了，我们要对它的方法进行织入，就需要用到编译后织入。</p><p>为了方便大家测试，尽量让前面的用例也能跑起来。我们定义一个新的类 <strong>User</strong>，代码和 Account 一样，但是<strong>在 aspectj-learning-share.jar</strong> 包中，这个包就这一个类。</p><p>同时也复制 AccountAspect 一份出来，命名为 <strong>UserAspect</strong>，稍微修改修改就可以用来处理 User 类了。</p><p>首先，我们注释掉之前编译期织入使用的插件配置，增加以下插件配置（其实还是同一个插件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--编译后织入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.codehaus.mojo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">complianceLevel</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">complianceLevel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">weaveDependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">weaveDependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.javadoop<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectj-learning-share<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">weaveDependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">weaveDependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意配置中的 <code>&lt;weaveDependency&gt;</code>，我们在 <code>&lt;dependencies&gt;</code> 中要配置好依赖，然后在这里进行配置。这样就可以对其进行织入了。</p></blockquote><p>接下来，大家可以<strong>手动</strong>用 <code>mvn clean package</code> 编译一下，然后就会看到以下结果：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop-aspectj/3.png" alt="3" title="">                </div>                <div class="image-caption">3</div>            </figure><p>从上图我们可以看到，上面的配置会把相应的 jar 包中的类加到当前工程的编译结果中（User 类原本是在 aspectj-learning-share.jar 中的）。</p><p>运行一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="params"> -jar</span> target/aspectj-learning-1.0-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>运行结果也会如预期的一样，UserAspect 对 User 进行了织入，这里就不赘述了。感兴趣的读者自己去跑一下，注意一定要用 mvn 命令，不要用 IDE，不然很多时候发现不了问题。</p><blockquote><p>Intellij 在 build 的时候会自己处理 AspectJ，而不是用我们配置的 maven 插件。</p></blockquote><h2 id="Load-Time-Weaving"><a href="#Load-Time-Weaving" class="headerlink" title="Load-Time Weaving"></a>Load-Time Weaving</h2><p>最后，我们要介绍的是 LTW 织入，正如 Load-Time 的名字所示，它是在 JVM 加载类的时候做的织入。AspectJ 允许我们在启动的时候指定 <strong>agent</strong> 来实现这个功能。</p><p>首先，我们先<strong>注释掉之前在 pom.xml 中用于编译期和编译后织入使用的插件</strong>，免得影响我们的测试。</p><blockquote><p>我们要知道，一旦我们去掉了 aspectj 的编译插件，那么 .aj 的文件是不会被编译的。</p></blockquote><p>然后，我们需要在 JVM 的启动参数中加上以下 agent（或在 IDE 中配置 VM options），如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-javaagent:/Users/hongjie/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jar</span><br></pre></td></tr></table></figure><p>之后，我们需要在 resources 中配置 <strong>aop.xml</strong> 文件，放置在 META-INF 目录中（<strong>resource/META-INF/aop.xml</strong>）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">aspectj</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//AspectJ//DTD//EN"</span> <span class="meta-string">"http://www.eclipse.org/aspectj/dtd/aspectj.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">"com.javadoop.aspectjlearning.aspect.ProfilingAspect"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">weaver</span> <span class="attr">options</span>=<span class="string">"-verbose -showWeaveInfo"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">"com.javadoop.aspectjlearning..*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>aop.xml 文件中的配置非常容易理解，只需要配置 Aspects 和需要被织入的类即可。</p></blockquote><p>我们用以下程序进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testLoadTime();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testLoadTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Account account = <span class="keyword">new</span> Account();</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        account.pay(<span class="number">10</span>);</span><br><span class="line">        account.pay(<span class="number">50</span>);</span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>万事具备了，我们可以开始跑起来了。</p><p><strong>第一步，编译</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn clean package</span><br></pre></td></tr></table></figure><p><strong>第二步，检查编译结果</strong></p><p>我们通过 IDE 查看编译出来的代码（IDE反编译），可以看到，Application 类并未进行织入，Account 类也并未进行织入。</p><p><strong>第三步，运行</strong></p><p>从第二步我们可以看到，在运行之前，AspectJ 没有做任何的事情。</p><p>那么可以肯定的就是，AspectJ 会在运行期利用 aop.xml 中的配置进行织入处理。</p><p>在命令行中执行以下语句：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="params"> -jar</span> target/aspectj-learning-1.0-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>可以看到没有任何织入处理，然后执行以下语句再试试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="params"> -javaagent</span>:/Users/hongjie/.m2/repository/org/aspectj/aspectjweaver/1.8.13/aspectjweaver-1.8.13.jar<span class="params"> -jar</span> target/aspectj-learning-1.0-jar-with-dependencies.jar</span><br></pre></td></tr></table></figure><p>启动的时候指定了 <code>-javaagent:/.../aspectjweaver-1.8.13.jar</code>，然后再看输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">[ProfilingAspect]方法: 【boolean com.javadoop.aspectjlearning.model.Account.pay(int)】结束，用时: 1</span><br><span class="line">[ProfilingAspect]方法: 【boolean com.javadoop.aspectjlearning.model.Account.pay(int)】结束，用时: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>我们可以看到 ProfilingAspect 已经进行了织入处理，这就是 Load-time Weaving。</p><p>到这里，就要结束这一小节了，这里顺便再介绍下如果用 maven 跑测试的话怎么搞。</p><p>首先，我们往 surefire 插件中加上 javaagent：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">argLine</span>&gt;</span></span><br><span class="line">            -javaagent:/xxx/aspectjweaver-1.8.13.jar</span><br><span class="line">        <span class="tag">&lt;/<span class="name">argLine</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">useSystemClassLoader</span>&gt;</span>true<span class="tag">&lt;/<span class="name">useSystemClassLoader</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">forkMode</span>&gt;</span>always<span class="tag">&lt;/<span class="name">forkMode</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们就可以用 <code>mvn test</code> 看到织入效果了。还是那句话，不要用 IDE 进行测试，因为 IDE 太“智能”了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>AspectJ 的三种织入方式中，个人觉得前面的两种会比较实用一些，因为第三种需要修改启动脚本，对于大型公司来说会比较不友好，需要专门找运维人员配置。</p><p>在实际生产中，我们用得最多的还是纯 Spring AOP，通过本文的介绍，相信大家对于 AspectJ 的使用应该也没什么压力了。</p><p>大家如果对于本文介绍的内容有什么不清楚的，请直接在评论区留言，如果对于 Spring + AspectJ 感兴趣的读者，碰到问题也可以在评论区和大家互动讨论。</p><p>（全文完）</p><p><em>郑重声明</em>  :  <strong>本文转载自我关注的一位大佬的博客,<a href="https://www.javadoop.com/post/aspectj" target="_blank" rel="noopener">原文链接</a> ,如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;上一篇文章，我们介绍了 Spring  AOP 的各种用法，包括随着 Spring 的演进而发展出来的几种配置方式。&lt;/p&gt;
&lt;p&gt;但是我们始终没有使用到 AspectJ，即使是在基于注解的 @AspectJ 的配置方式中，Spring 也仅仅是使
      
    
    </summary>
    
    
      <category term="框架" scheme="https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="aop" scheme="https://www.enjoyican.com/tags/aop/"/>
    
      <category term="aspectj" scheme="https://www.enjoyican.com/tags/aspectj/"/>
    
  </entry>
  
  <entry>
    <title>转载-Spring-AOP使用介绍，从前世到今生</title>
    <link href="https://www.enjoyican.com/posts/Spring-aop/"/>
    <id>https://www.enjoyican.com/posts/Spring-aop/</id>
    <published>2020-03-16T15:21:00.000Z</published>
    <updated>2020-03-16T15:21:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面写过 Spring IOC 的源码分析，很多读者希望可以出一个 Spring AOP 的源码分析，不过 Spring AOP 的源码还是比较多的，写出来不免篇幅会大些。</p><p>本文不介绍源码分析，而是介绍 Spring AOP 中的一些概念，以及它的各种配置方法，涵盖了 Spring AOP 发展到现在出现的全部 3 种配置方式。</p><p>由于 Spring 强大的向后兼容性，实际代码中往往会出现很多配置混杂的情况，而且居然还能工作，本文希望帮助大家理清楚这些知识。</p><p>本文使用的测试源码已上传到 Github: <a href="https://github.com/hongjiev/spring-aop-learning" target="_blank" rel="noopener">hongjiev/spring-aop-learning</a>。</p><p><strong>目录：</strong></p><!-- toc --><h2 id="AOP-AspectJ-Spring-AOP"><a href="#AOP-AspectJ-Spring-AOP" class="headerlink" title="AOP, AspectJ, Spring AOP"></a>AOP, AspectJ, Spring AOP</h2><p>我们先来把它们的概念和关系说说清楚。</p><p>AOP 要实现的是在我们原来写的代码的基础上，进行一定的包装，如在方法执行前、方法返回后、方法抛出异常后等地方进行一定的拦截处理或者叫增强处理。</p><p>AOP 的实现并不是因为 Java 提供了什么神奇的钩子，可以把方法的几个生命周期告诉我们，而是我们要实现一个代理，实际运行的实例其实是生成的代理类的实例。</p><p>作为 Java 开发者，我们都很熟悉 <strong>AspectJ</strong> 这个词，甚至于我们提到 AOP 的时候，想到的往往就是 AspectJ，即使你可能不太懂它是怎么工作的。这里，我们把 AspectJ 和 Spring AOP 做个简单的对比：</p><p><strong>Spring AOP：</strong></p><ul><li><p>它基于动态代理来实现。默认地，如果使用接口的，用 JDK 提供的动态代理实现，如果没有接口，使用 CGLIB 实现。大家一定要明白背后的意思，包括什么时候会不用 JDK 提供的动态代理，而用 CGLIB 实现。</p></li><li><p>Spring 3.2 以后，spring-core 直接就把 CGLIB 和 ASM 的源码包括进来了，这也是为什么我们不需要显式引入这两个依赖</p></li><li><p>Spring 的 IOC 容器和 AOP 都很重要，Spring AOP 需要依赖于 IOC 容器来管理。</p></li><li><p>如果你是 web 开发者，有些时候，你可能需要的是一个 Filter 或一个 Interceptor，而不一定是 AOP。</p></li><li><p>Spring AOP 只能作用于 Spring 容器中的 Bean，它是使用纯粹的 Java 代码实现的，只能作用于 bean 的方法。</p></li><li><p>Spring 提供了 AspectJ 的支持，后面我们会单独介绍怎么使用，一般来说我们用<strong>纯的</strong> Spring AOP 就够了。</p></li><li><p>很多人会对比 Spring AOP 和 AspectJ 的性能，Spring AOP 是基于代理实现的，在容器启动的时候需要生成代理实例，在方法调用上也会增加栈的深度，使得 Spring AOP 的性能不如 AspectJ 那么好。</p></li></ul><p><strong>AspectJ：</strong></p><ul><li>AspectJ 出身也是名门，来自于 Eclipse 基金会，link：<a href="https://www.eclipse.org/aspectj" target="_blank" rel="noopener">https://www.eclipse.org/aspectj</a></li></ul><ul><li>属于静态织入，它是通过修改代码来实现的，它的织入时机可以是：<ul><li>Compile-time weaving：编译期织入，如类 A 使用 AspectJ 添加了一个属性，类 B 引用了它，这个场景就需要编译期的时候就进行织入，否则没法编译类 B。</li><li>Post-compile weaving：也就是已经生成了 .class 文件，或已经打成 jar 包了，这种情况我们需要增强处理的话，就要用到编译后织入。</li><li><strong>Load-time weaving</strong>：指的是在加载类的时候进行织入，要实现这个时期的织入，有几种常见的方法。1、自定义类加载器来干这个，这个应该是最容易想到的办法，在被织入类加载到 JVM 前去对它进行加载，这样就可以在加载的时候定义行为了。2、在 JVM 启动的时候指定 AspectJ 提供的 agent：<code>-javaagent:xxx/xxx/aspectjweaver.jar</code>。</li></ul></li></ul><ul><li><p>AspectJ 能干很多 Spring AOP 干不了的事情，它是 <strong>AOP 编程的完全解决方案</strong>。Spring AOP 致力于解决的是企业级开发中最普遍的 AOP 需求（方法织入），而不是力求成为一个像 AspectJ 一样的 AOP 编程完全解决方案。</p></li><li><p>因为 AspectJ 在实际代码运行前完成了织入，所以大家会说它生成的类是没有额外运行时开销的。</p></li><li><p><del>很快我会专门写一篇文章介绍 AspectJ 的使用，以及怎么在 Spring 应用中使用 AspectJ。</del></p><blockquote><p>已成文： <a href="https://www.enjoyican.com/posts/spring-aop-aspectj/">https://www.enjoyican.com/posts/spring-aop-aspectj/</a> </p></blockquote></li></ul><h2 id="AOP-术语解释"><a href="#AOP-术语解释" class="headerlink" title="AOP 术语解释"></a>AOP 术语解释</h2><p>在这里，不准备解释那么多 AOP 编程中的术语了，我们碰到一个说一个吧。</p><p>Advice、Advisor、Pointcut、Aspect、Joinpoint 等等。</p><h2 id="Spring-AOP"><a href="#Spring-AOP" class="headerlink" title="Spring AOP"></a>Spring AOP</h2><p>首先要说明的是，这里介绍的 Spring AOP 是纯的 Spring 代码，和 AspectJ 没什么关系，但是 Spring 延用了 AspectJ 中的概念，包括使用了 AspectJ 提供的 jar 包中的注解，但是不依赖于其实现功能。</p><blockquote><p>后面介绍的如 @Aspect、@Pointcut、@Before、@After 等注解都是来自于 AspectJ，但是功能的实现是纯 Spring AOP 自己实现的。</p></blockquote><p>下面我们来介绍 Spring AOP 的使用方法，先从最简单的配置方式开始说起，这样读者想看源码也会比较容易。</p><p>目前 Spring AOP 一共有三种配置方式，Spring 做到了很好地向下兼容，所以大家可以放心使用。</p><ul><li>Spring 1.2 <strong>基于接口的配置</strong>：最早的 Spring AOP 是完全基于几个接口的，想看源码的同学可以从这里起步。</li><li>Spring 2.0 <strong>schema-based 配置</strong>：Spring 2.0 以后使用 XML 的方式来配置，使用 命名空间 <code>&lt;aop /&gt;</code></li><li>Spring 2.0 <strong>@AspectJ 配置</strong>：使用注解的方式来配置，这种方式感觉是最方便的，还有，这里虽然叫做 <code>@AspectJ</code>，但是这个和 AspectJ 其实没啥关系。</li></ul><h3 id="Spring-1-2-中的配置"><a href="#Spring-1-2-中的配置" class="headerlink" title="Spring 1.2 中的配置"></a>Spring 1.2 中的配置</h3><p>这节我们将介绍 Spring 1.2 中的配置，这是最古老的配置，但是由于 Spring 提供了很好的向后兼容，以及很多人根本不知道什么配置是什么版本的，以及是否有更新更好的配置方法替代，所以还是会有很多代码是采用这种古老的配置方式的，这里说的古老并没有贬义的意思。</p><p>下面用一个简单的例子来演示怎么使用 Spring 1.2 的配置方式。</p><p>首先，我们先定义两个接口 <code>UserService</code> 和 <code>OrderService</code>，以及它们的实现类 <code>UserServiceImpl</code> 和 <code>OrderServiceImpl</code>：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/7.png" alt="示例" title="">                </div>                <div class="image-caption">示例</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/8.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>接下来，我们定义两个 <strong>advice</strong>，分别用于拦截<strong>方法执行前</strong>和<strong>方法返回后</strong>：</p><blockquote><p>advice 是我们接触的第一个概念，记住它是干什么用的。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/4.png" alt="advice" title="">                </div>                <div class="image-caption">advice</div>            </figure><p>上面的两个 Advice 分别用于方法调用前输出参数和方法调用后输出结果。</p><p>现在可以开始配置了，我们配置一个名为 <strong>spring_1_2.xml</strong> 的文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/5.png" alt="配置" title="">                </div>                <div class="image-caption">配置</div>            </figure><p>接下来，我们跑起来看看：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/6.png" alt="6" title="">                </div>                <div class="image-caption">6</div>            </figure><p>查看输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: createUser, 参数列表：[Tom, Cruise, 55]</span><br><span class="line">方法返回：User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br><span class="line">准备执行方法: queryUser, 参数列表：[]</span><br><span class="line">方法返回：User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看到，对 UserService 中的两个方法都做了前、后拦截。这个例子理解起来应该非常简单，就是一个代理实现。</p><blockquote><p>代理模式需要一个接口、一个具体实现类，然后就是定义一个代理类，用来包装实现类，添加自定义逻辑，在使用的时候，需要用代理类来生成实例。</p></blockquote><p>此中方法有个致命的问题，如果我们需要拦截 OrderService 中的方法，那么我们还需要定义一个 OrderService 的代理。如果还要拦截 PostService，得定义一个 PostService 的代理……</p><p>而且，我们看到，我们的拦截器的粒度只控制到了类级别，类中所有的方法都进行了拦截。接下来，我们看看怎么样<strong>只拦截特定的方法</strong>。</p><p>在上面的配置中，配置拦截器的时候，interceptorNames 除了指定为 Advice，是还可以指定为 Interceptor 和 Advisor 的。</p><p>这里我们来理解 <strong>Advisor</strong> 的概念，它也比较简单，<strong>它内部需要指定一个 Advice</strong>，Advisor 决定该拦截哪些方法，拦截后需要完成的工作还是内部的 Advice 来做。</p><p>它有好几个实现类，这里我们使用实现类 <strong>NameMatchMethodPointcutAdvisor</strong> 来演示，从名字上就可以看出来，它需要我们给它提供方法名字，这样符合该配置的方法才会做拦截。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/1.png" alt="配置" title="">                </div>                <div class="image-caption">配置</div>            </figure><blockquote><p>我们可以看到，userServiceProxy 这个 bean 配置了一个 advisor，advisor 内部有一个 advice。advisor 负责匹配方法，内部的 advice 负责实现方法包装。</p><p>注意，这里的 mappedNames 配置是可以指定多个的，用逗号分隔，可以是不同类中的方法。相比直接指定 advice，advisor 实现了更细粒度的控制，因为在这里配置 advice 的话，所有方法都会被拦截。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/2.png" alt="测试" title="">                </div>                <div class="image-caption">测试</div>            </figure><p>输出结果如下，只有 createUser 方法被拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: createUser, 参数列表：[Tom, Cruise, 55]</span><br></pre></td></tr></table></figure><p>到这里，我们已经了解了 <strong>Advice</strong> 和 <strong>Advisor</strong> 了，前面也说了还可以配置 <strong>Interceptor</strong>。</p><p>对于 Java 开发者来说，对 Interceptor 这个概念肯定都很熟悉了，这里就不做演示了，贴一下实现代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DebugInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Before: invocation=["</span> + invocation + <span class="string">"]"</span>);</span><br><span class="line">        <span class="comment">// 执行 真实实现类 的方法</span></span><br><span class="line">        Object rval = invocation.proceed();</span><br><span class="line">        System.out.println(<span class="string">"Invocation returned"</span>);</span><br><span class="line">        <span class="keyword">return</span> rval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面，我们介绍完了 <strong>Advice、Advisor、Interceptor</strong> 三个概念，相信大家应该很容易就看懂它们了。</p><p>它们有个共同的问题，那就是我们得为每个 bean 都配置一个代理，之后获取 bean 的时候需要获取这个代理类的 bean 实例（如 <code>(UserService) context.getBean(&quot;userServiceProxy&quot;)</code>），这显然非常不方便，不利于我们之后要使用的自动根据类型注入。下面介绍 autoproxy 的解决方案。</p><p><strong>autoproxy</strong>：从名字我们也可以看出来，它是实现自动代理，也就是说当 Spring 发现一个 bean 需要被切面织入的时候，Spring 会自动生成这个 bean 的一个代理来拦截方法的执行，确保定义的切面能被执行。</p><p>这里强调<strong>自动</strong>，也就是说 Spring 会自动做这件事，而不用像前面介绍的，我们需要显式地指定代理类的 bean。</p><p>我们去掉原来的 <strong>ProxyFactoryBean</strong> 的配置，改为使用 <strong>BeanNameAutoProxyCreator</strong> 来配置：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/9.png" alt="BeanNameAutoProxyCreator" title="">                </div>                <div class="image-caption">BeanNameAutoProxyCreator</div>            </figure><p>配置很简单，beanNames 中可以使用正则来匹配 bean 的名字。这样配置出来以后，userServiceBeforeAdvice 和 userServiceAfterAdvice 这两个拦截器就不仅仅可以作用于 UserServiceImpl 了，也可以作用于 OrderServiceImpl、PostServiceImpl、ArticleServiceImpl……等等，也就是说不再是配置某个 bean 的代理了。</p><blockquote><p>注意，这里的 InterceptorNames 和前面一样，也是可以配置成 Advisor 和 Interceptor 的。</p></blockquote><p>然后我们修改下使用的地方：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/10.png" alt="测试" title="">                </div>                <div class="image-caption">测试</div>            </figure><p>发现没有，<strong>我们在使用的时候，完全不需要关心代理了</strong>，直接使用原来的类型就可以了，这是非常方便的。</p><p>输出结果就是 OrderService 和 UserService 中的每个方法都得到了拦截：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: createUser, 参数列表：[Tom, Cruise, 55]</span><br><span class="line">方法返回：User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br><span class="line">准备执行方法: queryUser, 参数列表：[]</span><br><span class="line">方法返回：User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br><span class="line">准备执行方法: createOrder, 参数列表：[Leo, 随便买点什么]</span><br><span class="line">方法返回：Order&#123;username&#x3D;&#39;Leo&#39;, product&#x3D;&#39;随便买点什么&#39;&#125;</span><br><span class="line">准备执行方法: queryOrder, 参数列表：[Leo]</span><br><span class="line">方法返回：Order&#123;username&#x3D;&#39;Leo&#39;, product&#x3D;&#39;随便买点什么&#39;&#125;</span><br></pre></td></tr></table></figure><p>到这里，是不是发现 BeanNameAutoProxyCreator 非常好用，它需要指定被拦截类名的模式(如 *ServiceImpl)，它可以配置多次，这样就可以用来匹配不同模式的类了。</p><p>另外，在 BeanNameAutoProxyCreator 同一个包中，还有一个非常有用的类 <strong>DefaultAdvisorAutoProxyCreator</strong>，比上面的 BeanNameAutoProxyCreator 还要方便。</p><p>之前我们说过，advisor 内部包装了 advice，advisor 负责决定拦截哪些方法，内部 advice 定义拦截后的逻辑。所以，仔细想想其实就是只要让我们的 advisor 全局生效就能实现我们需要的自定义拦截功能、拦截后的逻辑处理。</p><blockquote><p>BeanNameAutoProxyCreator 是自己匹配方法，然后交由内部配置 advice 来拦截处理；</p><p>而 DefaultAdvisorAutoProxyCreator 是让 ioc 容器中的所有 advisor 来匹配方法，advisor 内部都是有 advice 的，让它们内部的 advice 来执行拦截处理。</p></blockquote><p>1、我们需要再回头看下 Advisor 的配置，上面我们用了 NameMatchMethodPointcutAdvisor 这个类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"logCreateAdvisor"</span> <span class="attr">class</span>=<span class="string">"org.springframework.aop.support.NameMatchMethodPointcutAdvisor"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"advice"</span> <span class="attr">ref</span>=<span class="string">"logArgsAdvice"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mappedNames"</span> <span class="attr">value</span>=<span class="string">"createUser,createOrder"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其实 Advisor 还有一个更加灵活的实现类 <strong>RegexpMethodPointcutAdvisor</strong>，它能实现正则匹配，如：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"logArgsAdvisor"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.support.RegexpMethodPointcutAdvisor"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"advice"</span> ref=<span class="string">"logArgsAdvice"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"pattern"</span> value=<span class="string">"com.javadoop.*.service.*.create.*"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>也就是说，我们能通过配置 Advisor，精确定位到需要被拦截的方法，然后使用内部的 Advice 执行逻辑处理。</p><p>2、之后，我们需要配置 DefaultAdvisorAutoProxyCreator，它的配置非常简单，直接使用下面这段配置就可以了，它就会使得<strong>所有的 Advisor 自动生效</strong>，无须其他配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"</span> /&gt;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/11.png" alt="DefaultAdvisorAutoProxyCreator" title="">                </div>                <div class="image-caption">DefaultAdvisorAutoProxyCreator</div>            </figure><p>然后我们运行一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/12.png" alt="测试" title="">                </div>                <div class="image-caption">测试</div>            </figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">准备执行方法: createUser, 参数列表：[Tom, Cruise, 55]</span><br><span class="line">方法返回：User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br><span class="line">准备执行方法: createOrder, 参数列表：[Leo, 随便买点什么]</span><br><span class="line">方法返回：Order&#123;username&#x3D;&#39;Leo&#39;, product&#x3D;&#39;随便买点什么&#39;&#125;</span><br></pre></td></tr></table></figure><p>从结果可以看出，create* 方法使用了 logArgsAdvisor 进行传参输出，query* 方法使用了 logResultAdvisor 进行了返回结果输出。</p><p>到这里，Spring 1.2 的配置就要介绍完了。本文不会介绍得面面俱到，主要是关注最核心的配置，如果读者感兴趣，要学会自己去摸索，比如这里的 Advisor 就不只有我这里介绍的 NameMatchMethodPointcutAdvisor 和 RegexpMethodPointcutAdvisor，AutoProxyCreator 也不仅仅是 BeanNameAutoProxyCreator 和 DefaultAdvisorAutoProxyCreator。</p><blockquote><p>读到这里，我想对于很多人来说，就知道怎么去阅读 Spring AOP 源码了。</p></blockquote><h3 id="Spring-2-0-AspectJ-配置"><a href="#Spring-2-0-AspectJ-配置" class="headerlink" title="Spring 2.0 @AspectJ 配置"></a>Spring 2.0 @AspectJ 配置</h3><p>Spring 2.0 以后，引入了 @AspectJ 和 Schema-based 的两种配置方式，我们先来介绍 @AspectJ 的配置方式，之后我们再来看使用 xml 的配置方式。</p><p>注意了，<strong>@AspectJ 和 AspectJ 没多大关系</strong>，并不是说基于 AspectJ 实现的，而仅仅是使用了 AspectJ 中的概念，包括使用的注解也是直接来自于 AspectJ 的包。</p><p>首先，我们需要依赖 <code>aspectjweaver.jar</code> 这个包，这个包来自于 AspectJ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.8.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果是使用 Spring Boot 的话，添加以下依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 @AspectJ 的配置方式中，之所以要引入 aspectjweaver 并不是因为我们需要使用 AspectJ 的处理功能，而是因为 Spring 使用了 AspectJ 提供的一些注解，实际上<strong>还是纯的 Spring AOP 代码</strong>。</p><p>说了这么多，明确一点，@AspectJ 采用注解的方式来配置使用 Spring AOP。</p><p>首先，我们需要<strong>开启</strong> @AspectJ 的注解配置方式，有两种方式：</p><p>1、在 xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>使用 @EnableAspectJAutoProxy </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦开启了上面的配置，那么所有使用 @Aspect 注解的 <strong>bean</strong> 都会被 Spring 当做<strong>用来实现 AOP 的配置类</strong>，我们称之为一个 <strong>Aspect</strong>。</p><blockquote><p>注意了，@Aspect 注解要作用在 bean 上面，不管是使用 @Component 等注解方式，还是在 xml 中配置 bean，首先它需要是一个 bean。</p></blockquote><p>比如下面这个 bean，它的类名上使用了 @Aspect，它就会被当做 Spring AOP 的配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">class</span>=<span class="string">"org.xyz.NotVeryUsefulAspect"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- configure properties of aspect here as normal --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.xyz;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotVeryUsefulAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们需要关心的是 @Aspect 注解的 bean 中，我们需要配置哪些内容。</p><p><strong>首先，我们需要配置 Pointcut，</strong>Pointcut 在大部分地方被翻译成切点，用于定义哪些方法需要被增强或者说需要被拦截，有点类似于之前介绍的 <strong>Advisor</strong> 的方法匹配。</p><p>Spring AOP 只支持 bean 中的方法（不像 AspectJ 那么强大），所以我们可以认为 <strong>Pointcut</strong> 就是用来匹配 Spring 容器中的所有 bean 的方法的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)<span class="comment">// the pointcut expression</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span> </span>&#123;&#125;<span class="comment">// the pointcut signature</span></span><br></pre></td></tr></table></figure><p>我们看到，@Pointcut 中使用了 <strong>execution</strong> 来正则匹配方法签名，这也是最常用的，除了 execution，我们再看看其他的几个比较常用的匹配方式：</p><ul><li><p>within：指定所在类或所在包下面的方法（Spring AOP 独有）</p><blockquote><p>如 @Pointcut(“within(com.javadoop.springaoplearning.service..*)”)</p></blockquote></li><li><p>@annotation：方法上具有特定的注解，如 @Subscribe 用于订阅特定的事件。</p><blockquote><p>如 @Pointcut(“execution(* <em>.</em>(..)) &amp;&amp; @annotation(com.javadoop.annotation.Subscribe)”)</p></blockquote></li><li><p>bean(idOrNameOfBean)：匹配 bean 的名字（Spring AOP 独有）</p><blockquote><p>如 @Pointcut(“bean(*Service)”)</p></blockquote></li></ul><p>Tips：上面匹配中，通常 “.” 代表一个包名，”..” 代表包及其子包，方法参数任意匹配使用两个点 “..”。</p><p>对于 web 开发者，Spring 有个很好的建议，就是定义一个 <strong>SystemArchitecture</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// web 层</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.javadoop.web..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inWebLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service 层</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.javadoop.service..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inServiceLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dao 层</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"within(com.javadoop.dao..*)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inDataAccessLayer</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// service 实现，注意这里指的是方法实现，其实通常也可以使用 bean(*ServiceImpl)</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javadoop..service.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">businessService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dao 实现</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.javadoop.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataAccessOperation</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个 SystemArchitecture 很好理解，该 Aspect 定义了一堆的 Pointcut，随后在任何需要 Pointcut 的地方都可以直接引用（如 xml 中的 pointcut-ref=””）。</p><p>配置 pointcut 就是配置我们需要拦截哪些方法，接下来，我们要配置需要对这些被拦截的方法做什么，也就是前面介绍的 Advice。</p><p><strong>接下来，我们要配置 Advice。</strong></p><p>下面这块代码示例了各种常用的情况：</p><blockquote><p>注意，实际写代码的时候，不要把所有的切面都揉在一个 class 中。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdviceExample</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里会用到我们前面说的 SystemArchitecture</span></span><br><span class="line">    <span class="comment">// 下面方法就是写拦截 "dao层实现"</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当然，我们也可以直接"内联"Pointcut，直接在这里定义 Pointcut</span></span><br><span class="line">    <span class="comment">// 把 Advice 和 Pointcut 合在一起了，但是这两个概念我们还是要区分清楚的</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.javadoop.dao.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(</span><br><span class="line">        pointcut=<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>,</span><br><span class="line">        returning=<span class="string">"retVal"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这样，进来这个方法的处理时候，retVal 就是相应方法的返回值，是不是非常方便</span></span><br><span class="line">        <span class="comment">//  ... 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异常返回</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@AfterThrowing</span>(</span><br><span class="line">        pointcut=<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>,</span><br><span class="line">        throwing=<span class="string">"ex"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ... 实现代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注意理解它和 @AfterReturning 之间的区别，这里会拦截正常返回和异常的情况</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"com.javadoop.aop.SystemArchitecture.dataAccessOperation()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通常就像 finally 块一样使用，用来释放资源。</span></span><br><span class="line">        <span class="comment">// 无论正常返回还是异常退出，都会被拦截到</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 感觉这个很有用吧，既能做 @Before 的事情，也可以做 @AfterReturning 的事情</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"com.javadoop.aop.SystemArchitecture.businessService()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// start stopwatch</span></span><br><span class="line">        Object retVal = pjp.proceed();</span><br><span class="line">        <span class="comment">// stop stopwatch</span></span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的读者可能发现了有些 Advice 缺少方法传参，如在 @Before 场景中参数往往是非常有用的，比如我们要用日志记录下来被拦截方法的入参情况。</p><p>Spring 提供了非常简单的获取入参的方法，使用 org.aspectj.lang.JoinPoint 作为 Advice 的第一个参数即可，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"com.javadoop.springaoplearning.aop_spring_2_aspectj.SystemArchitecture.businessService()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logArgs</span><span class="params">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法执行前，打印入参："</span> + Arrays.toString(joinPoint.getArgs()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：第一，必须放置在第一个参数上；第二，如果是 @Around，我们通常会使用其子类 ProceedingJoinPoint，因为它有 procceed()/procceed(args[]) 方法。</p></blockquote><p>到这里，我们介绍完了 @AspectJ 配置方式中的 <strong>Pointcut</strong> 和 <strong>Advice</strong> 的配置。对于开发者来说，其实最重要的就是这两个了，定义 Pointcut 和使用合适的 Advice 在各个 Pointcut 上。</p><p>下面，我们用这一节介绍的 @AspectJ 来实现上一节实现的<strong>记录方法传参</strong>和<strong>记录方法返回值</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/13.png" alt="示例" title="">                </div>                <div class="image-caption">示例</div>            </figure><p>xml 的配置非常简单：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/14.png" alt="配置" title="">                </div>                <div class="image-caption">配置</div>            </figure><blockquote><p>这里是示例，所以 bean 的配置还是使用了 xml 的配置方式。</p></blockquote><p>测试一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/15.png" alt="测试" title="">                </div>                <div class="image-caption">测试</div>            </figure><p>输出结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">方法执行前，打印入参：[Tom, Cruise, 55]</span><br><span class="line">User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br><span class="line">方法执行前，打印入参：[]</span><br><span class="line">User&#123;firstName&#x3D;&#39;Tom&#39;, lastName&#x3D;&#39;Cruise&#39;, age&#x3D;55, address&#x3D;&#39;null&#39;&#125;</span><br></pre></td></tr></table></figure><p>JoinPoint 除了 getArgs() 外还有一些有用的方法，大家可以进去稍微看一眼。</p><p>最后提一点，@Aspect 中的配置不会作用于使用 @Aspect 注解的 bean。</p><h3 id="Spring-2-0-schema-based-配置"><a href="#Spring-2-0-schema-based-配置" class="headerlink" title="Spring 2.0 schema-based 配置"></a>Spring 2.0 schema-based 配置</h3><p>本节将介绍的是 Spring 2.0 以后提供的基于 <code>&lt;aop /&gt;</code> 命名空间的 XML 配置。这里说的 schema-based 就是指基于 <code>aop</code>  这个 schema。</p><blockquote><p>介绍 IOC 的时候也介绍过 Spring 是怎么解析各个命名空间的（各种 *NamespaceHandler），解析 <code>&lt;aop /&gt;</code> 的源码在 org.springframework.aop.config.AopNamespaceHandler 中。</p></blockquote><p>有了前面的 @AspectJ 的配置方式的知识，理解 xml 方式的配置非常简单，所以我们就可以废话少一点了。</p><p>这里先介绍<strong>配置 Aspect</strong>，便于后续理解：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"myAspect"</span> <span class="attr">ref</span>=<span class="string">"aBean"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"aBean"</span> <span class="attr">class</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>所有的配置都在 <code>&lt;aop:config&gt;</code> 下面。</p><p><code>&lt;aop:aspect &gt;</code> 中需要指定一个 bean，和前面介绍的 LogArgsAspect  和 LogResultAspect 一样，我们知道该 bean 中我们需要写处理代码。</p><p>然后，我们写好 Aspect 代码后，将其“织入”到合适的 Pointcut 中，这就是面向切面。</p></blockquote><p>然后，我们需要<strong>配置 Pointcut</strong>，非常简单，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"businessService"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">"execution(* com.javadoop.springaoplearning.service.*.*(..))"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--也可以像下面这样--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"businessService2"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">expression</span>=<span class="string">"com.javadoop.SystemArchitecture.businessService()"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>将 <code>&lt;aop:pointcut&gt;</code> 作为 <code>&lt;aop:config&gt;</code> 的直接子元素，将作为全局 Pointcut。</p></blockquote><p>我们也可以在 <code>&lt;aop:aspect /&gt;</code>内部配置 Pointcut，这样该 Pointcut 仅用于该 Aspect：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">"logArgsAspect"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"internalPointcut"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">"com.javadoop.SystemArchitecture.businessService()"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来，我们应该配置 <strong>Advice</strong> 了，为了避免废话过多，我们直接上实例吧，非常好理解，将上一节用 @AspectJ 方式配置的搬过来：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-aop/16.png" alt="16" title="">                </div>                <div class="image-caption">16</div>            </figure><p>上面的例子中，我们配置了两个 LogArgsAspect 和一个 LogResultAspect。</p><p>其实基于 XML 的配置也是非常灵活的，这里没办法给大家演示各种搭配，大家抓住基本的 Pointcut、Advice 和 Aspect 这几个概念，就很容易配置了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>到这里，本文介绍了 Spring AOP 的三种配置方式，我们要知道的是，到目前为止，我们使用的都是 Spring AOP，和 AspectJ 没什么关系。</p><p>下一篇文章，将会介绍 AspectJ 的使用方式，以及怎样在 Spring 应用中使用 AspectJ。之后差不多就可以出 Spring AOP 源码分析了。</p><p>《<a href="https://www.enjoyican.com/posts/spring-aop-aspectj">AspectJ 使用介绍</a>》介绍了 AspectJ 的 3 种用法，感兴趣的读者可以去看一看，那篇文章稍微短一些。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>本文使用的测试源码已上传到 Github: <a href="https://github.com/hongjiev/spring-aop-learning" target="_blank" rel="noopener">hongjiev/spring-aop-learning</a>。</p><p>建议读者 clone 下来以后，通过命令行进行测试，而不是依赖于 IDE，因为 IDE 太”智能”了：</p><ol><li><p>mvn clean package</p></li><li><p>java -jar target/spring-aop-learning-1.0-jar-with-dependencies.jar</p><blockquote><p>pom.xml 中配置了 assembly 插件，打包的时候会将所有 jar 包依赖打到一起。</p></blockquote></li><li><p>修改 Application.java 中的代码，或者其他代码，然后重复 1 和 2</p></li></ol><p>（全文完）</p><p><em>郑重声明</em>  :  <strong>本文转载自我关注的一位大佬的博客,<a href="https://www.javadoop.com/post/spring-aop-intro" target="_blank" rel="noopener">原文链接</a> ,如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面写过 Spring IOC 的源码分析，很多读者希望可以出一个 Spring AOP 的源码分析，不过 Spring AOP 的源码还是比较多的，写出来不免篇幅会大些。&lt;/p&gt;
&lt;p&gt;本文不介绍源码分析，而是介绍 Spring AOP 中的一些概念，以及它的各种配置方法
      
    
    </summary>
    
    
      <category term="框架" scheme="https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://www.enjoyican.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>基于hexo博客搭建tips</title>
    <link href="https://www.enjoyican.com/posts/blog-byhexo-tips/"/>
    <id>https://www.enjoyican.com/posts/blog-byhexo-tips/</id>
    <published>2020-03-12T02:08:30.000Z</published>
    <updated>2020-03-12T02:08:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p>基于hexo搭建博客的教程,网上很多,这里不再赘述,不同主题适配有不同的坑需要踩,因人而异,下面给出一些教程链接:</p><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官方主页中文版</a></p><p><a href="https://www.jianshu.com/p/cb0750324e26" target="_blank" rel="noopener">使用Hexo搭建GitHub博客</a></p><p><a href="https://blog.csdn.net/wistbean/article/details/82291124" target="_blank" rel="noopener">使用hexo搭建个人博客网站最完整详细教程</a></p><p>按照上述教程搭建过程中如遇到报错异常,一般网上搜索都是能搜索到原因的,针对修改即可.博客搭建完成后,你有两种方式访问自己的博客:</p><ul><li><p>自己有服务器,但是没有域名:   </p><p>首先上传新写好的一篇文档之后执行<code>hexo g</code>,<code>hexo s</code>发布文章启动博客之后,就可以在浏览器通过IP:4000(hexo默认端口)访问到自己的博客,但是这种访问方式一方面浏览器地址看着不舒服,另一方面通过<code>hexo s</code>在服务器启动之后,没办法退出当前命令行,ctrl+C之后就自动退出了,访问不了了,通过<code>hexo s&amp;</code>启动,可以让博客后台运行,短暂解放你的命令行,可以让你去执行别的命令,但是这个线程过一会儿就死亡了,又访问不了了.</p></li><li><p>自己没有服务器,基于github搭建:</p><p>基于github搭建的,当你执行<code>hexo g</code> <code>hexo d</code>发布到远程仓库之后你可以通过https: yourgithubusername.github.io访问你的博客,但是github访问有可能比较慢,此外github屏蔽了百度搜索,这个博客内容只能孤芳自赏了.所以接下来就想到申请域名,通过自己服务器搭建博客.</p></li></ul><h3 id="申请域名备案"><a href="#申请域名备案" class="headerlink" title="申请域名备案"></a>申请域名备案</h3><p>因为我自己平时有自用的阿里云服务器,没有域名,所以这一步我只需要在阿里云上申请域名并备案即可,域名的申请国内外网站都可以,我不想在后面与阿里云服务器匹配的时候遇到各种坑所以直接在阿里云上注册了一个域名,三年193RMB,注册成功后提交阿里云初审,<strong>自2019年7月29日起，根据管局对备案真实性的要求，阿里云备案流程中使用移动端进行活体检测保障真实性，幕布拍照方式不再使用,直接在app上人脸识别后上传照片即可</strong>不过人脸识别的时候请稍微收拾下,我当时人脸识别的时候没想到后面会用这张照片申请备案所以大半夜12点穿着睡衣,睡眼惺忪拍了张照,后面也懒得替换了,所以就用一张挫照提交备案申请了.</p><p>备案时阿里云会进行初审,<strong>注意网站名称不要出现博客,空间等字样,这些字样不在工信部备案支持内容里,具体可以上阿里云查询,不过就算填错,阿里云初审同学会提醒你修改</strong></p><p>初审用了1个工作日,之后就是阿里云提交工信部审核,我的个人网站审核特别快,一天就通过了,之前一直以为要15-20天,必须给浙江工信部点个赞.</p><p>备案完成后,按照相关指示修改你的博客js文件,将要求的备案号放在你网站的底部并链接到对应网址.</p><h3 id="用nginx做静态资源服务器"><a href="#用nginx做静态资源服务器" class="headerlink" title="用nginx做静态资源服务器"></a>用nginx做静态资源服务器</h3><p>域名有了,在阿里云控制台指向你的服务器ip之后,就可以通过nginx访问博客静态资源了.因为前述<code>hexo g</code>的执行就是在对应的public文件夹下生成静态html等文件资源,所以我们可以通过nginx访问,就不再需要后台启动hexo了.</p><ul><li><p>安装nginx,网上教程很多,搜索即可,安装很快</p></li><li><p>配置nginx配置文件,将root根目录配置如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       <span class="number">80</span>;</span><br><span class="line">        server_name  enjoyican.com www.enjoyican.com;</span><br><span class="line">        </span><br><span class="line">        location / &#123;</span><br><span class="line">            # root目录配置为你的博客路径下的public文件夹</span><br><span class="line">            root   /usr/soft/hexo/public/;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>这样配置并重启nginx之后就可以通过域名访问你的博客资源了,但是在浏览器访问的时候会显示不安全字样,看着不舒服,所以接下来就是<strong>配置https,以及将http的请求转发到https上</strong>,具体的配置可以参考如下链接:</p><p><a href="https://segmentfault.com/a/1190000019438227" target="_blank" rel="noopener">个人网站升级http为https</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;搭建&quot;&gt;&lt;a href=&quot;#搭建&quot; class=&quot;headerlink&quot; title=&quot;搭建&quot;&gt;&lt;/a&gt;搭建&lt;/h3&gt;&lt;p&gt;基于hexo搭建博客的教程,网上很多,这里不再赘述,不同主题适配有不同的坑需要踩,因人而异,下面给出一些教程链接:&lt;/p&gt;
&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="tips" scheme="https://www.enjoyican.com/categories/tips/"/>
    
    
      <category term="hexo" scheme="https://www.enjoyican.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>转载-Spring IOC 容器源码分析</title>
    <link href="https://www.enjoyican.com/posts/Spring-IOC/"/>
    <id>https://www.enjoyican.com/posts/Spring-IOC/</id>
    <published>2020-03-08T15:15:46.000Z</published>
    <updated>2020-03-08T15:15:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 的很多概念，帮助大家排查应用中和 Spring 相关的一些问题。</p><p>本文采用的源码版本是 4.3.11.RELEASE，算是 5.0.x 前比较新的版本了。为了降低难度，本文所说的所有的内容都是基于 xml 的配置的方式，实际使用已经很少人这么做了，至少不是纯 xml 配置，不过从理解源码的角度来看用这种方式来说无疑是最合适的。</p><p>阅读建议：读者至少需要知道怎么配置 Spring，了解 Spring 中的各种概念，少部分内容我还假设读者使用过 SpringMVC。本文要说的 IOC 总体来说有两处地方最重要，一个是创建 Bean 容器，一个是初始化 Bean，如果读者觉得一次性看完本文压力有点大，那么可以按这个思路分两次消化。读者不一定对 Spring 容器的源码感兴趣，也许附录部分介绍的知识对读者有些许作用。</p><p>希望通过本文可以让读者不惧怕阅读 Spring 源码，也希望大家能反馈表述错误或不合理的地方。</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>先看下最基本的启动 Spring 容器的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationfile.xml"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就可以利用配置文件来启动一个 Spring 容器了，请使用 maven 的小伙伴直接在 dependencies 中加上以下依赖即可，个人比较反对那些不知道要添加什么依赖，然后把 Spring 的所有相关的东西都加进来的方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><blockquote><p>spring-context 会自动将 spring-core、spring-beans、spring-aop、spring-expression 这几个基础 jar 包带进来。</p></blockquote><p>多说一句，很多开发者入门就直接接触的 SpringMVC，对 Spring 其实不是很了解，Spring 是渐进式的工具，并不具有很强的侵入性，它的模块也划分得很合理，即使你的应用不是 web 应用，或者之前完全没有使用到 Spring，而你就想用 Spring 的依赖注入这个功能，其实完全是可以的，它的引入不会对其他的组件产生冲突。</p><p>废话说完，我们继续。<code>ApplicationContext context = new ClassPathXmlApplicationContext(...)</code> 其实很好理解，从名字上就可以猜出一二，就是在 ClassPath 中寻找 xml 配置文件，根据 xml 文件内容来构建 ApplicationContext。当然，除了 ClassPathXmlApplicationContext 以外，我们也还有其他构建 ApplicationContext 的方案可供选择，我们先来看看大体的继承结构是怎么样的：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-ioc/1.png" alt="1" title="">                </div>                <div class="image-caption">1</div>            </figure><blockquote><p>读者可以大致看一下类名，源码分析的时候不至于找不着看哪个类，因为 Spring 为了适应各种使用场景，提供的各个接口都可能有很多的实现类。对于我们来说，就是揪着一个完整的分支看完。</p><p>当然，读本文的时候读者也不必太担心，每个代码块分析的时候，我都会告诉读者我们在说哪个类第几行。</p></blockquote><p>我们可以看到，ClassPathXmlApplicationContext 兜兜转转了好久才到 ApplicationContext 接口，同样的，我们也可以使用绿颜色的 <strong>FileSystemXmlApplicationContext</strong> 和 <strong>AnnotationConfigApplicationContext</strong> 这两个类。</p><p><strong>1、FileSystemXmlApplicationContext</strong> 的构造函数需要一个 xml 配置文件在系统中的路径，其他和 ClassPathXmlApplicationContext 基本上一样。</p><p><strong>2、AnnotationConfigApplicationContext</strong> 是基于注解来使用的，它不需要配置文件，采用 java 配置类和各种注解来配置，是比较简单的方式，也是大势所趋吧。</p><p>不过本文旨在帮助大家理解整个构建流程，所以决定使用 ClassPathXmlApplicationContext 进行分析。</p><p>我们先来一个简单的例子来看看怎么实例化 ApplicationContext。</p><p>首先，定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义接口实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello world"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们在 <strong>resources</strong> 目录新建一个配置文件，文件名随意，通常叫 application.xml 或 application-xxx.xml 就可以了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span> <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，我们就可以跑起来了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 用我们的配置文件来启动一个 ApplicationContext</span></span><br><span class="line">        ApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:application.xml"</span>);</span><br><span class="line">      </span><br><span class="line">        System.out.println(<span class="string">"context 启动成功"</span>);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 从 context 中取出我们的 Bean，而不是用 new MessageServiceImpl() 这种方式</span></span><br><span class="line">        MessageService messageService = context.getBean(MessageService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">// 这句将输出: hello world</span></span><br><span class="line">        System.out.println(messageService.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子很简单，不过也够引出本文的主题了，就是怎么样通过配置文件来启动 Spring 的 ApplicationContext ？也就是我们今天要分析的 IOC 的核心了。ApplicationContext 启动过程中，会负责创建实例 Bean，往各个 Bean 中注入依赖等。</p><h2 id="BeanFactory-简介"><a href="#BeanFactory-简介" class="headerlink" title="BeanFactory 简介"></a>BeanFactory 简介</h2><p>BeanFactory，从名字上也很好理解，生产 bean 的工厂，它负责生产和管理各个 bean 实例。</p><p>初学者可别以为我之前说那么多和 BeanFactory 无关，前面说的 ApplicationContext 其实就是一个 BeanFactory。我们来看下和 BeanFactory 接口相关的主要的继承结构：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-ioc/2.png" alt="2" title="">                </div>                <div class="image-caption">2</div>            </figure><p>我想，大家看完这个图以后，可能就不是很开心了。ApplicationContext 往下的继承结构前面一张图说过了，这里就不重复了。这张图呢，背下来肯定是不需要的，有几个重点和大家说明下就好。</p><ol><li>ApplicationContext 继承了 ListableBeanFactory，这个 Listable 的意思就是，通过这个接口，我们可以获取多个 Bean，大家看源码会发现，最顶层 BeanFactory 接口的方法都是获取单个 Bean 的。</li><li>ApplicationContext 继承了 HierarchicalBeanFactory，Hierarchical 单词本身已经能说明问题了，也就是说我们可以在应用中起多个 BeanFactory，然后可以将各个 BeanFactory 设置为父子关系。</li><li>AutowireCapableBeanFactory 这个名字中的 Autowire 大家都非常熟悉，它就是用来自动装配 Bean 用的，但是仔细看上图，ApplicationContext 并没有继承它，不过不用担心，不使用继承，不代表不可以使用组合，如果你看到 ApplicationContext 接口定义中的最后一个方法 getAutowireCapableBeanFactory() 就知道了。</li><li>ConfigurableListableBeanFactory 也是一个特殊的接口，看图，特殊之处在于它继承了第二层所有的三个接口，而 ApplicationContext 没有。这点之后会用到。</li><li>请先不用花时间在其他的接口和类上，先理解我说的这几点就可以了。</li></ol><p>然后，请读者打开编辑器，翻一下 BeanFactory、ListableBeanFactory、HierarchicalBeanFactory、AutowireCapableBeanFactory、ApplicationContext 这几个接口的代码，大概看一下各个接口中的方法，大家心里要有底，限于篇幅，我就不贴代码介绍了。</p><h2 id="启动过程分析"><a href="#启动过程分析" class="headerlink" title="启动过程分析"></a>启动过程分析</h2><p>下面将会是冗长的代码分析，记住，一定要自己打开源码来看，不然纯看是很累的。</p><p>第一步，我们肯定要从 ClassPathXmlApplicationContext 的构造方法说起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">extends</span> <span class="title">AbstractXmlApplicationContext</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Resource[] configResources;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果已经有 ApplicationContext 并需要配置成父子关系，那么调用这个构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(ApplicationContext parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>(parent);</span><br><span class="line">    <span class="comment">// 根据提供的路径，处理成配置文件数组(以分号、逗号、空格、tab、换行符分割)</span></span><br><span class="line">    setConfigLocations(configLocations);</span><br><span class="line">    <span class="keyword">if</span> (refresh) &#123;</span><br><span class="line">      refresh(); <span class="comment">// 核心方法</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，就是 <code>refresh()</code>，这里简单说下为什么是 refresh()，而不是 init() 这种名字的方法。因为 ApplicationContext 建立起来以后，其实我们是可以通过调用 refresh() 这个方法重建的，refresh() 会将原来的 ApplicationContext 销毁，然后再重新执行一次初始化操作。</p><p>往下看，refresh() 方法里面调用了那么多方法，就知道肯定不简单了，请读者先看个大概，细节之后会详细说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面，我们开始一步步来肢解这个 refresh() 方法。</p><h3 id="创建-Bean-容器前的准备工作"><a href="#创建-Bean-容器前的准备工作" class="headerlink" title="创建 Bean 容器前的准备工作"></a>创建 Bean 容器前的准备工作</h3><p>这个比较简单，直接看代码中的几个注释即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareRefresh</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 记录启动时间，</span></span><br><span class="line">   <span class="comment">// 将 active 属性设置为 true，closed 属性设置为 false，它们都是 AtomicBoolean 类型</span></span><br><span class="line">   <span class="keyword">this</span>.startupDate = System.currentTimeMillis();</span><br><span class="line">   <span class="keyword">this</span>.closed.set(<span class="keyword">false</span>);</span><br><span class="line">   <span class="keyword">this</span>.active.set(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Refreshing "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize any placeholder property sources in the context environment</span></span><br><span class="line">   initPropertySources();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验 xml 配置文件</span></span><br><span class="line">   getEnvironment().validateRequiredProperties();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.earlyApplicationEvents = <span class="keyword">new</span> LinkedHashSet&lt;ApplicationEvent&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-Bean-容器，加载并注册-Bean"><a href="#创建-Bean-容器，加载并注册-Bean" class="headerlink" title="创建 Bean 容器，加载并注册 Bean"></a>创建 Bean 容器，加载并注册 Bean</h3><p>我们回到 refresh() 方法中的下一行 obtainFreshBeanFactory()。</p><p>注意，<strong>这个方法是全文最重要的部分之一</strong>，这里将会初始化 BeanFactory、加载 Bean、注册 Bean 等等。</p><p>当然，这步结束后，Bean 并没有完成初始化。这里指的是 Bean 实例并未在这一步生成。</p><p>// AbstractApplicationContext.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ConfigurableListableBeanFactory <span class="title">obtainFreshBeanFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 关闭旧的 BeanFactory (如果有)，创建新的 BeanFactory，加载 Bean 定义、注册 Bean 等等</span></span><br><span class="line">   refreshBeanFactory();</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 返回刚刚创建的 BeanFactory</span></span><br><span class="line">   ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Bean factory for "</span> + getDisplayName() + <span class="string">": "</span> + beanFactory);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanFactory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>// AbstractRefreshableApplicationContext.java 120</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 如果 ApplicationContext 中已经加载过 BeanFactory 了，销毁所有 Bean，关闭 BeanFactory</span></span><br><span class="line">   <span class="comment">// 注意，应用中 BeanFactory 本来就是可以多个的，这里可不是说应用全局是否有 BeanFactory，而是当前</span></span><br><span class="line">   <span class="comment">// ApplicationContext 是否有 BeanFactory</span></span><br><span class="line">   <span class="keyword">if</span> (hasBeanFactory()) &#123;</span><br><span class="line">      destroyBeans();</span><br><span class="line">      closeBeanFactory();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 初始化一个 DefaultListableBeanFactory，为什么用这个，我们马上说。</span></span><br><span class="line">      DefaultListableBeanFactory beanFactory = createBeanFactory();</span><br><span class="line">      <span class="comment">// 用于 BeanFactory 的序列化，我想不部分人应该都用不到</span></span><br><span class="line">      beanFactory.setSerializationId(getId());</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 下面这两个方法很重要，别跟丢了，具体细节之后说</span></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的两个配置属性：是否允许 Bean 覆盖、是否允许循环引用</span></span><br><span class="line">      customizeBeanFactory(beanFactory);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 加载 Bean 到 BeanFactory 中</span></span><br><span class="line">      loadBeanDefinitions(beanFactory);</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</span><br><span class="line">         <span class="keyword">this</span>.beanFactory = beanFactory;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>看到这里的时候，我觉得读者就应该站在高处看 ApplicationContext 了，ApplicationContext 继承自 BeanFactory，但是它不应该被理解为 BeanFactory 的实现类，而是说其内部持有一个实例化的 BeanFactory（DefaultListableBeanFactory）。以后所有的 BeanFactory 相关的操作其实是委托给这个实例来处理的。</p></blockquote><p>我们说说为什么选择实例化 <strong>DefaultListableBeanFactory</strong> ？前面我们说了有个很重要的接口 ConfigurableListableBeanFactory，它实现了 BeanFactory 下面一层的所有三个接口，我把之前的继承图再拿过来大家再仔细看一下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/spring-ioc/3.png" alt="3" title="">                </div>                <div class="image-caption">3</div>            </figure><p>我们可以看到 ConfigurableListableBeanFactory 只有一个实现类 DefaultListableBeanFactory，而且实现类 DefaultListableBeanFactory 还通过实现右边的 AbstractAutowireCapableBeanFactory 通吃了右路。所以结论就是，最底下这个家伙 DefaultListableBeanFactory 基本上是最牛的 BeanFactory 了，这也是为什么这边会使用这个类来实例化的原因。</p><blockquote><p>如果你想要在程序运行的时候动态往 Spring IOC 容器注册新的 bean，就会使用到这个类。那我们怎么在运行时获得这个实例呢？</p><p>之前我们说过 ApplicationContext 接口能获取到 AutowireCapableBeanFactory，就是最右上角那个，然后它向下转型就能得到 DefaultListableBeanFactory 了。</p><p>那怎么拿到 ApplicationContext 实例呢？如果你不会，说明你没用过 Spring。</p></blockquote><p>在继续往下之前，我们需要先了解 BeanDefinition。<strong>我们说 BeanFactory 是 Bean 容器，那么 Bean 又是什么呢？</strong></p><p>这里的 BeanDefinition 就是我们所说的 Spring 的 Bean，我们自己定义的各个 Bean 其实会转换成一个个 BeanDefinition 存在于 Spring 的 BeanFactory 中。</p><p>所以，如果有人问你 Bean 是什么的时候，你要知道 Bean 在代码层面上可以简单认为是 BeanDefinition 的实例。</p><blockquote><p>BeanDefinition 中保存了我们的 Bean 信息，比如这个 Bean 指向的是哪个类、是否是单例的、是否懒加载、这个 Bean 依赖了哪些 Bean 等等。</p></blockquote><h4 id="BeanDefinition-接口定义"><a href="#BeanDefinition-接口定义" class="headerlink" title="BeanDefinition 接口定义"></a>BeanDefinition 接口定义</h4><p>我们来看下 BeanDefinition 的接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 我们可以看到，默认只提供 sington 和 prototype 两种，</span></span><br><span class="line">   <span class="comment">// 很多读者可能知道还有 request, session, globalSession, application, websocket 这几种，</span></span><br><span class="line">   <span class="comment">// 不过，它们属于基于 web 的扩展。</span></span><br><span class="line">   String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</span><br><span class="line">   String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 比较不重要，直接跳过吧</span></span><br><span class="line">   <span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置父 Bean，这里涉及到 bean 继承，不是 java 继承。请参见附录的详细介绍</span></span><br><span class="line">   <span class="comment">// 一句话就是：继承父 Bean 的配置信息而已</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 获取父 Bean</span></span><br><span class="line">   <span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 设置 Bean 的类名称，将来是要通过反射来生成实例的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 获取 Bean 的类名称</span></span><br><span class="line">   <span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置 bean 的 scope</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置是否懒加载</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</span><br><span class="line">   </span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 依赖的所有的 Bean，注意，这里的依赖不是指属性依赖(如 @Autowire 标记的)，</span></span><br><span class="line">   <span class="comment">// 是 depends-on="" 属性设置的值。</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 返回该 Bean 的所有依赖</span></span><br><span class="line">   String[] getDependsOn();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 设置该 Bean 是否可以注入到其他 Bean 中，只对根据类型注入有效，</span></span><br><span class="line">   <span class="comment">// 如果根据名称注入，即使这边设置了 false，也是可以的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 该 Bean 是否可以注入到其他 Bean 中</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 主要的。同一接口的多个实现，如果不指定名字的话，Spring 会优先选择设置 primary 为 true 的 bean</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否是 primary 的</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果该 Bean 采用工厂方法生成，指定工厂名称。对工厂不熟悉的读者，请参加附录</span></span><br><span class="line">   <span class="comment">// 一句话就是：有些实例不是用反射生成的，而是用工厂模式生成的</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="comment">// 指定工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</span><br><span class="line">   <span class="comment">// 获取工厂类中的 工厂方法名称</span></span><br><span class="line">   <span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造器参数</span></span><br><span class="line">   <span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Bean 中的属性值，后面给 bean 注入属性值的时候会说到</span></span><br><span class="line">   <span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 singleton</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 是否 prototype</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果这个 Bean 是被设置为 abstract，那么不能实例化，</span></span><br><span class="line">   <span class="comment">// 常用于作为 父bean 用于继承，其实也很少用......</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个 BeanDefinition 其实已经包含很多的信息了，暂时不清楚所有的方法对应什么东西没关系，希望看完本文后读者可以彻底搞清楚里面的所有东西。</p><p>这里接口虽然那么多，但是没有类似 getInstance() 这种方法来获取我们定义的类的实例，真正的我们定义的类生成的实例到哪里去了呢？别着急，这个要很后面才能讲到。</p></blockquote><p>有了 BeanDefinition 的概念以后，我们再往下看 refreshBeanFactory() 方法中的剩余部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">customizeBeanFactory(beanFactory);</span><br><span class="line">loadBeanDefinitions(beanFactory);</span><br></pre></td></tr></table></figure><p>虽然只有两个方法，但路还很长啊。。。</p><h4 id="customizeBeanFactory"><a href="#customizeBeanFactory" class="headerlink" title="customizeBeanFactory"></a>customizeBeanFactory</h4><p>customizeBeanFactory(beanFactory) 比较简单，就是配置是否允许 BeanDefinition 覆盖、是否允许循环引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeBeanFactory</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowBeanDefinitionOverriding != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 定义覆盖</span></span><br><span class="line">      beanFactory.setAllowBeanDefinitionOverriding(<span class="keyword">this</span>.allowBeanDefinitionOverriding);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.allowCircularReferences != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 是否允许 Bean 间的循环依赖</span></span><br><span class="line">      beanFactory.setAllowCircularReferences(<span class="keyword">this</span>.allowCircularReferences);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinition 的覆盖问题可能会有开发者碰到这个坑，就是在配置文件中定义 bean 时使用了相同的 id 或 name，默认情况下，allowBeanDefinitionOverriding 属性为 null，如果在同一配置文件中重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>循环引用也很好理解：A 依赖 B，而 B 依赖 A。或 A 依赖 B，B 依赖 C，而 C 依赖 A。</p><p>默认情况下，Spring 允许循环依赖，当然如果你在 A 的构造方法中依赖 B，在 B 的构造方法中依赖 A 是不行的。</p><p>至于这两个属性怎么配置？我在附录中进行了介绍，尤其对于覆盖问题，很多人都希望禁止出现 Bean 覆盖，可是 Spring 默认是不同文件的时候可以覆盖的。</p><p>之后的源码中还会出现这两个属性，读者有个印象就可以了，它们不是非常重要。</p><h4 id="加载-Bean-loadBeanDefinitions"><a href="#加载-Bean-loadBeanDefinitions" class="headerlink" title="加载 Bean: loadBeanDefinitions"></a>加载 Bean: loadBeanDefinitions</h4><p>接下来是最重要的 loadBeanDefinitions(beanFactory) 方法了，这个方法将根据配置，加载各个 Bean，然后放到 BeanFactory 中。</p><p>读取配置的操作在 XmlBeanDefinitionReader 中，其负责加载配置、解析。</p><p>// AbstractXmlApplicationContext.java 80</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 我们可以看到，此方法将通过一个 XmlBeanDefinitionReader 实例来加载各个 Bean。*/</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   <span class="comment">// 给这个 BeanFactory 实例化一个 XmlBeanDefinitionReader</span></span><br><span class="line">   XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line">   <span class="comment">// resource loading environment.</span></span><br><span class="line">   beanDefinitionReader.setEnvironment(<span class="keyword">this</span>.getEnvironment());</span><br><span class="line">   beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line">   beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 BeanDefinitionReader，其实这个是提供给子类覆写的，</span></span><br><span class="line">   <span class="comment">// 我看了一下，没有类覆写这个方法，我们姑且当做不重要吧</span></span><br><span class="line">   initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">   <span class="comment">// 重点来了，继续往下</span></span><br><span class="line">   loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在还在这个类中，接下来用刚刚初始化的 Reader 开始来加载 xml 配置，这块代码读者可以选择性跳过，不是很重要。也就是说，下面这个代码块，读者可以很轻松地略过。</p><p>// AbstractXmlApplicationContext.java 120</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(XmlBeanDefinitionReader reader)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line">   Resource[] configResources = getConfigResources();</span><br><span class="line">   <span class="keyword">if</span> (configResources != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 往下看</span></span><br><span class="line">      reader.loadBeanDefinitions(configResources);</span><br><span class="line">   &#125;</span><br><span class="line">   String[] configLocations = getConfigLocations();</span><br><span class="line">   <span class="keyword">if</span> (configLocations != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      reader.loadBeanDefinitions(configLocations);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面虽然有两个分支，不过第二个分支很快通过解析路径转换为 Resource 以后也会进到这里</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(resources, <span class="string">"Resource array must not be null"</span>);</span><br><span class="line">   <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">   <span class="comment">// 注意这里是个 for 循环，也就是每个文件是一个 resource</span></span><br><span class="line">   <span class="keyword">for</span> (Resource resource : resources) &#123;</span><br><span class="line">      <span class="comment">// 继续往下看</span></span><br><span class="line">      counter += loadBeanDefinitions(resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 最后返回 counter，表示总共加载了多少的 BeanDefinition</span></span><br><span class="line">   <span class="keyword">return</span> counter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 303</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// XmlBeanDefinitionReader 314</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</span><br><span class="line">   <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">      logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 用一个 ThreadLocal 来存放配置文件资源</span></span><br><span class="line">   Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</span><br><span class="line">   <span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</span><br><span class="line">      currentResources = <span class="keyword">new</span> HashSet&lt;EncodedResource&gt;(<span class="number">4</span>);</span><br><span class="line">      <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      InputStream inputStream = encodedResource.getResource().getInputStream();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</span><br><span class="line">         <span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            inputSource.setEncoding(encodedResource.getEncoding());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">// 核心部分是这里，往下面看</span></span><br><span class="line">         <span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         inputStream.close();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</span><br><span class="line">            <span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      currentResources.remove(encodedResource);</span><br><span class="line">      <span class="keyword">if</span> (currentResources.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还在这个文件中，第 388 行</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这里就不看了，将 xml 文件转换为 Document 对象</span></span><br><span class="line">      Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">      <span class="comment">// 继续</span></span><br><span class="line">      <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 还在这个文件中，第 505 行</span></span><br><span class="line"><span class="comment">// 返回值：返回从当前配置文件加载了多少数量的 Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">   BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">   <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">   <span class="comment">// 这里</span></span><br><span class="line">   documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">   <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 90</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.readerContext = readerContext;</span><br><span class="line">   logger.debug(<span class="string">"Loading bean definitions"</span>);</span><br><span class="line">   Element root = doc.getDocumentElement();</span><br><span class="line">   <span class="comment">// 从 xml 根节点开始解析文件</span></span><br><span class="line">   doRegisterBeanDefinitions(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过漫长的链路，一个配置文件终于转换为一颗 DOM 树了，注意，这里指的是其中一个配置文件，不是所有的，读者可以看到上面有个 for 循环的。下面开始从根节点开始解析：</p><h5 id="doRegisterBeanDefinitions："><a href="#doRegisterBeanDefinitions：" class="headerlink" title="doRegisterBeanDefinitions："></a>doRegisterBeanDefinitions：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DefaultBeanDefinitionDocumentReader 116</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegisterBeanDefinitions</span><span class="params">(Element root)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 我们看名字就知道，BeanDefinitionParserDelegate 必定是一个重要的类，它负责解析 Bean 定义，</span></span><br><span class="line">   <span class="comment">// 这里为什么要定义一个 parent? 看到后面就知道了，是递归问题，</span></span><br><span class="line">   <span class="comment">// 因为 &lt;beans /&gt; 内部是可以定义 &lt;beans /&gt; 的，所以这个方法的 root 其实不一定就是 xml 的根节点，也可以是嵌套在里面的 &lt;beans /&gt; 节点，从源码分析的角度，我们当做根节点就好了</span></span><br><span class="line">   BeanDefinitionParserDelegate parent = <span class="keyword">this</span>.delegate;</span><br><span class="line">   <span class="keyword">this</span>.delegate = createDelegate(getReaderContext(), root, parent);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      <span class="comment">// 这块说的是根节点 &lt;beans ... profile="dev" /&gt; 中的 profile 是否是当前环境需要的，</span></span><br><span class="line">      <span class="comment">// 如果当前环境配置的 profile 不包含此 profile，那就直接 return 了，不对此 &lt;beans /&gt; 解析</span></span><br><span class="line">      <span class="comment">// 不熟悉 profile 为何物，不熟悉怎么配置 profile 读者的请移步附录区</span></span><br><span class="line">      String profileSpec = root.getAttribute(PROFILE_ATTRIBUTE);</span><br><span class="line">      <span class="keyword">if</span> (StringUtils.hasText(profileSpec)) &#123;</span><br><span class="line">         String[] specifiedProfiles = StringUtils.tokenizeToStringArray(</span><br><span class="line">               profileSpec, BeanDefinitionParserDelegate.MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">         <span class="keyword">if</span> (!getReaderContext().getEnvironment().acceptsProfiles(specifiedProfiles)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</span><br><span class="line">               logger.info(<span class="string">"Skipped XML bean definition file due to specified profiles ["</span> + profileSpec +</span><br><span class="line">                     <span class="string">"] not matching: "</span> + getReaderContext().getResource());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   preProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line">   <span class="comment">// 往下看</span></span><br><span class="line">   parseBeanDefinitions(root, <span class="keyword">this</span>.delegate);</span><br><span class="line">   postProcessXml(root); <span class="comment">// 钩子</span></span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.delegate = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>preProcessXml(root) 和 postProcessXml(root) 是给子类用的钩子方法，鉴于没有被使用到，也不是我们的重点，我们直接跳过。</p><p>这里涉及到了 profile 的问题，对于不了解的读者，我在附录中对 profile 做了简单的解释，读者可以参考一下。</p><p>接下来，看核心解析方法 parseBeanDefinitions(root, this.delegate) :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// default namespace 涉及到的就四个标签 &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;，</span></span><br><span class="line"><span class="comment">// 其他的属于 custom 的</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">      NodeList nl = root.getChildNodes();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">         Node node = nl.item(i);</span><br><span class="line">         <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            Element ele = (Element) node;</span><br><span class="line">            <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">               <span class="comment">// 解析 default namespace 下面的几个元素</span></span><br><span class="line">               parseDefaultElement(ele, delegate);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 解析其他 namespace 的元素</span></span><br><span class="line">               delegate.parseCustomElement(ele);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      delegate.parseCustomElement(root);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，对于每个配置来说，分别进入到 parseDefaultElement(ele, delegate); 和 delegate.parseCustomElement(ele); 这两个分支了。</p><p>parseDefaultElement(ele, delegate) 代表解析的节点是 <code>&lt;import /&gt;</code>、<code>&lt;alias /&gt;</code>、<code>&lt;bean /&gt;</code>、<code>&lt;beans /&gt;</code> 这几个。</p><blockquote><p>这里的四个标签之所以是 <strong>default</strong> 的，是因为它们是处于这个 namespace 下定义的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br></pre></td></tr></table></figure><p>又到初学者科普时间，不熟悉 namespace 的读者请看下面贴出来的 xml，这里的第二行 <strong>xmlns</strong> 就是咯。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">            http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">          http://www.springframework.org/schema/beans/spring-beans.xsd"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而对于其他的标签，将进入到 delegate.parseCustomElement(element) 这个分支。如我们经常会使用到的 <code>&lt;mvc /&gt;</code>、<code>&lt;task /&gt;</code>、<code>&lt;context /&gt;</code>、<code>&lt;aop /&gt;</code>等。</p><p>这些属于扩展，如果需要使用上面这些 ”非 default“ 标签，那么上面的 xml 头部的地方也要引入相应的 namespace 和 .xsd 文件的路径，如下所示。同时代码中需要提供相应的 parser 来解析，如 MvcNamespaceHandler、TaskNamespaceHandler、ContextNamespaceHandler、AopNamespaceHandler 等。</p><p>假如读者想分析 <code>&lt;context:property-placeholder location=&quot;classpath:xx.properties&quot; /&gt;</code> 的实现原理，就应该到 ContextNamespaceHandler 中找答案。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc   </span></span></span><br><span class="line"><span class="tag"><span class="string">           http://www.springframework.org/schema/mvc/spring-mvc.xsd  </span></span></span><br><span class="line"><span class="tag"><span class="string">       "</span></span></span><br><span class="line"><span class="tag">      <span class="attr">default-autowire</span>=<span class="string">"byName"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同理，以后你要是碰到 <code>&lt;dubbo /&gt;</code> 这种标签，那么就应该搜一搜是不是有 DubboNamespaceHandler 这个处理类。</p></blockquote><p>回过神来，看看处理 default 标签的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseDefaultElement</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (delegate.nodeNameEquals(ele, IMPORT_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;import /&gt; 标签</span></span><br><span class="line">      importBeanDefinitionResource(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, ALIAS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;alias /&gt; 标签定义</span></span><br><span class="line">      <span class="comment">// &lt;alias name="fromName" alias="toName"/&gt;</span></span><br><span class="line">      processAliasRegistration(ele);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, BEAN_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 处理 &lt;bean /&gt; 标签定义，这也算是我们的重点吧</span></span><br><span class="line">      processBeanDefinition(ele, delegate);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (delegate.nodeNameEquals(ele, NESTED_BEANS_ELEMENT)) &#123;</span><br><span class="line">      <span class="comment">// 如果碰到的是嵌套的 &lt;beans /&gt; 标签，需要递归</span></span><br><span class="line">      doRegisterBeanDefinitions(ele);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果每个标签都说，那我不吐血，你们都要吐血了。我们挑我们的重点 <code>&lt;bean /&gt;</code> 标签出来说。</p><h5 id="processBeanDefinition-解析-bean-标签"><a href="#processBeanDefinition-解析-bean-标签" class="headerlink" title="processBeanDefinition 解析 bean 标签"></a>processBeanDefinition 解析 bean 标签</h5><p>下面是 processBeanDefinition 解析 <code>&lt;bean /&gt;</code> 标签：</p><p>// DefaultBeanDefinitionDocumentReader 298</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点中的信息提取出来，然后封装到一个 BeanDefinitionHolder 中，细节往下看</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面的几行先不要看，跳过先，跳过先，跳过先，后面会继续说的</span></span><br><span class="line">  </span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// Register the final decorated instance.</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Send registration event.</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继续往下看怎么解析之前，我们先看下 <strong><code>&lt;bean /&gt;</code></strong> 标签中可以定义哪些属性：</p><table><thead><tr><th>Property</th><th></th></tr></thead><tbody><tr><td>class</td><td>类的全限定名</td></tr><tr><td>name</td><td>可指定 id、name(用逗号、分号、空格分隔)</td></tr><tr><td>scope</td><td>作用域</td></tr><tr><td>constructor arguments</td><td>指定构造参数</td></tr><tr><td>properties</td><td>设置属性的值</td></tr><tr><td>autowiring mode</td><td>no(默认值)、byName、byType、 constructor</td></tr><tr><td>lazy-initialization mode</td><td>是否懒加载(如果被非懒加载的bean依赖了那么其实也就不能懒加载了)</td></tr><tr><td>initialization method</td><td>bean 属性设置完成后，会调用这个方法</td></tr><tr><td>destruction method</td><td>bean 销毁后的回调方法</td></tr></tbody></table><p>上面表格中的内容我想大家都非常熟悉吧，如果不熟悉，那就是你不够了解 Spring 的配置了。</p><p>简单地说就是像下面这样子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleBean"</span> <span class="attr">name</span>=<span class="string">"name1, name2, name3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.ExampleBean"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span> <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- 可以用下面三种形式指定构造参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"years"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"7500000"</span>/&gt;</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">&lt;!-- property 的几种情况 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanOne"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"anotherExampleBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beanTwo"</span> <span class="attr">ref</span>=<span class="string">"yetAnotherBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"integerProperty"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，除了上面举例出来的这些，还有 factory-bean、factory-method、<code>&lt;lockup-method /&gt;</code>、<code>&lt;replaced-method /&gt;</code>、<code>&lt;meta /&gt;</code>、<code>&lt;qualifier /&gt;</code> 这几个，大家是不是熟悉呢？自己检验一下自己对 Spring 中 bean 的了解程度。</p><p>有了以上这些知识以后，我们再继续往里看怎么解析 bean 元素，是怎么转换到 BeanDefinitionHolder 的。</p><p>// BeanDefinitionParserDelegate 428</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parseBeanDefinitionElement(ele, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">   String id = ele.getAttribute(ID_ATTRIBUTE);</span><br><span class="line">   String nameAttr = ele.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line"></span><br><span class="line">   List&lt;String&gt; aliases = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">      </span><br><span class="line">   <span class="comment">// 将 name 属性的定义按照 “逗号、分号、空格” 切分，形成一个 别名列表数组，</span></span><br><span class="line">   <span class="comment">// 当然，如果你不定义 name 属性的话，就是空的了</span></span><br><span class="line">   <span class="comment">// 我在附录中简单介绍了一下 id 和 name 的配置，大家可以看一眼，有个20秒就可以了</span></span><br><span class="line">   <span class="keyword">if</span> (StringUtils.hasLength(nameAttr)) &#123;</span><br><span class="line">      String[] nameArr = StringUtils.tokenizeToStringArray(nameAttr, MULTI_VALUE_ATTRIBUTE_DELIMITERS);</span><br><span class="line">      aliases.addAll(Arrays.asList(nameArr));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   String beanName = id;</span><br><span class="line">   <span class="comment">// 如果没有指定id, 那么用别名列表的第一个名字作为beanName</span></span><br><span class="line">   <span class="keyword">if</span> (!StringUtils.hasText(beanName) &amp;&amp; !aliases.isEmpty()) &#123;</span><br><span class="line">      beanName = aliases.remove(<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"No XML 'id' specified - using '"</span> + beanName +</span><br><span class="line">               <span class="string">"' as bean name and "</span> + aliases + <span class="string">" as aliases"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (containingBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">      checkNameUniqueness(beanName, aliases, ele);</span><br><span class="line">   &#125;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 根据 &lt;bean ...&gt;...&lt;/bean&gt; 中的配置创建 BeanDefinition，然后把配置中的信息都设置到实例中,</span></span><br><span class="line">   <span class="comment">// 细节后面细说，先知道下面这行结束后，一个 BeanDefinition 实例就出来了。</span></span><br><span class="line">   AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 到这里，整个 &lt;bean /&gt; 标签就算解析结束了，一个 BeanDefinition 就形成了。</span></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果都没有设置 id 和 name，那么此时的 beanName 就会为 null，进入下面这块代码产生</span></span><br><span class="line">      <span class="comment">// 如果读者不感兴趣的话，我觉得不需要关心这块代码，对本文源码分析来说，这些东西不重要</span></span><br><span class="line">      <span class="keyword">if</span> (!StringUtils.hasText(beanName)) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (containingBean != <span class="keyword">null</span>) &#123;<span class="comment">// 按照我们的思路，这里 containingBean 是 null 的</span></span><br><span class="line">               beanName = BeanDefinitionReaderUtils.generateBeanName(</span><br><span class="line">                     beanDefinition, <span class="keyword">this</span>.readerContext.getRegistry(), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// 如果我们不定义 id 和 name，那么我们引言里的那个例子：</span></span><br><span class="line">               <span class="comment">//   1. beanName 为：com.javadoop.example.MessageServiceImpl#0</span></span><br><span class="line">               <span class="comment">//   2. beanClassName 为：com.javadoop.example.MessageServiceImpl</span></span><br><span class="line">              </span><br><span class="line">               beanName = <span class="keyword">this</span>.readerContext.generateBeanName(beanDefinition);</span><br><span class="line">               </span><br><span class="line">               String beanClassName = beanDefinition.getBeanClassName();</span><br><span class="line">               <span class="keyword">if</span> (beanClassName != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                     beanName.startsWith(beanClassName) &amp;&amp; beanName.length() &gt; beanClassName.length() &amp;&amp;</span><br><span class="line">                     !<span class="keyword">this</span>.readerContext.getRegistry().isBeanNameInUse(beanClassName)) &#123;</span><br><span class="line">                  <span class="comment">// 把 beanClassName 设置为 Bean 的别名</span></span><br><span class="line">                  aliases.add(beanClassName);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">               logger.debug(<span class="string">"Neither XML 'id' nor 'name' specified - "</span> +</span><br><span class="line">                     <span class="string">"using generated bean name ["</span> + beanName + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            error(ex.getMessage(), ele);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      String[] aliasesArray = StringUtils.toStringArray(aliases);</span><br><span class="line">      <span class="comment">// 返回 BeanDefinitionHolder</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再看看怎么根据配置创建 BeanDefinition 实例的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractBeanDefinition <span class="title">parseBeanDefinitionElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Element ele, String beanName, BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">this</span>.parseState.push(<span class="keyword">new</span> BeanEntry(beanName));</span><br><span class="line"></span><br><span class="line">   String className = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (ele.hasAttribute(CLASS_ATTRIBUTE)) &#123;</span><br><span class="line">      className = ele.getAttribute(CLASS_ATTRIBUTE).trim();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      String parent = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (ele.hasAttribute(PARENT_ATTRIBUTE)) &#123;</span><br><span class="line">         parent = ele.getAttribute(PARENT_ATTRIBUTE);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 创建 BeanDefinition，然后设置类信息而已，很简单，就不贴代码了</span></span><br><span class="line">      AbstractBeanDefinition bd = createBeanDefinition(className, parent);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanDefinition 的一堆属性，这些属性定义在 AbstractBeanDefinition 中</span></span><br><span class="line">      parseBeanDefinitionAttributes(ele, beanName, containingBean, bd);</span><br><span class="line">      bd.setDescription(DomUtils.getChildElementValueByTagName(ele, DESCRIPTION_ELEMENT));</span><br><span class="line">    </span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 下面的一堆是解析 &lt;bean&gt;......&lt;/bean&gt; 内部的子元素，</span></span><br><span class="line"><span class="comment">       * 解析出来以后的信息都放到 bd 的属性中</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 解析 &lt;meta /&gt;</span></span><br><span class="line">      parseMetaElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;lookup-method /&gt;</span></span><br><span class="line">      parseLookupOverrideSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">      <span class="comment">// 解析 &lt;replaced-method /&gt;</span></span><br><span class="line">      parseReplacedMethodSubElements(ele, bd.getMethodOverrides());</span><br><span class="line">    <span class="comment">// 解析 &lt;constructor-arg /&gt;</span></span><br><span class="line">      parseConstructorArgElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;property /&gt;</span></span><br><span class="line">      parsePropertyElements(ele, bd);</span><br><span class="line">      <span class="comment">// 解析 &lt;qualifier /&gt;</span></span><br><span class="line">      parseQualifierElements(ele, bd);</span><br><span class="line"></span><br><span class="line">      bd.setResource(<span class="keyword">this</span>.readerContext.getResource());</span><br><span class="line">      bd.setSource(extractSource(ele));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> bd;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">      error(<span class="string">"Bean class ["</span> + className + <span class="string">"] not found"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (NoClassDefFoundError err) &#123;</span><br><span class="line">      error(<span class="string">"Class that bean class ["</span> + className + <span class="string">"] depends on not found"</span>, ele, err);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      error(<span class="string">"Unexpected failure during bean definition parsing"</span>, ele, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parseState.pop();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经完成了根据 <code>&lt;bean /&gt;</code> 配置创建了一个 BeanDefinitionHolder 实例。注意，是一个。</p><p>我们回到解析 <code>&lt;bean /&gt;</code> 的入口方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 将 &lt;bean /&gt; 节点转换为 BeanDefinitionHolder，就是上面说的一堆</span></span><br><span class="line">   BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">   <span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果有自定义属性的话，进行相应的解析，先忽略</span></span><br><span class="line">      bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 我们把这步叫做 注册Bean 吧</span></span><br><span class="line">         BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">         getReaderContext().error(<span class="string">"Failed to register bean definition with name '"</span> +</span><br><span class="line">               bdHolder.getBeanName() + <span class="string">"'"</span>, ele, ex);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 注册完成后，发送事件，本文不展开说这个</span></span><br><span class="line">      getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家再仔细看一下这块吧，我们后面就不回来说这个了。这里已经根据一个 <code>&lt;bean /&gt;</code> 标签产生了一个 BeanDefinitionHolder 的实例，这个实例里面也就是一个 BeanDefinition 的实例和它的 beanName、aliases 这三个信息，注意，我们的关注点始终在 BeanDefinition 上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String beanName;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] aliases;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>然后我们准备注册这个 BeanDefinition，最后，把这个注册事件发送出去。</p><p>下面，我们开始说说注册 Bean 吧。</p><h5 id="注册-Bean"><a href="#注册-Bean" class="headerlink" title="注册 Bean"></a>注册 Bean</h5><p>// BeanDefinitionReaderUtils 143</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      BeanDefinitionHolder definitionHolder, BeanDefinitionRegistry registry)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   String beanName = definitionHolder.getBeanName();</span><br><span class="line">   <span class="comment">// 注册这个 Bean</span></span><br><span class="line">   registry.registerBeanDefinition(beanName, definitionHolder.getBeanDefinition());</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果还有别名的话，也要根据别名全部注册一遍，不然根据别名就会找不到 Bean 了</span></span><br><span class="line">   String[] aliases = definitionHolder.getAliases();</span><br><span class="line">   <span class="keyword">if</span> (aliases != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (String alias : aliases) &#123;</span><br><span class="line">         <span class="comment">// alias -&gt; beanName 保存它们的别名信息，这个很简单，用一个 map 保存一下就可以了，</span></span><br><span class="line">         <span class="comment">// 获取的时候，会先将 alias 转换为 beanName，然后再查找</span></span><br><span class="line">         registry.registerAlias(beanName, alias);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>别名注册的放一边，毕竟它很简单，我们看看怎么注册 Bean。</p><p>// DefaultListableBeanFactory 793</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line"></span><br><span class="line">   Assert.hasText(beanName, <span class="string">"Bean name must not be empty"</span>);</span><br><span class="line">   Assert.notNull(beanDefinition, <span class="string">"BeanDefinition must not be null"</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (beanDefinition <span class="keyword">instanceof</span> AbstractBeanDefinition) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         ((AbstractBeanDefinition) beanDefinition).validate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(...);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// old? 还记得 “允许 bean 覆盖” 这个配置吗？allowBeanDefinitionOverriding</span></span><br><span class="line">   BeanDefinition oldBeanDefinition;</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 之后会看到，所有的 Bean 注册后会放入这个 beanDefinitionMap 中</span></span><br><span class="line">   oldBeanDefinition = <span class="keyword">this</span>.beanDefinitionMap.get(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 处理重复名称的 Bean 定义的情况</span></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isAllowBeanDefinitionOverriding()) &#123;</span><br><span class="line">         <span class="comment">// 如果不允许覆盖的话，抛异常</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(beanDefinition.getResourceDescription()...</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (oldBeanDefinition.getRole() &lt; beanDefinition.getRole()) &#123;</span><br><span class="line">         <span class="comment">// log...用框架定义的 Bean 覆盖用户自定义的 Bean </span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (!beanDefinition.equals(oldBeanDefinition)) &#123;</span><br><span class="line">         <span class="comment">// log...用新的 Bean 覆盖旧的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// log...用同等的 Bean 覆盖旧的 Bean，这里指的是 equals 方法返回 true 的 Bean</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 覆盖</span></span><br><span class="line">      <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 判断是否已经有其他的 Bean 开始初始化了.</span></span><br><span class="line">      <span class="comment">// 注意，"注册Bean" 这个动作结束，Bean 依然还没有初始化，我们后面会有大篇幅说初始化过程，</span></span><br><span class="line">      <span class="comment">// 在 Spring 容器启动的最后，会 预初始化 所有的 singleton beans</span></span><br><span class="line">      <span class="keyword">if</span> (hasBeanCreationStarted()) &#123;</span><br><span class="line">         <span class="comment">// Cannot modify startup-time collection elements anymore (for stable iteration)</span></span><br><span class="line">         <span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanDefinitionMap) &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">            List&lt;String&gt; updatedDefinitions = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames.size() + <span class="number">1</span>);</span><br><span class="line">            updatedDefinitions.addAll(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line">            updatedDefinitions.add(beanName);</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitionNames = updatedDefinitions;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.manualSingletonNames.contains(beanName)) &#123;</span><br><span class="line">               Set&lt;String&gt; updatedSingletons = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(<span class="keyword">this</span>.manualSingletonNames);</span><br><span class="line">               updatedSingletons.remove(beanName);</span><br><span class="line">               <span class="keyword">this</span>.manualSingletonNames = updatedSingletons;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 最正常的应该是进到这个分支。</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 将 BeanDefinition 放到这个 map 中，这个 map 保存了所有的 BeanDefinition</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">         <span class="comment">// 这是个 ArrayList，所以会按照 bean 配置的顺序保存每一个注册的 Bean 的名字</span></span><br><span class="line">         <span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">         <span class="comment">// 这是个 LinkedHashSet，代表的是手动注册的 singleton bean，</span></span><br><span class="line">         <span class="comment">// 注意这里是 remove 方法，到这里的 Bean 当然不是手动注册的</span></span><br><span class="line">         <span class="comment">// 手动指的是通过调用以下方法注册的 bean ：</span></span><br><span class="line">         <span class="comment">//     registerSingleton(String beanName, Object singletonObject)</span></span><br><span class="line">         <span class="comment">// 这不是重点，解释只是为了不让大家疑惑。Spring 会在后面"手动"注册一些 Bean，</span></span><br><span class="line">         <span class="comment">// 如 "environment"、"systemProperties" 等 bean，我们自己也可以在运行时注册 Bean 到容器中的</span></span><br><span class="line">         <span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 这个不重要，在预初始化的时候会用到，不必管它。</span></span><br><span class="line">      <span class="keyword">this</span>.frozenBeanDefinitionNames = <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (oldBeanDefinition != <span class="keyword">null</span> || containsSingleton(beanName)) &#123;</span><br><span class="line">      resetBeanDefinition(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，到这里已经初始化了 Bean 容器，<code>&lt;bean /&gt;</code> 配置也相应的转换为了一个个 BeanDefinition，然后注册了各个 BeanDefinition 到注册中心，并且发送了注册事件。</p><p>——— 分割线 ———</p><p>到这里是一个分水岭，前面的内容都还算比较简单，不过应该也比较繁琐，大家要清楚地知道前面都做了哪些事情。</p><h3 id="Bean-容器实例化完成后"><a href="#Bean-容器实例化完成后" class="headerlink" title="Bean 容器实例化完成后"></a>Bean 容器实例化完成后</h3><p>说到这里，我们回到 refresh() 方法，我重新贴了一遍代码，看看我们说到哪了。是的，我们才说完 obtainFreshBeanFactory() 方法。</p><p>考虑到篇幅，这里开始大幅缩减掉没必要详细介绍的部分，大家直接看下面的代码中的注释就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">   <span class="comment">// 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</span></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">      prepareRefresh();</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 这步比较关键，这步完成后，配置文件就会解析成一个个 Bean 定义，注册到 BeanFactory 中，</span></span><br><span class="line">      <span class="comment">// 当然，这里说的 Bean 还没有初始化，只是配置信息都提取出来了，</span></span><br><span class="line">      <span class="comment">// 注册也只是将这些信息都保存到了注册中心(说到底核心是一个 beanName-&gt; beanDefinition 的 map)</span></span><br><span class="line">      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 设置 BeanFactory 的类加载器，添加几个 BeanPostProcessor，手动注册几个特殊的 bean</span></span><br><span class="line">      <span class="comment">// 这块待会会展开说</span></span><br><span class="line">      prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="comment">// 【这里需要知道 BeanFactoryPostProcessor 这个知识点，Bean 如果实现了此接口，</span></span><br><span class="line">         <span class="comment">// 那么在容器初始化以后，Spring 会负责调用里面的 postProcessBeanFactory 方法。】</span></span><br><span class="line">        </span><br><span class="line">         <span class="comment">// 这里是提供给子类的扩展点，到这里的时候，所有的 Bean 都加载、注册完成了，但是都还没有初始化</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这步的时候添加一些特殊的 BeanFactoryPostProcessor 的实现类或做点什么事</span></span><br><span class="line">         postProcessBeanFactory(beanFactory);</span><br><span class="line">         <span class="comment">// 调用 BeanFactoryPostProcessor 各个实现类的 postProcessBeanFactory(factory) 回调方法</span></span><br><span class="line">         invokeBeanFactoryPostProcessors(beanFactory);          </span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></span><br><span class="line">         <span class="comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></span><br><span class="line">         <span class="comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。这里仅仅是注册，之后会看到回调这两方法的时机</span></span><br><span class="line">         registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的 MessageSource，国际化这里就不展开说了，不然没完没了了</span></span><br><span class="line">         initMessageSource();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 初始化当前 ApplicationContext 的事件广播器，这里也不展开了</span></span><br><span class="line">         initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 从方法名就可以知道，典型的模板方法(钩子方法)，不展开说</span></span><br><span class="line">         <span class="comment">// 具体的子类可以在这里初始化一些特殊的 Bean（在初始化 singleton beans 之前）</span></span><br><span class="line">         onRefresh();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 注册事件监听器，监听器需要实现 ApplicationListener 接口。这也不是我们的重点，过</span></span><br><span class="line">         registerListeners();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 重点，重点，重点</span></span><br><span class="line">         <span class="comment">// 初始化所有的 singleton beans</span></span><br><span class="line">         <span class="comment">//（lazy-init 的除外）</span></span><br><span class="line">         finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 最后，广播事件，ApplicationContext 初始化完成，不展开</span></span><br><span class="line">         finishRefresh();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line">                  <span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">         <span class="comment">// 销毁已经初始化的 singleton 的 Beans，以免有些 bean 会一直占用资源</span></span><br><span class="line">         destroyBeans();</span><br><span class="line"></span><br><span class="line">         <span class="comment">// Reset 'active' flag.</span></span><br><span class="line">         cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 把异常往外抛</span></span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">finally</span> &#123;</span><br><span class="line">         <span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line">         <span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">         resetCommonCaches();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="准备-Bean-容器-prepareBeanFactory"><a href="#准备-Bean-容器-prepareBeanFactory" class="headerlink" title="准备 Bean 容器: prepareBeanFactory"></a>准备 Bean 容器: prepareBeanFactory</h3><p>之前我们说过，Spring 把我们在 xml 配置的 bean 都注册以后，会”手动”注册一些特殊的 bean。</p><p>这里简单介绍下 prepareBeanFactory(factory) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Configure the factory's standard context characteristics,</span></span><br><span class="line"><span class="comment"> * such as the context's ClassLoader and post-processors.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanFactory the BeanFactory to configure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">prepareBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 设置 BeanFactory 的类加载器，我们知道 BeanFactory 需要加载类，也就需要类加载器，</span></span><br><span class="line">   <span class="comment">// 这里设置为加载当前 ApplicationContext 类的类加载器</span></span><br><span class="line">   beanFactory.setBeanClassLoader(getClassLoader());</span><br><span class="line">    </span><br><span class="line">   <span class="comment">// 设置 BeanExpressionResolver</span></span><br><span class="line">   beanFactory.setBeanExpressionResolver(<span class="keyword">new</span> StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));</span><br><span class="line">   <span class="comment">// </span></span><br><span class="line">   beanFactory.addPropertyEditorRegistrar(<span class="keyword">new</span> ResourceEditorRegistrar(<span class="keyword">this</span>, getEnvironment()));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 添加一个 BeanPostProcessor，这个 processor 比较简单：</span></span><br><span class="line">   <span class="comment">// 实现了 Aware 接口的 beans 在初始化的时候，这个 processor 负责回调，</span></span><br><span class="line">   <span class="comment">// 这个我们很常用，如我们会为了获取 ApplicationContext 而 implement ApplicationContextAware</span></span><br><span class="line">   <span class="comment">// 注意：它不仅仅回调 ApplicationContextAware，</span></span><br><span class="line">   <span class="comment">//   还会负责回调 EnvironmentAware、ResourceLoaderAware 等，看下源码就清楚了</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationContextAwareProcessor(<span class="keyword">this</span>));</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 下面几行的意思就是，如果某个 bean 依赖于以下几个接口的实现类，在自动装配的时候忽略它们，</span></span><br><span class="line">   <span class="comment">// Spring 会通过其他方式来处理这些依赖。</span></span><br><span class="line">   beanFactory.ignoreDependencyInterface(EnvironmentAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ResourceLoaderAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(MessageSourceAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">   beanFactory.ignoreDependencyInterface(ApplicationContextAware<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 下面几行就是为特殊的几个 bean 赋值，如果有 bean 依赖了以下几个，会注入这边相应的值，</span></span><br><span class="line"><span class="comment">    * 之前我们说过，"当前 ApplicationContext 持有一个 BeanFactory"，这里解释了第一行。</span></span><br><span class="line"><span class="comment">    * ApplicationContext 还继承了 ResourceLoader、ApplicationEventPublisher、MessageSource</span></span><br><span class="line"><span class="comment">    * 所以对于这几个依赖，可以赋值为 this，注意 this 是一个 ApplicationContext</span></span><br><span class="line"><span class="comment">    * 那这里怎么没看到为 MessageSource 赋值呢？那是因为 MessageSource 被注册成为了一个普通的 bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   beanFactory.registerResolvableDependency(BeanFactory<span class="class">.<span class="keyword">class</span>, <span class="title">beanFactory</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ResourceLoader<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationEventPublisher<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line">   beanFactory.registerResolvableDependency(ApplicationContext<span class="class">.<span class="keyword">class</span>, <span class="title">this</span>)</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这个 BeanPostProcessor 也很简单，在 bean 实例化后，如果是 ApplicationListener 的子类，</span></span><br><span class="line">   <span class="comment">// 那么将其添加到 listener 列表中，可以理解成：注册 事件监听器</span></span><br><span class="line">   beanFactory.addBeanPostProcessor(<span class="keyword">new</span> ApplicationListenerDetector(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 这里涉及到特殊的 bean，名为：loadTimeWeaver，这不是我们的重点，忽略它</span></span><br><span class="line">   <span class="comment">// tips: ltw 是 AspectJ 的概念，指的是在运行期进行织入，这个和 Spring AOP 不一样，</span></span><br><span class="line">   <span class="comment">//    感兴趣的读者请参考我写的关于 AspectJ 的另一篇文章 https://www.javadoop.com/post/aspectj</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.addBeanPostProcessor(<span class="keyword">new</span> LoadTimeWeaverAwareProcessor(beanFactory));</span><br><span class="line">      <span class="comment">// Set a temporary ClassLoader for type matching.</span></span><br><span class="line">      beanFactory.setTempClassLoader(<span class="keyword">new</span> ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从下面几行代码我们可以知道，Spring 往往很 "智能" 就是因为它会帮我们默认注册一些有用的 bean，</span></span><br><span class="line"><span class="comment">    * 我们也可以选择覆盖</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 如果没有定义 "environment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemProperties" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 如果没有定义 "systemEnvironment" 这个 bean，那么 Spring 会 "手动" 注册一个</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) &#123;</span><br><span class="line">      beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这块代码中，Spring 对一些特殊的 bean 进行了处理，读者如果暂时还不能消化它们也没有关系，慢慢往下看。</p><h3 id="初始化所有的-singleton-beans"><a href="#初始化所有的-singleton-beans" class="headerlink" title="初始化所有的 singleton beans"></a>初始化所有的 singleton beans</h3><p>我们的重点当然是 <code>finishBeanFactoryInitialization(beanFactory);</code> 这个巨头了，这里会负责初始化所有的 singleton beans。</p><p>注意，后面的描述中，我都会使用<strong>初始化</strong>或<strong>预初始化</strong>来代表这个阶段，Spring 会在这个阶段完成所有的 singleton beans 的实例化。</p><p>我们来总结一下，到目前为止，应该说 BeanFactory 已经创建完成，并且所有的实现了 BeanFactoryPostProcessor 接口的 Bean 都已经初始化并且其中的 postProcessBeanFactory(factory) 方法已经得到回调执行了。而且 Spring 已经“手动”注册了一些特殊的 Bean，如 <code>environment</code>、<code>systemProperties</code> 等。</p><p>剩下的就是初始化 singleton beans 了，我们知道它们是单例的，如果没有设置懒加载，那么 Spring 会在接下来初始化所有的 singleton beans。</p><p>// AbstractApplicationContext.java 834</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化剩余的 singleton beans</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 首先，初始化名字为 conversionService 的 Bean。本着送佛送到西的精神，我在附录中简单介绍了一下 ConversionService，因为这实在太实用了</span></span><br><span class="line">   <span class="comment">// 什么，看代码这里没有初始化 Bean 啊！</span></span><br><span class="line">   <span class="comment">// 注意了，初始化的动作包装在 beanFactory.getBean(...) 中，这里先不说细节，先往下看吧</span></span><br><span class="line">   <span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">         beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">      beanFactory.setConversionService(</span><br><span class="line">            beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line">   <span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line">   <span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line">   <span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">      beanFactory.addEmbeddedValueResolver(<span class="keyword">new</span> StringValueResolver() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> String <span class="title">resolveStringValue</span><span class="params">(String strVal)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEnvironment().resolvePlaceholders(strVal);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 先初始化 LoadTimeWeaverAware 类型的 Bean</span></span><br><span class="line">   <span class="comment">// 之前也说过，这是 AspectJ 相关的内容，放心跳过吧</span></span><br><span class="line">   String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware<span class="class">.<span class="keyword">class</span>, <span class="title">false</span>, <span class="title">false</span>)</span>;</span><br><span class="line">   <span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">      getBean(weaverAwareName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">   beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 没什么别的目的，因为到这一步的时候，Spring 已经开始预初始化 singleton beans 了，</span></span><br><span class="line">   <span class="comment">// 肯定不希望这个时候还出现 bean 定义解析、加载、注册。</span></span><br><span class="line">   beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 开始初始化</span></span><br><span class="line">   beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面最后一行往里看，我们就又回到 DefaultListableBeanFactory 这个类了，这个类大家应该都不陌生了吧。</p><h4 id="preInstantiateSingletons"><a href="#preInstantiateSingletons" class="headerlink" title="preInstantiateSingletons"></a>preInstantiateSingletons</h4><p>// DefaultListableBeanFactory 728</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">      <span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// this.beanDefinitionNames 保存了所有的 beanNames</span></span><br><span class="line">   List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 下面这个循环，触发所有的非懒加载的 singleton beans 的初始化操作</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 合并父 Bean 中的配置，注意 &lt;bean id="" class="" parent="" /&gt; 中的 parent，用的不多吧，</span></span><br><span class="line">      <span class="comment">// 考虑到这可能会影响大家的理解，我在附录中解释了一下 "Bean 继承"，不了解的请到附录中看一下</span></span><br><span class="line">      RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">     </span><br><span class="line">      <span class="comment">// 非抽象、非懒加载的 singletons。如果配置了 'abstract = true'，那是不需要初始化的</span></span><br><span class="line">      <span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">         <span class="comment">// 处理 FactoryBean(读者如果不熟悉 FactoryBean，请移步附录区了解)</span></span><br><span class="line">         <span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">            <span class="comment">// FactoryBean 的话，在 beanName 前面加上 ‘&amp;’ 符号。再调用 getBean，getBean 方法别急</span></span><br><span class="line">            <span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">            <span class="comment">// 判断当前 FactoryBean 是否是 SmartFactoryBean 的实现，此处忽略，直接跳过</span></span><br><span class="line">            <span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">               isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;, getAccessControlContext());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">               isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">                     ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">               </span><br><span class="line">               getBean(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 对于普通的 Bean，只要调用 getBean(beanName) 这个方法就可以进行初始化了</span></span><br><span class="line">            getBean(beanName);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这里说明所有的非懒加载的 singleton beans 已经完成了初始化</span></span><br><span class="line">   <span class="comment">// 如果我们定义的 bean 是实现了 SmartInitializingSingleton 接口的，那么在这里得到回调，忽略</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">      Object singletonInstance = getSingleton(beanName);</span><br><span class="line">      <span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line">         <span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line">         <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                  smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;, getAccessControlContext());</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们就进入到 getBean(beanName) 方法了，这个方法我们经常用来从 BeanFactory 中获取一个 Bean，而初始化的过程也封装到了这个方法里。</p><h4 id="getBean"><a href="#getBean" class="headerlink" title="getBean"></a>getBean</h4><p>在继续前进之前，读者应该具备 FactoryBean 的知识，如果读者还不熟悉，请移步附录部分了解 FactoryBean。</p><p>// AbstractBeanFactory 196</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们在剖析初始化 Bean 的过程，但是 getBean 方法我们经常是用来从容器中获取 Bean 用的，注意切换思路，</span></span><br><span class="line"><span class="comment">// 已经初始化过了就从容器中直接返回，否则就先初始化再返回</span></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">final</span> String name, <span class="keyword">final</span> Class&lt;T&gt; requiredType, <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">   <span class="comment">// 获取一个 “正统的” beanName，处理两种情况，一个是前面说的 FactoryBean(前面带 ‘&amp;’)，</span></span><br><span class="line">   <span class="comment">// 一个是别名问题，因为这个方法是 getBean，获取 Bean 用的，你要是传一个别名进来，是完全可以的</span></span><br><span class="line">   <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 注意跟着这个，这个是返回值</span></span><br><span class="line">   Object bean; </span><br><span class="line"></span><br><span class="line">   <span class="comment">// 检查下是不是已经创建过了</span></span><br><span class="line">   Object sharedInstance = getSingleton(beanName);</span><br><span class="line">  </span><br><span class="line">   <span class="comment">// 这里说下 args 呗，虽然看上去一点不重要。前面我们一路进来的时候都是 getBean(beanName)，</span></span><br><span class="line">   <span class="comment">// 所以 args 传参其实是 null 的，但是如果 args 不为空的时候，那么意味着调用方不是希望获取 Bean，而是创建 Bean</span></span><br><span class="line">   <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            logger.debug(<span class="string">"..."</span>);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.debug(<span class="string">"Returning cached instance of singleton bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 下面这个方法：如果是普通 Bean 的话，直接返回 sharedInstance，</span></span><br><span class="line">      <span class="comment">// 如果是 FactoryBean 的话，返回它创建的那个实例对象</span></span><br><span class="line">      <span class="comment">// (FactoryBean 知识，读者若不清楚请移步附录)</span></span><br><span class="line">      bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 创建过了此 beanName 的 prototype 类型的 bean，那么抛异常，</span></span><br><span class="line">         <span class="comment">// 往往是因为陷入了循环引用</span></span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查一下这个 BeanDefinition 在容器中是否存在</span></span><br><span class="line">      BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">      <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">         <span class="comment">// 如果当前容器不存在这个 BeanDefinition，试试父容器中有没有</span></span><br><span class="line">         String nameToLookup = originalBeanName(name);</span><br><span class="line">         <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 返回父容器的查询结果</span></span><br><span class="line">            <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">            <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">         <span class="comment">// typeCheckOnly 为 false，将当前 beanName 放入一个 alreadyCreated 的 Set 集合中。</span></span><br><span class="line">         markBeanAsCreated(beanName);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       * 稍稍总结一下：</span></span><br><span class="line"><span class="comment">       * 到这里的话，要准备创建 Bean 了，对于 singleton 的 Bean 来说，容器中还没创建过此 Bean；</span></span><br><span class="line"><span class="comment">       * 对于 prototype 的 Bean 来说，本来就是要创建一个新的 Bean。</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">         checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 先初始化依赖的所有 Bean，这个很好理解。</span></span><br><span class="line">         <span class="comment">// 注意，这里的依赖指的是 depends-on 中定义的依赖</span></span><br><span class="line">         String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">         <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">               <span class="comment">// 检查是不是有循环依赖，这里的循环依赖和我们前面说的循环依赖又不一样，这里肯定是不允许出现的，不然要乱套了，读者想一下就知道了</span></span><br><span class="line">               <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                        <span class="string">"Circular depends-on relationship between '"</span> + beanName + <span class="string">"' and '"</span> + dep + <span class="string">"'"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 注册一下依赖关系</span></span><br><span class="line">               registerDependentBean(dep, beanName);</span><br><span class="line">               <span class="comment">// 先初始化被依赖项</span></span><br><span class="line">               getBean(dep);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 singleton scope 的，创建 singleton 的实例</span></span><br><span class="line">         <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">            sharedInstance = getSingleton(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                     <span class="comment">// 执行创建 Bean，详情后面再说</span></span><br><span class="line">                     <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                     destroySingleton(beanName);</span><br><span class="line">                     <span class="keyword">throw</span> ex;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果是 prototype scope 的，创建 prototype 的实例</span></span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">            <span class="comment">// It's a prototype -&gt; create a new instance.</span></span><br><span class="line">            Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               beforePrototypeCreation(beanName);</span><br><span class="line">               <span class="comment">// 执行创建 Bean</span></span><br><span class="line">               prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> &#123;</span><br><span class="line">               afterPrototypeCreation(beanName);</span><br><span class="line">            &#125;</span><br><span class="line">            bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 如果不是 singleton 和 prototype 的话，需要委托给相应的实现类来处理</span></span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            String scopeName = mbd.getScope();</span><br><span class="line">            <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">            <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No Scope registered for scope name '"</span> + scopeName + <span class="string">"'"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               Object scopedInstance = scope.get(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">                     beforePrototypeCreation(beanName);</span><br><span class="line">                     <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行创建 Bean</span></span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterPrototypeCreation(beanName);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">               bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                     <span class="string">"Scope '"</span> + scopeName + <span class="string">"' is not active for the current thread; consider "</span> +</span><br><span class="line">                     <span class="string">"defining a scoped proxy for this bean if you intend to refer to it from a singleton"</span>,</span><br><span class="line">                     ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">         cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">         <span class="keyword">throw</span> ex;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 最后，检查一下类型对不对，不对的话就抛异常，对的话就返回了</span></span><br><span class="line">   <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; bean != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">         <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            logger.debug(<span class="string">"Failed to convert bean '"</span> + name + <span class="string">"' to required type '"</span> +</span><br><span class="line">                  ClassUtils.getQualifiedName(requiredType) + <span class="string">"'"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家应该也猜到了，接下来当然是分析 createBean 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException</span>;</span><br></pre></td></tr></table></figure><p>第三个参数 args 数组代表创建实例需要的参数，不就是给构造方法用的参数，或者是工厂 Bean 的参数嘛，不过要注意，在我们的初始化阶段，args 是 null。</p><p>这回我们要到一个新的类了 AbstractAutowireCapableBeanFactory，看类名，AutowireCapable？类名是不是也说明了点问题了。</p><p>主要是为了以下场景，采用 @Autowired 注解注入属性值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageServiceImpl</span> <span class="keyword">implements</span> <span class="title">MessageService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上这种属于混用了 xml 和 注解 两种方式的配置方式，Spring 会处理这种情况。</p><p>好了，读者要知道这么回事就可以了，继续向前。</p><p>// AbstractAutowireCapableBeanFactory 447</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Central method of this class: creates a bean instance,</span></span><br><span class="line"><span class="comment"> * populates the bean instance, applies post-processors, etc.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #doCreateBean</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 确保 BeanDefinition 中的 Class 被加载</span></span><br><span class="line">   Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">   <span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">      mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 准备方法覆写，这里又涉及到一个概念：MethodOverrides，它来自于 bean 定义中的 &lt;lookup-method /&gt; </span></span><br><span class="line">   <span class="comment">// 和 &lt;replaced-method /&gt;，如果读者感兴趣，回到 bean 解析的地方看看对这两个标签的解析。</span></span><br><span class="line">   <span class="comment">// 我在附录中也对这两个标签的相关知识点进行了介绍，读者可以移步去看看</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      mbdToUse.prepareMethodOverrides();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">            beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 让 InstantiationAwareBeanPostProcessor 在这一步有机会返回代理，</span></span><br><span class="line">      <span class="comment">// 在 《Spring AOP 源码分析》那篇文章中有解释，这里先跳过</span></span><br><span class="line">      Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">      <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">return</span> bean; </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 重头戏，创建 bean</span></span><br><span class="line">   Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">   <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">      logger.debug(<span class="string">"Finished creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建-Bean"><a href="#创建-Bean" class="headerlink" title="创建 Bean"></a>创建 Bean</h4><p>我们继续往里看 doCreateBean 这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Actually create the specified bean. Pre-creation processing has already happened</span></span><br><span class="line"><span class="comment"> * at this point, e.g. checking &#123;<span class="doctag">@code</span> postProcessBeforeInstantiation&#125; callbacks.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Differentiates between default bean instantiation, use of a</span></span><br><span class="line"><span class="comment"> * factory method, and autowiring a constructor.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> beanName the name of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> mbd the merged bean definition for the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args explicit arguments to use for constructor or factory method invocation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a new instance of the bean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> BeanCreationException if the bean could not be created</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateBean</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #instantiateUsingFactoryMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #autowireConstructor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> Object[] args)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Instantiate the bean.</span></span><br><span class="line">   BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">      instanceWrapper = <span class="keyword">this</span>.factoryBeanInstanceCache.remove(beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 说明不是 FactoryBean，这里实例化 Bean，这里非常关键，细节之后再说</span></span><br><span class="line">      instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 这个就是 Bean 里面的 我们定义的类 的实例，很多地方我直接描述成 "bean 实例"</span></span><br><span class="line">   <span class="keyword">final</span> Object bean = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedInstance() : <span class="keyword">null</span>);</span><br><span class="line">   <span class="comment">// 类型</span></span><br><span class="line">   Class&lt;?&gt; beanType = (instanceWrapper != <span class="keyword">null</span> ? instanceWrapper.getWrappedClass() : <span class="keyword">null</span>);</span><br><span class="line">   mbd.resolvedTargetType = beanType;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建议跳过吧，涉及接口：MergedBeanDefinitionPostProcessor</span></span><br><span class="line">   <span class="keyword">synchronized</span> (mbd.postProcessingLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!mbd.postProcessed) &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// MergedBeanDefinitionPostProcessor，这个我真不展开说了，直接跳过吧，很少用的</span></span><br><span class="line">            applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                  <span class="string">"Post-processing of merged bean definition failed"</span>, ex);</span><br><span class="line">         &#125;</span><br><span class="line">         mbd.postProcessed = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">   <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">   <span class="comment">// 下面这块代码是为了解决循环依赖的问题，以后有时间，我再对循环依赖这个问题进行解析吧</span></span><br><span class="line">   <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp;</span><br><span class="line">         isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">         logger.debug(<span class="string">"Eagerly caching bean '"</span> + beanName +</span><br><span class="line">               <span class="string">"' to allow for resolving potential circular references"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      addSingletonFactory(beanName, <span class="keyword">new</span> ObjectFactory&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getEarlyBeanReference(beanName, mbd, bean);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">   Object exposedObject = bean;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 这一步也是非常关键的，这一步负责属性装配，因为前面的实例只是实例化了，并没有设值，这里就是设值</span></span><br><span class="line">      populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">      <span class="keyword">if</span> (exposedObject != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 还记得 init-method 吗？还有 InitializingBean 接口？还有 BeanPostProcessor 接口？</span></span><br><span class="line">         <span class="comment">// 这里就是处理 bean 初始化完成后的各种回调</span></span><br><span class="line">         exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ex <span class="keyword">instanceof</span> BeanCreationException &amp;&amp; beanName.equals(((BeanCreationException) ex).getBeanName())) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (BeanCreationException) ex;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Initialization of bean failed"</span>, ex);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">      <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">            exposedObject = earlySingletonReference;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">            String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">            Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;String&gt;(dependentBeans.length);</span><br><span class="line">            <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">               <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                  actualDependentBeans.add(dependentBean);</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                     <span class="string">"Bean with name '"</span> + beanName + <span class="string">"' has been injected into other beans ["</span> +</span><br><span class="line">                     StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                     <span class="string">"] in its raw version as part of a circular reference, but has eventually been "</span> +</span><br><span class="line">                     <span class="string">"wrapped. This means that said other beans do not use the final version of the "</span> +</span><br><span class="line">                     <span class="string">"bean. This is often the result of over-eager type matching - consider using "</span> +</span><br><span class="line">                     <span class="string">"'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Register bean as disposable.</span></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Invalid destruction signature"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们已经分析完了 doCreateBean 方法，总的来说，我们已经说完了整个初始化流程。</p><p>接下来我们挑 doCreateBean 中的三个细节出来说说。一个是创建 Bean 实例的 createBeanInstance 方法，一个是依赖注入的 populateBean 方法，还有就是回调方法 initializeBean。 </p><p>注意了，接下来的这三个方法要认真说那也是极其复杂的，很多地方我就点到为止了，感兴趣的读者可以自己往里看，最好就是碰到不懂的，自己写代码去调试它。</p><h5 id="创建-Bean-实例"><a href="#创建-Bean-实例" class="headerlink" title="创建 Bean 实例"></a>创建 Bean 实例</h5><p>我们先看看 createBeanInstance 方法。需要说明的是，这个方法如果每个分支都分析下去，必然也是极其复杂冗长的，我们挑重点说。此方法的目的就是实例化我们指定的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">createBeanInstance</span><span class="params">(String beanName, RootBeanDefinition mbd, Object[] args)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 确保已经加载了此 class</span></span><br><span class="line">   Class&lt;?&gt; beanClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 校验一下这个类的访问权限</span></span><br><span class="line">   <span class="keyword">if</span> (beanClass != <span class="keyword">null</span> &amp;&amp; !Modifier.isPublic(beanClass.getModifiers()) &amp;&amp; !mbd.isNonPublicAccessAllowed()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">            <span class="string">"Bean class isn't public, and non-public access not allowed: "</span> + beanClass.getName());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getFactoryMethodName() != <span class="keyword">null</span>)  &#123;</span><br><span class="line">      <span class="comment">// 采用工厂方法实例化，不熟悉这个概念的读者请看附录，注意，不是 FactoryBean</span></span><br><span class="line">      <span class="keyword">return</span> instantiateUsingFactoryMethod(beanName, mbd, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不是第一次创建，比如第二次创建 prototype bean。</span></span><br><span class="line">   <span class="comment">// 这种情况下，我们可以从第一次创建知道，采用无参构造函数，还是构造函数依赖注入 来完成实例化</span></span><br><span class="line">   <span class="keyword">boolean</span> resolved = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">boolean</span> autowireNecessary = <span class="keyword">false</span>;</span><br><span class="line">   <span class="keyword">if</span> (args == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (mbd.constructorArgumentLock) &#123;</span><br><span class="line">         <span class="keyword">if</span> (mbd.resolvedConstructorOrFactoryMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resolved = <span class="keyword">true</span>;</span><br><span class="line">            autowireNecessary = mbd.constructorArgumentsResolved;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (resolved) &#123;</span><br><span class="line">      <span class="keyword">if</span> (autowireNecessary) &#123;</span><br><span class="line">         <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">         <span class="keyword">return</span> autowireConstructor(beanName, mbd, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 无参构造函数</span></span><br><span class="line">         <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 判断是否采用有参构造函数</span></span><br><span class="line">   Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line">   <span class="keyword">if</span> (ctors != <span class="keyword">null</span> ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">         mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args))  &#123;</span><br><span class="line">      <span class="comment">// 构造函数依赖注入</span></span><br><span class="line">      <span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用无参构造函数</span></span><br><span class="line">   <span class="keyword">return</span> instantiateBean(beanName, mbd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>挑个简单的<strong>无参构造函数</strong>构造实例来看看：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Object beanInstance;</span><br><span class="line">      <span class="keyword">final</span> BeanFactory parent = <span class="keyword">this</span>;</span><br><span class="line">      <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">         beanInstance = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               </span><br><span class="line">               <span class="keyword">return</span> getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;, getAccessControlContext());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// 实例化</span></span><br><span class="line">         beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 包装一下，返回</span></span><br><span class="line">      BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">      initBeanWrapper(bw);</span><br><span class="line">      <span class="keyword">return</span> bw;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            mbd.getResourceDescription(), beanName, <span class="string">"Instantiation of bean failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，关键的地方在于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br></pre></td></tr></table></figure><p>这里会进行实际的实例化过程，我们进去看看:</p><p>// SimpleInstantiationStrategy 59</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">instantiate</span><span class="params">(RootBeanDefinition bd, String beanName, BeanFactory owner)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 如果不存在方法覆写，那就使用 java 反射进行实例化，否则使用 CGLIB,</span></span><br><span class="line">   <span class="comment">// 方法覆写 请参见附录"方法注入"中对 lookup-method 和 replaced-method 的介绍</span></span><br><span class="line">   <span class="keyword">if</span> (bd.getMethodOverrides().isEmpty()) &#123;</span><br><span class="line">      Constructor&lt;?&gt; constructorToUse;</span><br><span class="line">      <span class="keyword">synchronized</span> (bd.constructorArgumentLock) &#123;</span><br><span class="line">         constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</span><br><span class="line">         <span class="keyword">if</span> (constructorToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;?&gt; clazz = bd.getBeanClass();</span><br><span class="line">            <span class="keyword">if</span> (clazz.isInterface()) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"Specified class is an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                  constructorToUse = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</span><br><span class="line">                     <span class="meta">@Override</span></span><br><span class="line">                     <span class="keyword">public</span> Constructor&lt;?&gt; run() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        <span class="keyword">return</span> clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">                     &#125;</span><br><span class="line">                  &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span> &#123;</span><br><span class="line">                  constructorToUse = clazz.getDeclaredConstructor((Class[]) <span class="keyword">null</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               bd.resolvedConstructorOrFactoryMethod = constructorToUse;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> BeanInstantiationException(clazz, <span class="string">"No default constructor found"</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 利用构造方法进行实例化</span></span><br><span class="line">      <span class="keyword">return</span> BeanUtils.instantiateClass(constructorToUse);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 存在方法覆写，利用 CGLIB 来完成实例化，需要依赖于 CGLIB 生成子类，这里就不展开了。</span></span><br><span class="line">      <span class="comment">// tips: 因为如果不使用 CGLIB 的话，存在 override 的情况 JDK 并没有提供相应的实例化支持</span></span><br><span class="line">      <span class="keyword">return</span> instantiateWithMethodInjection(bd, beanName, owner);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里，我们就算实例化完成了。我们开始说怎么进行属性注入。</p><h5 id="bean-属性注入"><a href="#bean-属性注入" class="headerlink" title="bean 属性注入"></a>bean 属性注入</h5><p>看完了 createBeanInstance(…) 方法，我们来看看 populateBean(…) 方法，该方法负责进行属性设值，处理依赖。</p><p>// AbstractAutowireCapableBeanFactory 1203</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// bean 实例的所有属性都在这里了</span></span><br><span class="line">   PropertyValues pvs = mbd.getPropertyValues();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (bw == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!pvs.isEmpty()) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">               mbd.getResourceDescription(), beanName, <span class="string">"Cannot apply property values to null instance"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">// Skip property population phase for null instance.</span></span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 到这步的时候，bean 实例化完成（通过工厂方法或构造方法），但是还没开始属性设值，</span></span><br><span class="line">   <span class="comment">// InstantiationAwareBeanPostProcessor 的实现类可以在这里对 bean 进行状态修改，</span></span><br><span class="line">   <span class="comment">// 我也没找到有实际的使用，所以我们暂且忽略这块吧</span></span><br><span class="line">   <span class="keyword">boolean</span> continueWithPropertyPopulation = <span class="keyword">true</span>;</span><br><span class="line">   <span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">      <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">         <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">            InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">            <span class="comment">// 如果返回 false，代表不需要进行后续的属性设值，也不需要再经过其他的 BeanPostProcessor 的处理</span></span><br><span class="line">            <span class="keyword">if</span> (!ibp.postProcessAfterInstantiation(bw.getWrappedInstance(), beanName)) &#123;</span><br><span class="line">               continueWithPropertyPopulation = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (!continueWithPropertyPopulation) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">         mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">      MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过名字找到所有属性值，如果是 bean 依赖，先初始化依赖的 bean。记录依赖关系</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">         autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 通过类型装配。复杂一些</span></span><br><span class="line">      <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">         autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      pvs = newPvs;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">boolean</span> hasInstAwareBpps = hasInstantiationAwareBeanPostProcessors();</span><br><span class="line">   <span class="keyword">boolean</span> needsDepCheck = (mbd.getDependencyCheck() != RootBeanDefinition.DEPENDENCY_CHECK_NONE);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (hasInstAwareBpps || needsDepCheck) &#123;</span><br><span class="line">      PropertyDescriptor[] filteredPds = filterPropertyDescriptorsForDependencyCheck(bw, mbd.allowCaching);</span><br><span class="line">      <span class="keyword">if</span> (hasInstAwareBpps) &#123;</span><br><span class="line">         <span class="keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bp <span class="keyword">instanceof</span> InstantiationAwareBeanPostProcessor) &#123;</span><br><span class="line">               InstantiationAwareBeanPostProcessor ibp = (InstantiationAwareBeanPostProcessor) bp;</span><br><span class="line">               <span class="comment">// 这里有个非常有用的 BeanPostProcessor 进到这里: AutowiredAnnotationBeanPostProcessor</span></span><br><span class="line">               <span class="comment">// 对采用 @Autowired、@Value 注解的依赖进行设值，这里的内容也是非常丰富的，不过本文不会展开说了，感兴趣的读者请自行研究</span></span><br><span class="line">               pvs = ibp.postProcessPropertyValues(pvs, filteredPds, bw.getWrappedInstance(), beanName);</span><br><span class="line">               <span class="keyword">if</span> (pvs == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (needsDepCheck) &#123;</span><br><span class="line">         checkDependencies(beanName, mbd, filteredPds, pvs);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 设置 bean 实例的属性值</span></span><br><span class="line">   applyPropertyValues(beanName, mbd, bw, pvs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="initializeBean"><a href="#initializeBean" class="headerlink" title="initializeBean"></a>initializeBean</h5><p>属性注入完成后，这一步其实就是处理各种回调了，这块代码比较简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Object&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            invokeAwareMethods(beanName, bean);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;, getAccessControlContext());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果 bean 实现了 BeanNameAware、BeanClassLoaderAware 或 BeanFactoryAware 接口，回调</span></span><br><span class="line">      invokeAwareMethods(beanName, bean);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   Object wrappedBean = bean;</span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessBeforeInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 处理 bean 中定义的 init-method，</span></span><br><span class="line">      <span class="comment">// 或者如果 bean 实现了 InitializingBean 接口，调用 afterPropertiesSet() 方法</span></span><br><span class="line">      invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">            (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">            beanName, <span class="string">"Invocation of init method failed"</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">      <span class="comment">// BeanPostProcessor 的 postProcessAfterInitialization 回调</span></span><br><span class="line">      wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家发现没有，BeanPostProcessor 的两个回调都发生在这边，只不过中间处理了 init-method，是不是和读者原来的认知有点不一样了？</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="id-和-name"><a href="#id-和-name" class="headerlink" title="id 和 name"></a>id 和 name</h3><p>每个 Bean 在 Spring 容器中都有一个唯一的名字（beanName）和 0 个或多个别名（aliases）。</p><p>我们从 Spring 容器中获取 Bean 的时候，可以根据 beanName，也可以通过别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beanFactory.getBean(<span class="string">"beanName or alias"</span>);</span><br></pre></td></tr></table></figure><p>在配置 <code>&lt;bean /&gt;</code> 的过程中，我们可以配置 id 和 name，看几个例子就知道是怎么回事了。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，别名有 3 个，分别为 m1、m2、m3。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"m1, m2, m3"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 m1，别名有 2 个，分别为 m2、m3。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>beanName 为：com.javadoop.example.MessageServiceImpl#0，</p><p>别名 1 个，为： com.javadoop.example.MessageServiceImpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"messageService"</span> <span class="attr">class</span>=<span class="string">"com.javadoop.example.MessageServiceImpl"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上配置的结果就是：beanName 为 messageService，没有别名。</p><h3 id="配置是否允许-Bean-覆盖、是否允许循环依赖"><a href="#配置是否允许-Bean-覆盖、是否允许循环依赖" class="headerlink" title="配置是否允许 Bean 覆盖、是否允许循环依赖"></a>配置是否允许 Bean 覆盖、是否允许循环依赖</h3><p>我们说过，默认情况下，allowBeanDefinitionOverriding 属性为 null。如果在同一配置文件中 Bean id 或 name 重复了，会抛错，但是如果不是同一配置文件中，会发生覆盖。</p><p>可是有些时候我们希望在系统启动的过程中就严格杜绝发生 Bean 覆盖，因为万一出现这种情况，会增加我们排查问题的成本。</p><p>循环依赖说的是 A 依赖 B，而 B 又依赖 A。或者是 A 依赖 B，B 依赖 C，而 C 却依赖 A。默认 allowCircularReferences 也是 null。</p><p>它们两个属性是一起出现的，必然可以在同一个地方一起进行配置。</p><p>添加这两个属性的作者 Juergen Hoeller 在这个 <a href="https://jira.spring.io/browse/SPR-4374" target="_blank" rel="noopener">jira</a> 的讨论中说明了怎么配置这两个属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoBeanOverridingContextLoader</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">customizeContext</span><span class="params">(ServletContext servletContext, ConfigurableWebApplicationContext applicationContext)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.customizeContext(servletContext, applicationContext);</span><br><span class="line">    AbstractRefreshableApplicationContext arac = (AbstractRefreshableApplicationContext) applicationContext;</span><br><span class="line">    arac.setAllowBeanDefinitionOverriding(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">context</span>.<span class="title">ContextLoaderListener</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> ContextLoader <span class="title">createContextLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NoBeanOverridingContextLoader();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.javadoop.MyContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果以上方式不能满足你的需求，请参考这个链接：<a href="http://blog.csdn.net/zgmzyr/article/details/39380477" target="_blank" rel="noopener">解决spring中不同配置文件中存在name或者id相同的bean可能引起的问题</a></p><h3 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h3><p>我们可以把不同环境的配置分别配置到单独的文件中，举个例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>应该不必做过多解释了吧，看每个文件第一行的 profile=””。</p><p>当然，我们也可以在一个配置文件中使用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jdbc</span>=<span class="string">"http://www.springframework.org/schema/jdbc"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:jee</span>=<span class="string">"http://www.springframework.org/schema/jee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"..."</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbc:embedded-database</span> <span class="attr">id</span>=<span class="string">"dataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/schema.sql"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">jdbc:script</span> <span class="attr">location</span>=<span class="string">"classpath:com/bank/config/sql/test-data.sql"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbc:embedded-database</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"production"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jee:jndi-lookup</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">jndi-name</span>=<span class="string">"java:comp/env/jdbc/datasource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>理解起来也很简单吧。</p><p>接下来的问题是，怎么使用特定的 profile 呢？Spring 在启动的过程中，会去寻找 “spring.profiles.active” 的属性值，根据这个属性值来的。那怎么配置这个值呢？</p><p>Spring 会在这几个地方寻找 spring.profiles.active 的属性值：操作系统环境变量、JVM 系统变量、web.xml 中定义的参数、JNDI。</p><p>最简单的方式莫过于在程序启动的时候指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dspring.profiles.active=<span class="string">"profile1,profile2"</span></span><br></pre></td></tr></table></figure><blockquote><p>profile 可以激活多个</p></blockquote><p>当然，我们也可以通过代码的形式从 Environment 中设置 profile：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnotationConfigApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">ctx.getEnvironment().setActiveProfiles(<span class="string">"development"</span>);</span><br><span class="line">ctx.register(SomeConfig<span class="class">.<span class="keyword">class</span>, <span class="title">StandaloneDataConfig</span>.<span class="title">class</span>, <span class="title">JndiDataConfig</span>.<span class="title">class</span>)</span>;</span><br><span class="line">ctx.refresh(); <span class="comment">// 重启</span></span><br></pre></td></tr></table></figure><p>如果是 Spring Boot 的话更简单，我们一般会创建 application.properties、application-dev.properties、application-prod.properties 等文件，其中 application.properties 配置各个环境通用的配置，application-{profile}.properties 中配置特定环境的配置，然后在启动的时候指定 profile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java<span class="params"> -Dspring</span>.profiles.active=prod<span class="params"> -jar</span> JavaDoop.jar</span><br></pre></td></tr></table></figure><p>如果是单元测试中使用的话，在测试类中使用 @ActiveProfiles 指定，这里就不展开了。</p><h3 id="工厂模式生成-Bean"><a href="#工厂模式生成-Bean" class="headerlink" title="工厂模式生成 Bean"></a>工厂模式生成 Bean</h3><p>请读者注意 factory-bean 和 FactoryBean 的区别。这节说的是前者，是说静态工厂或实例工厂，而后者是 Spring 中的特殊接口，代表一类特殊的 Bean，附录的下面一节会介绍 FactoryBean。</p><p>设计模式里，工厂方法模式分静态工厂和实例工厂，我们分别看看 Spring 中怎么配置这两个，来个代码示例就什么都清楚了。</p><p>静态工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">class</span>=<span class="string">"examples.ClientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientService();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ClientService</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientService <span class="title">createInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例工厂：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"serviceLocator"</span> <span class="attr">class</span>=<span class="string">"examples.DefaultServiceLocator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject any dependencies required by this locator bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"clientService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createClientServiceInstance"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-bean</span>=<span class="string">"serviceLocator"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">factory-method</span>=<span class="string">"createAccountServiceInstance"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultServiceLocator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ClientService clientService = <span class="keyword">new</span> ClientServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AccountService accountService = <span class="keyword">new</span> AccountServiceImpl();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClientService <span class="title">createClientServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> clientService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AccountService <span class="title">createAccountServiceInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accountService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h3><p>FactoryBean 适用于 Bean 的创建过程比较复杂的场景，比如数据库连接池的创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">Class&lt;T&gt; <span class="title">getObjectType</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123; </span><br><span class="line">    <span class="keyword">private</span> Car car ;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setCar</span><span class="params">(Car car)</span></span>&#123; <span class="keyword">this</span>.car = car;  &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设现在需要创建一个 Person 的 Bean，首先我们需要一个 Car 的实例，我们这里假设 Car 的实例创建很麻烦，那么我们可以把创建 Car 的复杂过程包装起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCarFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Car</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String make; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> year ;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMake</span><span class="params">(String m)</span></span>&#123; <span class="keyword">this</span>.make =m ; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setYear</span><span class="params">(<span class="keyword">int</span> y)</span></span>&#123; <span class="keyword">this</span>.year = y; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Car <span class="title">getObject</span><span class="params">()</span></span>&#123; </span><br><span class="line">      <span class="comment">// 这里我们假设 Car 的实例化过程非常复杂，反正就不是几行代码可以写完的那种</span></span><br><span class="line">      CarBuilder cb = CarBuilder.car();</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span>(year!=<span class="number">0</span>) cb.setYear(<span class="keyword">this</span>.year);</span><br><span class="line">      <span class="keyword">if</span>(StringUtils.hasText(<span class="keyword">this</span>.make)) cb.setMake( <span class="keyword">this</span>.make ); </span><br><span class="line">      <span class="keyword">return</span> cb.factory(); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class&lt;Car&gt; <span class="title">getObjectType</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Car<span class="class">.<span class="keyword">class</span> </span>; &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看看装配的时候是怎么配置的：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.MyCarFactoryBean"</span> <span class="attr">id</span> = <span class="string">"car"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"make"</span> <span class="attr">value</span> =<span class="string">"Honda"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"year"</span> <span class="attr">value</span> =<span class="string">"1984"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span> = <span class="string">"com.javadoop.Person"</span> <span class="attr">id</span> = <span class="string">"josh"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> = <span class="string">"car"</span> <span class="attr">ref</span> = <span class="string">"car"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>看到不一样了吗？id 为 “car” 的 bean 其实指定的是一个 FactoryBean，不过配置的时候，我们直接让配置 Person 的 Bean 直接依赖于这个 FactoryBean 就可以了。中间的过程 Spring 已经封装好了。</p><p>说到这里，我们再来点干货。我们知道，现在还用 xml 配置 Bean 依赖的越来越少了，更多时候，我们可能会采用 java  config 的方式来配置，这里有什么不一样呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarConfiguration</span> </span>&#123; </span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyCarFactoryBean <span class="title">carFactoryBean</span><span class="params">()</span></span>&#123; </span><br><span class="line">      MyCarFactoryBean cfb = <span class="keyword">new</span> MyCarFactoryBean();</span><br><span class="line">      cfb.setMake(<span class="string">"Honda"</span>);</span><br><span class="line">      cfb.setYear(<span class="number">1984</span>);</span><br><span class="line">      <span class="keyword">return</span> cfb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">aPerson</span><span class="params">()</span></span>&#123; </span><br><span class="line">    Person person = <span class="keyword">new</span> Person();</span><br><span class="line">      <span class="comment">// 注意这里的不同</span></span><br><span class="line">    person.setCar(carFactoryBean().getObject());</span><br><span class="line">    <span class="keyword">return</span> person; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，其实我们的思路也很简单，把 MyCarFactoryBean 看成是一个简单的 Bean 就可以了，不必理会什么 FactoryBean，它是不是 FactoryBean 和我们没关系。</p><h3 id="初始化-Bean-的回调"><a href="#初始化-Bean-的回调" class="headerlink" title="初始化 Bean 的回调"></a>初始化 Bean 的回调</h3><p>有以下四种方案：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">init-method</span>=<span class="string">"init"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some initialization work</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(initMethod = <span class="string">"init"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Foo <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Foo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostConstruct</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁-Bean-的回调"><a href="#销毁-Bean-的回调" class="headerlink" title="销毁 Bean 的回调"></a>销毁 Bean 的回调</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"exampleInitBean"</span> <span class="attr">class</span>=<span class="string">"examples.ExampleBean"</span> <span class="attr">destroy-method</span>=<span class="string">"cleanup"</span>/&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnotherExampleBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do some destruction work (like releasing pooled connections)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(destroyMethod = <span class="string">"cleanup"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Bar <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Bar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cleanup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ConversionService"><a href="#ConversionService" class="headerlink" title="ConversionService"></a>ConversionService</h3><p>既然文中说到了这个，顺便提一下好了。</p><p>最有用的场景就是，它用来将前端传过来的参数和后端的 controller 方法上的参数进行绑定的时候用。</p><p>像前端传过来的字符串、整数要转换为后端的 String、Integer 很容易，但是如果 controller 方法需要的是一个枚举值，或者是 Date 这些非基础类型（含基础类型包装类）值的时候，我们就可以考虑采用 ConversionService 来进行转换。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.javadoop.learning.utils.StringToEnumConverterFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>ConversionService 接口很简单，所以要自定义一个 convert 的话也很简单。</p><p>下面再说一个实现这种转换很简单的方式，那就是实现 Converter 接口。</p><p>来看一个很简单的例子，这样比什么都管用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> DateUtils.parseDate(source, <span class="string">"yyyy-MM-dd"</span>, <span class="string">"yyyy-MM-dd HH:mm:ss"</span>, <span class="string">"yyyy-MM-dd HH:mm"</span>, <span class="string">"HH:mm:ss"</span>, <span class="string">"HH:mm"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要注册这个 Bean 就可以了。这样，前端往后端传的时间描述字符串就很容易绑定成 Date 类型了，不需要其他任何操作。</p><h3 id="Bean-继承"><a href="#Bean-继承" class="headerlink" title="Bean 继承"></a>Bean 继承</h3><p>在初始化 Bean 的地方，我们说过了这个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br></pre></td></tr></table></figure><p>这里涉及到的就是 <code>&lt;bean parent=&quot;&quot; /&gt;</code> 中的 parent 属性，我们来看看 Spring 中是用这个来干什么的。</p><p>首先，我们要明白，这里的继承和 java 语法中的继承没有任何关系，不过思路是相通的。child bean 会继承 parent bean 的所有配置，也可以覆盖一些配置，当然也可以新增额外的配置。</p><p>Spring 中提供了继承自 AbstractBeanDefinition 的 <code>ChildBeanDefinition</code> 来表示 child bean。</p><p>看如下一个例子:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBean"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.TestBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"inheritsWithDifferentClass"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.beans.DerivedTestBean"</span></span><br><span class="line">        parent=<span class="string">"inheritedTestBean"</span> init-method=<span class="string">"initialize"</span>&gt;</span><br><span class="line">        </span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"override"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>parent bean 设置了 <code>abstract=&quot;true&quot;</code> 所以它不会被实例化，child bean 继承了 parent bean 的两个属性，但是对 name 属性进行了覆写。</p><p>child bean 会继承 scope、构造器参数值、属性值、init-method、destroy-method 等等。</p><p>当然，我不是说 parent bean 中的 abstract = true 在这里是必须的，只是说如果加上了以后 Spring 在实例化 singleton beans 的时候会忽略这个 bean。</p><p>比如下面这个极端 parent bean，它没有指定 class，所以毫无疑问，这个 bean 的作用就是用来充当模板用的 parent bean，此处就必须加上 abstract = true。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"inheritedTestBeanWithoutClass"</span> <span class="keyword">abstract</span>=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> value=<span class="string">"parent"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"age"</span> value=<span class="string">"1"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h3 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h3><p>一般来说，我们的应用中大多数的 Bean 都是 singleton 的。singleton 依赖 singleton，或者 prototype 依赖 prototype 都很好解决，直接设置属性依赖就可以了。</p><p>但是，如果是 singleton 依赖 prototype 呢？这个时候不能用属性依赖，因为如果用属性依赖的话，我们每次其实拿到的还是第一次初始化时候的 bean。</p><p>一种解决方案就是不要用属性依赖，每次获取依赖的 bean 的时候从 BeanFactory 中取。这个也是大家最常用的方式了吧。怎么取，我就不介绍了，大部分 Spring 项目大家都会定义那么个工具类的。</p><p>另一种解决方案就是这里要介绍的通过使用 Lookup method。</p><h4 id="lookup-method"><a href="#lookup-method" class="headerlink" title="lookup-method"></a>lookup-method</h4><p>我们来看一下 Spring Reference 中提供的一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> fiona.apple;</span><br><span class="line"></span><br><span class="line"><span class="comment">// no more Spring imports!</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// grab a new instance of the appropriate Command interface</span></span><br><span class="line">        Command command = createCommand();</span><br><span class="line">        <span class="comment">// set the state on the (hopefully brand new) Command instance</span></span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// okay... but where is the implementation of this method?</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>xml 配置 <code>&lt;lookup-method /&gt;</code>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- a stateful bean deployed as a prototype (non-singleton) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myCommand"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.AsyncCommand"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- inject dependencies here as required --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- commandProcessor uses statefulCommandHelper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"commandManager"</span> <span class="attr">class</span>=<span class="string">"fiona.apple.CommandManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">"createCommand"</span> <span class="attr">bean</span>=<span class="string">"myCommand"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Spring 采用 <strong>CGLIB 生成字节码</strong>的方式来生成一个子类。我们定义的类不能定义为 final class，抽象方法上也不能加 final。</p><p>lookup-method 上的配置也可以采用注解来完成，这样就可以不用配置 <code>&lt;lookup-method /&gt;</code> 了，其他不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span>(<span class="string">"myCommand"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Command <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，既然用了注解，要配置注解扫描：<code>&lt;context:component-scan base-package=&quot;com.javadoop&quot; /&gt;</code></p></blockquote><p>甚至，我们可以像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">process</span><span class="params">(Object commandState)</span> </span>&#123;</span><br><span class="line">        MyCommand command = createCommand();</span><br><span class="line">        command.setState(commandState);</span><br><span class="line">        <span class="keyword">return</span> command.execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Lookup</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> MyCommand <span class="title">createCommand</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>上面的返回值用了 MyCommand，当然，如果 Command 只有一个实现类，那返回值也可以写 Command。</p></blockquote><h4 id="replaced-method"><a href="#replaced-method" class="headerlink" title="replaced-method"></a>replaced-method</h4><p>记住它的功能，就是替换掉 bean 中的一些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValueCalculator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">computeValue</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// some real code...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// some other methods...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法覆写，注意要实现 MethodReplacer 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReplacementComputeValue</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">springframework</span>.<span class="title">beans</span>.<span class="title">factory</span>.<span class="title">support</span>.<span class="title">MethodReplacer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">reimplement</span><span class="params">(Object o, Method m, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// get the input value, work with it, and return a computed result</span></span><br><span class="line">        String input = (String) args[<span class="number">0</span>];</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> ...;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置也很简单：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myValueCalculator"</span> <span class="attr">class</span>=<span class="string">"x.y.z.MyValueCalculator"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义 computeValue 这个方法要被替换掉 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">replaced-method</span> <span class="attr">name</span>=<span class="string">"computeValue"</span> <span class="attr">replacer</span>=<span class="string">"replacementComputeValue"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg-type</span>&gt;</span>String<span class="tag">&lt;/<span class="name">arg-type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">replaced-method</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"replacementComputeValue"</span> <span class="attr">class</span>=<span class="string">"a.b.c.ReplacementComputeValue"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>arg-type 明显不是必须的，除非存在方法重载，这样必须通过参数类型列表来判断这里要覆盖哪个方法。</p></blockquote><h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>应该说 BeanPostProcessor 概念在 Spring 中也是比较重要的。我们看下接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看这个接口中的两个方法名字我们大体上可以猜测 bean 在初始化之前会执行 postProcessBeforeInitialization 这个方法，初始化完成之后会执行 postProcessAfterInitialization 这个方法。但是，这么理解是非常片面的。</p><p>首先，我们要明白，除了我们自己定义的 BeanPostProcessor 实现外，Spring 容器在启动时自动给我们也加了几个。如在获取 BeanFactory 的 obtainFactory() 方法结束后的 prepareBeanFactory(factory)，大家仔细看会发现，Spring 往容器中添加了这两个 BeanPostProcessor：ApplicationContextAwareProcessor、ApplicationListenerDetector。</p><p>我们回到这个接口本身，读者请看第一个方法，这个方法接受的第一个参数是 bean 实例，第二个参数是 bean 的名字，重点在返回值将会作为新的 bean 实例，所以，没事的话这里不能随便返回个 null。</p><p>那意味着什么呢？我们很容易想到的就是，我们这里可以对一些我们想要修饰的 bean 实例做一些事情。但是对于 Spring 框架来说，它会决定是不是要在这个方法中返回 bean 实例的代理，这样就有更大的想象空间了。</p><p>最后，我们说说如果我们自己定义一个 bean 实现 BeanPostProcessor 的话，它的执行时机是什么时候？</p><p>如果仔细看了代码分析的话，其实很容易知道了，在 bean 实例化完成、属性注入完成之后，会执行回调方法，具体请参见类 AbstractAutowireCapableBeanFactory#initBean 方法。</p><p>首先会回调几个实现了 Aware 接口的 bean，然后就开始回调 BeanPostProcessor 的 postProcessBeforeInitialization 方法，之后是回调 init-method，然后再回调 BeanPostProcessor 的 postProcessAfterInitialization 方法。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>按理说，总结应该写在附录前面，我就不讲究了。</p><p>在花了那么多时间后，这篇文章终于算是基本写完了，大家在惊叹 Spring 给我们做了那么多的事的时候，应该透过现象看本质，去理解 Spring 写得好的地方，去理解它的设计思想。</p><p>本文的缺陷在于对 Spring 预初始化 singleton beans 的过程分析不够，主要是代码量真的比较大，分支旁路众多。同时，虽然附录条目不少，但是庞大的 Spring 真的引出了很多的概念，希望日后有精力可以慢慢补充一些。</p><p>（全文完）</p><p><strong><em>郑重声明</em></strong>  :  <strong>本文转载自我关注的一位大佬的博客,原文链接<a href="https://www.javadoop.com/post/spring-ioc" target="_blank" rel="noopener">原文</a> 如有侵权还请联系本人删除,仅做知识传播与记录,无剽窃冒犯之意.</strong></p><p><strong>可在本人个人博客 <a href="https://www.enjoyican.com/posts/Spring-IOC/">blog-spring-ioc</a>下留言或者在<a href="https://blog.csdn.net/u010408502/article/details/105067101" target="_blank" rel="noopener">csdn-spring-ioc</a>中留言</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Spring 最重要的概念是 IOC 和 AOP，本篇文章其实就是要带领大家来分析下 Spring 的 IOC 容器。既然大家平时都要用到 Spring，怎么可以不好好了解 Spring 呢？阅读本文并不能让你成为 Spring 专家，不过一定有助于大家理解 Spring 
      
    
    </summary>
    
    
      <category term="框架" scheme="https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://www.enjoyican.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>spring事件监听</title>
    <link href="https://www.enjoyican.com/posts/spring-application-listener/"/>
    <id>https://www.enjoyican.com/posts/spring-application-listener/</id>
    <published>2019-09-06T12:29:30.000Z</published>
    <updated>2019-09-07T02:40:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="业务场景："><a href="#业务场景：" class="headerlink" title="业务场景："></a>业务场景：</h3><p>在一个加了事务的service方法中，有数据库操作，有MQ消息的发送，MQ发送后消息消费端需要回查数据库，目前存在的一个情况是在数据库操作事务尚未提交的情况下，消息就发送成功了，此时消息消费者回查数据库，数据依然是未更改的状态，导致消息消费失败。</p><h3 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h3><p>我们希望能够控制在事务提交成功之后消息再消费</p><h3 id="方案："><a href="#方案：" class="headerlink" title="方案："></a>方案：</h3><p>采用spring事件监听机制，当监听到事务成功提交后，开始发布消息：</p><h4 id="1-事件发布者需要实现ApplicationEventPublisherAware接口："><a href="#1-事件发布者需要实现ApplicationEventPublisherAware接口：" class="headerlink" title="1.事件发布者需要实现ApplicationEventPublisherAware接口："></a>1.事件发布者需要实现ApplicationEventPublisherAware接口：</h4><p>相关详细解释可以参考以下博客：<a href="https://www.cnblogs.com/takumicx/p/9972461.html#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">深入理解spring容器内事件发布监听机制</a></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMqEventPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (eventPublisher == <span class="keyword">null</span>) &#123;</span><br><span class="line">            eventPublisher = applicationEventPublisher;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@description</span> 发布事件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(BaseEvent event)</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"===&gt; 发布sendMq事件:  &#123;&#125;"</span>, event);</span><br><span class="line">        eventPublisher.publishEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">publishMqEvent</span><span class="params">(String topic, String tag, MessageObject messageObject)</span> </span>&#123;</span><br><span class="line">        SendMqParam sendMqParam = <span class="keyword">new</span> SendMqParam();</span><br><span class="line">        sendMqParam.setTopic(topic);</span><br><span class="line">        sendMqParam.setTag(tag);</span><br><span class="line">        sendMqParam.setMessageObject(messageObject);</span><br><span class="line">        <span class="keyword">this</span>.publishEvent(<span class="keyword">new</span> BaseEvent(sendMqParam));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中要发布的事件体BaseEvent继承自ApplicationEvent：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">BaseEvent</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ApplicationEvent</span> </span>&#123;</span><br><span class="line">   <span class="comment">//具体消息体自定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-在事务方法中进行事件发布："><a href="#2-在事务方法中进行事件发布：" class="headerlink" title="2.在事务方法中进行事件发布："></a>2.在事务方法中进行事件发布：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="meta">@Transactional</span>(rollbackFor = Exception<span class="class">.<span class="keyword">class</span>, <span class="title">propagation</span> </span>= Propagation.REQUIRES_NEW)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processOneAchieve</span><span class="params">(UpgradeStoreAchievementEntity storeAchievementEntity)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//其他数据库操作相关的业务逻辑</span></span><br><span class="line">       </span><br><span class="line">       <span class="comment">//事件发布</span></span><br><span class="line">           UpgradeOperateMqo upgradeOperateMqo = <span class="keyword">new</span> UpgradeOperateMqo();</span><br><span class="line">           upgradeOperateMqo.setStarstoreId(currentStarstoreId);</span><br><span class="line">           sendMqEventPublisher.publishMqEvent(MessageConstant.STARSTORE_RELATION_TOPIC,</span><br><span class="line">                   MessageConstant.STARSTORE_UPGRADE_OPERATE_TAG, MessageBuilder.overMessage(upgradeOperateMqo));</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           distLockSservice.unlock(lockResult);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-事件监听者通过注解监听发布的事件"><a href="#3-事件监听者通过注解监听发布的事件" class="headerlink" title="3.事件监听者通过注解监听发布的事件"></a>3.事件监听者通过注解监听发布的事件</h4><p>通过在方法上增加注解@TransactionalEventListener进行事件监听消费（该注解只监听事务相关的事件），其中参数phase参数可以控制监听到事件后处理事件与提交事务的前后关系：</p><p>参数值有下面四种：<br><strong>BEFORE_COMMIT,</strong><br><strong>AFTER_COMMIT,</strong><br><strong>AFTER_ROLLBACK,</strong><br><strong>AFTER_COMPLETION;</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMqEventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RocketMQTemplate rocketMQTemplate;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@TransactionalEventListener</span>(fallbackExecution = <span class="keyword">true</span>, phase = TransactionPhase.AFTER_COMMIT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(BaseEvent&lt;SendMqParam&gt; event)</span> </span>&#123;</span><br><span class="line">        SendMqParam sendMqParam = (SendMqParam) event.getSource();</span><br><span class="line">        String name = Thread.currentThread().getName();</span><br><span class="line">        log.info(<span class="string">"===&gt; 收到sendMq事件:  &#123;&#125;，线程名为： &#123;&#125;"</span>, sendMqParam, name);</span><br><span class="line">        rocketMQTemplate.sendNormal(sendMqParam.getTopic(), sendMqParam.getTag(), sendMqParam.getMessageObject());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>注意spring事件发布者和监听者都需要加入spring管理，@Component注解不要忘记</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/timg.jpg" alt="永不言败" title="">                </div>                <div class="image-caption">永不言败</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;业务场景：&quot;&gt;&lt;a href=&quot;#业务场景：&quot; class=&quot;headerlink&quot; title=&quot;业务场景：&quot;&gt;&lt;/a&gt;业务场景：&lt;/h3&gt;&lt;p&gt;在一个加了事务的service方法中，有数据库操作，有MQ消息的发送，MQ发送后消息消费端需要回查数据库，目前存在的
      
    
    </summary>
    
    
      <category term="框架" scheme="https://www.enjoyican.com/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="spring" scheme="https://www.enjoyican.com/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>树和图笔记</title>
    <link href="https://www.enjoyican.com/posts/tree/"/>
    <id>https://www.enjoyican.com/posts/tree/</id>
    <published>2019-03-20T14:19:30.000Z</published>
    <updated>2019-03-20T14:19:30.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.enjoyican.com/img/datastruct/1-1.png" alt="树和图" title="">                </div>                <div class="image-caption">树和图</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="https://www.enjoyican.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="datastructure" scheme="https://www.enjoyican.com/tags/datastructure/"/>
    
  </entry>
  
</feed>
